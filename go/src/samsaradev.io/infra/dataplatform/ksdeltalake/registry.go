package ksdeltalake

import (
	"fmt"
	"sort"

	"samsaradev.io/helpers/samtime"
	"samsaradev.io/hubproto"
	"samsaradev.io/hubproto/aitwowayagentproto"
	"samsaradev.io/hubproto/assethealthproto"
	"samsaradev.io/hubproto/atis"
	"samsaradev.io/hubproto/bifrost"
	"samsaradev.io/hubproto/bleproxyproto"
	"samsaradev.io/hubproto/brakemonitoringproto"
	"samsaradev.io/hubproto/cloudbackupproto"
	"samsaradev.io/hubproto/fwenumproto"
	"samsaradev.io/hubproto/logeventproto"
	"samsaradev.io/hubproto/maptileproto"
	"samsaradev.io/hubproto/nrfzephyrproto"
	"samsaradev.io/hubproto/objectstatproto"
	"samsaradev.io/hubproto/plc4trucksproto"
	"samsaradev.io/hubproto/qrcodeproto"
	"samsaradev.io/hubproto/vgmcuobjectstatproto"
	"samsaradev.io/hubproto/workforcehubproto"
	"samsaradev.io/infra/dataplatform/amundsen/amundsentags"
	"samsaradev.io/infra/dataplatform/amundsen/metadatahelpers"
	"samsaradev.io/infra/dataplatform/databricks"
	"samsaradev.io/infra/dataplatform/ni/dataplatformconsts"
	"samsaradev.io/infra/dataplatform/sparktypes"
	"samsaradev.io/libs/ni/infraconsts"
	"samsaradev.io/libs/ni/pointer"
	"samsaradev.io/team"
	"samsaradev.io/team/components"
)

var registry = map[string]Table{}

func mustAddTable(t Table) {
	if _, ok := registry[t.Name]; ok {
		panic(fmt.Sprintf("%s already exists", t.Name))
	}
	registry[t.Name] = t
}

func AllTables() []Table {
	tables := make([]Table, 0, len(registry))
	for _, t := range registry {
		tables = append(tables, t)
	}
	sort.Slice(tables, func(i, j int) bool {
		return tables[i].Name < tables[j].Name
	})
	return tables
}

func AllS3BigStatTables() []Table {
	var tables []Table
	for _, t := range registry {
		if t.S3BigStatSchema != nil {
			tables = append(tables, t)
		}
	}
	sort.Slice(tables, func(i, j int) bool {
		return tables[i].Name < tables[j].Name
	})
	return tables
}

func AllProductionTables() []Table {
	var tables []Table
	for _, t := range registry {
		if t.Production {
			tables = append(tables, t)
		}
	}
	sort.Slice(tables, func(i, j int) bool {
		return tables[i].Name < tables[j].Name
	})
	return tables
}

func LookupTable(name string) (Table, bool) {
	t, ok := registry[name]
	return t, ok
}

func rawStats() []Stat {
	return []Stat{ // lint: +sorted
		{
			Kind:                     StatKindLocation,
			Production:               true,
			DataModelStat:            true,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			MetadataInfo: &MetadataInfo{
				Description:            "Metadata about the location of a device at a given point in time",
				Frequency:              FrequencyOnChange("every five seconds if a device is moving"),
				IntValueDescription:    "",
				DoubleValueDescription: "",
				ColumnDescriptions: map[string]string{
					"value.time":                                              "the time at which this location was measured",
					"value.latitude":                                          "angular distance north / south of the equator, in degrees",
					"value.longitude":                                         "angular distance east / west of Greenwich, England, in degrees",
					"value.gps_speed_meters_per_second":                       "the speed of the device in meters per second as measured by the GPS",
					"value.gps_speed_invalid":                                 "true if the GPS speed is invalid, for instance if the device is stationary sometimes speed can't be trusted",
					"value.heading_degrees":                                   "the heading of the asset, with 0 corresponding to true north, 90 degrees to east, 180 degrees to south, and 270 degrees to west",
					"value.heading_invalid":                                   "true if the heading is invalid, for instance if the device is stationary heading isn't known",
					"value.hdop":                                              "horizontal dilution of precision; specifies propagation of uncertainty in the measurement of the GPS coordinates",
					"value.vdop":                                              "vertical dilution of precision; specifies propagation of uncertainty in the measurement of the GPS coordinates",
					"value.altitude_meters":                                   "the altitude above mean sea level, in meters",
					"value.altitude_invalid":                                  "true if the altitude is invalid, for instance if the device is stationary altitude isn't known",
					"value.geoid_height_correction_meters":                    "elevation delta between the mean sea level (MSL) and the WSG84 ellipsoid",
					"value.has_revgeo":                                        "whether or not reverse geolocation to get additional data was performed on this datapoint",
					"value.revgeo_street":                                     "the street corresponding to the latitude / longitude of this device as determined by reverse geolocation",
					"value.revgeo_city":                                       "the city corresponding to the latitude / longitude of this device as determined by reverse geolocation",
					"value.revgeo_state":                                      "the country corresponding to the latitude / longitude of this device as determined by reverse geolocation",
					"value.revgeo_country":                                    "the country corresponding to the latitude / longitude of this device as determined by reverse geolocation",
					"value.has_speed_limit":                                   "whether or not this location datapoint contains speed limit data in speed_limit_meters_per_second",
					"value.speed_limit_meters_per_second":                     "if has_speed_limit is true, the speed limit of the way at this specific latitude / longitude",
					"value.has_toll":                                          "if there is any data on tolls for the way corresponding to this location",
					"value.toll":                                              "if there is a toll for the way corresponding to this location",
					"value.ecu_speed_meters_per_second":                       "the speed of the asset as reported by the asset's ECU (Electronic Control Unit), for devices with a connection to the asset's OBD port",
					"value.has_ecu_speed":                                     "true if the ECU speed is available. ECU speed can be more accurate at low speeds and during rapid speed changes, but is subject to per-vehicle availability and quality",
					"value.revgeo_postcode":                                   "the postcode corresponding to the latitude / longitude of this device as determined by reverse geolocation",
					"value.has_way_id":                                        "whether or not the WayId field is valid",
					"value.way_id":                                            "the way closest to this location's latitude / longitude (see https://wiki.openstreetmap.org/wiki/Way)",
					"value.speed_limit_source":                                "the source of the speed limit data, if any exists",
					"value.speed_limit_updated_at_ms":                         "when the speed limit was updated in the location datapoint in milliseconds",
					"value.revgeo_house_number":                               "the house number corresponding to the latitude / longitude of this device as determined by reverse geolocation",
					"value.revgeo_poi":                                        "the point of interest corresponding to the latitude / longitude of this device as determined by reverse geolocation",
					"value.revgeo_neighborhood":                               "the neighborhood corresponding to the latitude / longitude of this device as determined by reverse geolocation",
					"value.received_at_ms":                                    "when this location datapoint was received by the backend, in milliseconds",
					"value.accuracy_millimeters":                              "the horizontalaccuracy of this location datapoint in millimeters, estimated by the GNSS receiver",
					"value.accuracy_invalid":                                  "true if the accuracy_millimeters field does not contain valid data",
					"value.gps_fix_timestamp_utc_ms":                          "the timestamp of the gps fix in milliseconds",
					"value.location_source":                                   "the source of the location data from the device (e.g. fix, cache, wifi, cellular, etc.)",
					"value.pre_release_speed_limit_meters_per_second":         "a modified speed limit derived from speed_limit_meters_per_second; not set on the KinesisStats write path",
					"value.pre_release_speed_limit_source":                    "the source of the pre release speed limit data",
					"value.exact_addresses_source":                            "the source of the reverse geocoding data (e.g., Nominatim)",
					"value.speed_limit_is_smoothed":                           "whether or not the speed limit data for this location datapoint is smoothed",
					"value.proxy_location_source_devices":                     "A list of devices that proxied the location. The list is populated iff location_source = LOCATION_SOURCE_PROXY",
					"value.proxy_location_source_devices.org_id":              "The unique organization identifier that the source device belongs to",
					"value.proxy_location_source_devices.device_id":           "The unique object identifier of the source device",
					"value.proxy_location_source_devices.object_type":         "The type of the source device_id. {object_type, device_id} as a pair uniquely identify the entity that proxied the location. 0 = DEVICE (Gateway), 1 = APP (clouddb.mobile_app)",
					"value.proxy_location_source_devices.in_customer_network": "Whether or not the source device is in organization as the device this location is associated with",
					"value.is_spoofed":                                        "Whether or not the location is spoofed, typically a bogus location used for testing",
					"value.is_fixed":                                          "Whether or not the location is fixed, typically an accurate location used on a stationary installation",
					"value.intermediate_locations":                            "An optional list of intermediate locations between the previous location datapoint and the current one, providing higher resolution data. Ordered oldest to newest.",
					"value.intermediate_locations.timestamp_utc_ms":           "Timestamp in unix milliseconds. Always smaller than the main location's timestamp",
					"value.intermediate_locations.latitude_1en7_degrees":      "Latitude in 10^-7 degree increments(tenths of microdegrees, i.e. 0.0000001 degrees)",
					"value.intermediate_locations.longitude_1en7_degrees":     "Longitude in 10^-7 degree increments (tenths of microdegrees, i.e. 0.0000001 degrees)",
					"value.intermediate_locations.gnss_speed_kmph_tenths":     "GNSS ('GPS') speed in tenths of kilometers per hour (0.1 km/h increments)",
					"value.intermediate_locations.gnss_speed_invalid":         "True if the gnss_speed_kmph_tenths is invalid",
					"value.intermediate_locations.ecu_speed_kmph_tenths":      "ECU speed in tenths of kilometers per hour (0.1 km/h increments)",
					"value.intermediate_locations.ecu_speed_invalid":          "True if the ecu_speed_kmph_tenths is invalid",
					"value.altitude_uncertainty_meters":                       "The estimated uncertainty in altitude measurement, in meters, provided by the GNSS receiver",
					"value.altitude_uncertainty_valid":                        "True if the altitude_uncertainty_meters field contains valid data",
					"value.gnss_speed_uncertainty_meters_per_second":          "The estimated uncertainty in GNSS speed measurement, in meters per second, provided by the GNSS receiver",
					"value.gnss_speed_uncertainty_valid":                      "True if the gnss_speed_uncertainty_meters_per_second field contains valid data",
					"value.heading_uncertainty_degrees":                       "The estimated uncertainty in heading measurement, in degrees, provided by the GNSS receiver",
					"value.heading_uncertainty_valid":                         "True if the heading_uncertainty_degrees field contains valid data",
					"value.geofences":                                         "An optional list of (precomputed) geofences that the location is associated with",
					"value.geofences_computed":                                "Whether or not the geofences field has been precomputed",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				UseTieredSchedule:   true,
				HourlyCronSchedule:  true,
				PrimaryKeysOverride: pointer.StringPtr("org_id,device_id,time"),
				DisableDeletionTask: true,
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MinWorkersOverride: pointer.IntPtr(8),
						MaxWorkersOverride: pointer.IntPtr(32),
						QueueEnabledSchedules: []dataplatformconsts.KsJobType{
							dataplatformconsts.KsJobTypeEvery3Hr,
						},
						DailyPartitionChunkSize: pointer.IntPtr(150),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osABleProxiedAdvertisement,
			BinaryMessageField: "BleProxiedAdvertisement",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Data corresponding to a BLE Proxied Advertisement (observed by a Samsara mobile app), AKA Crux",
				Frequency:   FrequencyCustom("Logged when compatible peripheral(s) are observed by a Samsara mobile app, default 1 min upload interval, but it is configurable."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_proxied_advertisement.peripherals.uuid":                                                 metadatahelpers.EnumDescription("BLE Service UUID", bleproxyproto.ServiceUuid_name),
					"value.proto_value.ble_proxied_advertisement.peripherals.mac_observed":                                         "MAC address observed, may or may not be encrypted",
					"value.proto_value.ble_proxied_advertisement.peripherals.num_times_observed_during_batch_period":               "Number of times the peripheral was observed during the log period (will be non-zero only if different from number of repeated peripherals)",
					"value.proto_value.ble_proxied_advertisement.peripherals.last_adv_packet_data":                                 "Verbatim advertisement data observed in last advertisement in batch period",
					"value.proto_value.ble_proxied_advertisement.peripherals.tx_power_is_invalid":                                  "Set to true if the central couldn't understand the structure of advertisement to decode TX power",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series.incremental_observed_at_offset_ds": "Array with incremental deciseconds deltas after the log's happenedAtMs that this advertisement was observed",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series.incremental_rssi_dbm":              "Array of deltas of received signal strength of the peripheral as seen by the central, in dBm",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series.incremental_tx_power_dbm":          "Array of deltas of transmit power of peripheral, in dBm (note that 0 is a valid value)",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series":                                   "Observation data that occurs during the batch period corresponding to this peripheral",
					"value.proto_value.ble_proxied_advertisement.peripherals.third_party_integration_id":                           "Device type ID used for third party BLE integrations, telling the backend what the data type is for use when parsing",
					"value.proto_value.ble_proxied_advertisement.peripherals":                                                      "Peripheral data observed during the batch period",
					"value.proto_value.ble_proxied_advertisement.batch_duration_sec":                                               "Amount of time (in seconds) the central scanned before uploading this stat",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osACruxPeripheralObservationBatch,
			BinaryMessageField: "PeripheralObservationBatch",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "A batch of peripheral device detections by a central mobile app via the Crux protocol. This is only a subset of available data required for peripheral observation processing. This stat is attached to the central mobile app making the observation, not the peripheral devices being observed.",
				Frequency:   FrequencyCustom("Logged for a single scanning window by a Crux central gateway, max 1 minute per central gateway."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.peripheral_observation_batch.peripheral_observations":                                                      "A list of peripherals observed by the central mobile app",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.org_id":                                               "The org ID of the observed peripheral",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.hardware_id":                                          "The hardware ID of the observed peripheral",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.product_id":                                           "The product ID of the observed peripheral",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.observation_series":                                   "A batch of observation data for the observed peripheral",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.observation_series.incremental_observed_at_offset_ds": "Array with incremental deciseconds deltas after the log's happenedAtMs that the peripheral was observed",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.observation_series.incremental_rssi_dbm":              "Array of deltas of received signal strength of the peripheral as seen by the central mobile app, in dBm",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.observation_series.incremental_tx_power_dbm":          "Array of deltas of transmit power of peripheral, in dBm (note that 0 is a valid value)",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.protocol_version":                                     "The network protocol version used to encode the data in the peripheral's advertisement packet",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osAlgorithmValidationOutput,
			BinaryMessageField: "AlgorithmValidationOutput",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "General-purpose validation data for comparing different algorithm versions or implementations. Services emit this data to track and validate algorithm outputs over time.",
				Frequency:   FrequencyCustom("Logged when algorithm validation data is emitted by a service"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.algorithm_validation_output.algorithm_id": "Identifier of the algorithm (e.g., 'stce.crux_association_breaker')",
					"value.proto_value.algorithm_validation_output.version":      "Version of the algorithm that produced this output",
					"value.proto_value.algorithm_validation_output.unix_ms":      "Timestamp when this output was generated (milliseconds since epoch)",
					"value.proto_value.algorithm_validation_output.json_data":    "JSON-encoded data payload for flexible validation data",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osComputedHealthStatus,
			BinaryMessageField: "ComputedHealthStatus",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Health status computed for an object at a point in time.",
				Frequency:   FrequencyEveryXSeconds(15 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.computed_health_status.ordered_rule_outputs":               "Prioritized list of health rule outputs, from highest to lowest priority",
					"value.proto_value.computed_health_status.ordered_rule_outputs.rule_code":     "The identifier of the rule which output this",
					"value.proto_value.computed_health_status.ordered_rule_outputs.status_code":   "The status code for this health output.",
					"value.proto_value.computed_health_status.ordered_rule_outputs.category":      "The category for this health output",
					"value.proto_value.computed_health_status.ordered_rule_outputs.changed_at_ms": "The time this rule began outputting this status for this object",
					"value.proto_value.computed_health_status.ordered_rule_outputs.details":       "Details about the status computed",
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osCVgMcuFatal,
			BinaryMessageField:       "VgMcuFatal",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osCVgMcuMetrics,
			BinaryMessageField:       "VgMcuMetrics",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAccelDataSamples,
			BinaryMessageField: "AccelDataSamples",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag},
			MetadataInfo: &MetadataInfo{
				Description: "Generic object stat for reporting accelerometer data.  Currently used on the Marathon platform.",
				Frequency:   FrequencyCustom("Reported on boot and at other assorted sample times.  Often just a single sample for orientation."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.accel_data_samples.samples.x_ug":    "Accelerometer sample reading X in micro g",
					"value.proto_value.accel_data_samples.samples.y_ug":    "Accelerometer sample reading Y in micro g",
					"value.proto_value.accel_data_samples.samples.z_ug":    "Accelerometer sample reading Z in micro g",
					"value.proto_value.accel_data_samples.sample_rate_mhz": "Sample rate in milli-hertz when multiple samples are given. Will be meaningless when a single sample is given."},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAccelEngineTorqueOverLimitMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total time engine torque over limit (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the engine torque was over the configured threshold. The threshold is configured via hubproto config integer field DeviceConfig.ObdConfig.EcodriverConfig.AccelMinEngineTorque, representing the torque threshold causing this stat to be accumulated.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("time engine torque over limit", hubproto.ObdValue_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAccelEngineTorqueOverLimitWhileNotOnCruiseControlMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total time engine torque over limit while cruise control disabled (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the engine torque was over the configured threshold. The threshold is configured via hubproto config integer field DeviceConfig.ObdConfig.EcodriverConfig.AccelMinEngineTorque, representing the torque threshold causing this stat to be accumulated.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("time engine torque over limit", hubproto.ObdValue_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAcceleratorPedalTimeGreaterThan95PercentMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total time accelerator pedal pressed over threshold",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the accelerator pedal was above 95% depressed.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAcceleratorPedalTimeGreaterThanPositionAMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total time accelerator pedal pressed over threshold",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the accelerator pedal was above position A as defined in the ecodriving config (default 25%).",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAcceleratorPedalTimeGreaterThanPositionBMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total time accelerator pedal pressed over threshold",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the accelerator pedal was above position B as defined in the ecodriving config (default 50%).",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAcceleratorPedalTimeGreaterThanPositionCMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total time accelerator pedal pressed over threshold",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the accelerator pedal was above position C as defined in the ecodriving config (default 75%).",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAcceleratorPedalTimeGreaterThanPositionDMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total time accelerator pedal pressed over threshold",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the accelerator pedal was above position D as defined in the ecodriving config (default 95%).",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAccelerometer,
			BinaryMessageField: "AccelerometerEvent",
			// Commenting out the field to disable replication for s3bigstats.osDAccelerometer
			// This is due to the increase in the ingestion throughput which the job was not able to keep up with.
			// This is a temporary fix to disable replication for the s3bigstats.osDAccelerometer table but also
			// might be something we don't re-enable if there is no user demand for it.
			// TODO: Re-enable the replication for the s3bigstats.osDAccelerometer table if we find user demand and
			//       we have a solution to the scalability issue.
			// S3BinaryMessageField: "AccelEventData",
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			Production:               true,
			DataModelStat:            true,
			ksFieldsToExclude: []string{
				"value.proto_value.accelerometer_event.harsh_accel_metadata.distracted_calibration_id",
			},
			MetadataInfo: &MetadataInfo{
				Description: "Sent up by a VG or CM when it detects an event or or driver behavior that we want to surface to the user as important. Sent up both for accelerometer-detected events (e.g. crash) and AI-detected events (e.g. seatbelt). \n \n NOTE: The osDAccelerometer S3BigStat (i.e s3bigstats.osdaccelerometer) has NOT been backfilled and only has data from March 2021. If you would like a backfill please reach out to #ask-data-platform to discuss your use case.",
				Frequency:   FrequencyOnChange("Any time the VG or CM detects an event or driver behavior that we want to surface to the user as important."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.accelerometer_event.max_accel_gs":                                         "(accelerometer-based events only) The maximum value of the acceleration vector (g-force) that was measured in the detected-event window.",
					"value.proto_value.accelerometer_event.crash_thresh_gs":                                      "(accelerometer-based events only) (HEv1 only) The G-force threshold used to trigger the event on the VG for crashes.",
					"value.proto_value.accelerometer_event.brake_thresh_gs":                                      "(accelerometer-based events only) (HEv1 only) The G-force threshold used to trigger the event on the VG for non-crash events.",
					"value.proto_value.accelerometer_event.event_duration_ms":                                    "The size in milliseconds of the window for the detected event.",
					"value.proto_value.accelerometer_event.last_gps":                                             "The last GPS datapoint from the VG in the window of the event.",
					"value.proto_value.accelerometer_event.event_id":                                             "The unique identifier for the event (UUID) for the generated event. Should match the event_id on the associated dashcam asset if one exists.",
					"value.proto_value.accelerometer_event.harsh_accel_type":                                     metadatahelpers.EnumDescription("The type of event that was triggered by the device.", hubproto.HarshAccelTypeEnum_name),
					"value.proto_value.accelerometer_event.initial_rke":                                          "(accelerometer-based events only) (HEv1 only) The rotational kinetic energy calculated from the gyroscope at the start of the detected event. For non-crash accelerometer events, used to classify the event as a harsh turn if the RKE is > the configured threshold.",
					"value.proto_value.accelerometer_event.harsh_accel_metadata":                                 "Extra metadata for distracted driving event detection. Includes the severity and the detected duration of the distracted driving.",
					"value.proto_value.accelerometer_event.speed_limit_metadata":                                 "Extra metadata for speeding events. Includes the wayId, the stored speed limit in Kmph, and additional info around the tile.",
					"value.proto_value.accelerometer_event.distracted_policy_detector_metadata":                  "Extra metadata for policy violation detection (mobile usage, food/drink, smoking). Includes the startMs and the duration of the detection.",
					"value.proto_value.accelerometer_event.tile_rolling_stop_sign_metadata":                      "Extra metadata for tile based rolling stop sign detection.",
					"value.proto_value.accelerometer_event.tile_rolling_railroad_crossing_metadata":              "Extra metadata for tile based railroad crossing detection",
					"value.proto_value.accelerometer_event.tailgating_metadata":                                  "Extra metadata for tailgating detections. Includes the startMs and the duration of the tailgating.",
					"value.proto_value.accelerometer_event.dashcam_seatbelt_data":                                "Extra metadata for no seatbelt detections. Includes the confidence of the detection as well as the number of warnings issued to the driver.",
					"value.proto_value.accelerometer_event.dashcam_mask_data":                                    "Extra metadata for no mask detections. Includes the confidence of the detection as well as the number of warnings issued to the driver.",
					"value.proto_value.accelerometer_event.dashcam_driver_obstruction_data":                      "Extra metadata for camera obstruction detections. Includes the confidence of the detection as well as the number of warnings issued to the driver.",
					"value.proto_value.accelerometer_event.event_source":                                         metadatahelpers.EnumDescription("The source of the event trigger.", hubproto.ObjectStatBinaryMessage_AccelerometerEvent_EventSource_name),
					"value.proto_value.accelerometer_event.gateway_id":                                           "For VG-triggered events, the gatewayID of the triggering VG. For CM-triggered events, the gatewayID of the VG connected to the triggering CM.",
					"value.proto_value.accelerometer_event.ingestion_tag":                                        "(accelerometer-based events only) Version tag corresponding to the algorithm that triggered the event (0: HEv1, 1: HEv2).",
					"value.proto_value.accelerometer_event.customer_visible_ingestion_tag":                       "(accelerometer-based events only) The version of harsh events that the customer should see in the safety inbox and dashboard.",
					"value.proto_value.accelerometer_event.hidden_to_customer":                                   "(accelerometer-based events only) If true, this event is not surfaced to the customer but still persisted to safetydb.safety_events",
					"value.proto_value.accelerometer_event.imu_harsh_event":                                      "Fields specific to IMU-based (accelerometer + gyroscope) harsh events: harsh brake/accel/turn and crashes. Not available for HEv1.",
					"value.proto_value.accelerometer_event.imu_harsh_event.algorithm_version":                    "Version number for the HEv2 algorithm (accelerometer-based harsh events). Manually incremented when making significant firmware changes.",
					"value.proto_value.accelerometer_event.imu_harsh_event.config":                               "Copy of the hubproto.ImuHarshEventConfig the algorithm was running when the event was detected.",
					"value.proto_value.accelerometer_event.imu_harsh_event.orientation":                          "IMU orientation in use when the event was detected, if the IMU is calibrated.",
					"value.proto_value.accelerometer_event.imu_harsh_event.triggered_audio_alert":                "True if an audio coaching alert was triggered by this event.",
					"value.proto_value.accelerometer_event.imu_harsh_event.triggered_customer_threshold":         "True if the customer-configured harsh event g-threshold was crossed. If false, the event is still reported (configurable) but won't be persisted in safetydb.safety_events, and will be hidden from the customer. Used for canonical data collection.",
					"value.proto_value.accelerometer_event.imu_harsh_event.num_samples_above_customer_threshold": "Number of acceleration samples where the magnitude of the vector was above the customer threshold, if any.",
					"value.proto_value.accelerometer_event.imu_harsh_event.gravity_only_event":                   "True if the event was detected without the IMU being fully oriented (gravity + yaw). Only available with algorith_version 3 and above.",
					"value.proto_value.accelerometer_event.imu_harsh_event.gravity_vector":                       "If gravity_only_event is true, the gravity vector (X,Y,Z) that was in use when the event was detected.",
					"value.proto_value.accelerometer_event.imu_harsh_event.secondary_events":                     "Array of accelerometer-based harsh events that were detected at the same time (approx.) but are of lesser importance, based on event type and event g-force.",
					// S3BigStats fields (commented out to disable replication for s3bigstats.osDAccelerometer, See above where S3BinaryMessageField is commented out for more details):
					// "s3_proto_value.accel_event_data.recent_accel":                                               "List of data detected by the accelerometer around the window of the event detection. Each datapoint corresponds to the reported G value along the X,Y,Z axes on the accelerometer as well as the time of the value (relative to the event_ms). Only relevant for accelerometer based VG events",
					// "s3_proto_value.accel_event_data.recent_accel.x_f":                                           "The G value detected along the X axis of the accelerometer",
					// "s3_proto_value.accel_event_data.recent_accel.y_f":                                           "The G value detected along the Y axis of the accelerometer",
					// "s3_proto_value.accel_event_data.recent_accel.z_f":                                           "The G value detected along the Z axis of the accelerometer",
					// "s3_proto_value.accel_event_data.recent_accel.offset_from_event_ms":                          "The time the reported Gs were recorded on the accelerometer relative to the event_ms (time the event was triggered)",
					// "s3_proto_value.accel_event_data.recent_gyro":                                                "List of data detected by the gyroscope around the window of the event detection. Each datapoint corresponds to the reported angular rate (in degrees per second) along the X,Y,Z axes on the gyroscope as well as the time of the value (relative to the event_ms). Only relevant for accelerometer based VG events",
					// "s3_proto_value.accel_event_data.recent_gyro.x_dps":                                          "The degrees per second change detected along the X axis of the gyroscope. Only relevant for accelerometer based VG events",
					// "s3_proto_value.accel_event_data.recent_gyro.y_dps":                                          "The degrees per second change detected along the Y axis of the gyroscope. Only relevant for accelerometer based VG events",
					// "s3_proto_value.accel_event_data.recent_gyro.z_dps":                                          "The degrees per second change detected along the Z axis of the gyroscope. Only relevant for accelerometer based VG events",
					// "s3_proto_value.accel_event_data.recent_gyro.offset_from_event_ms":                           "The time the reported angular rotation was recorded on the gyroscope relative to the event_ms (time the event was triggered)",
					// "s3_proto_value.accel_event_data.recent_gps":                                                 "A list of the gps datapoints reported around the window of the detected event",
					// "s3_proto_value.accel_event_data.recent_gps.ts":                                              "The millisecond unixtime that this gps datapoint was reported. This timestamp is derived from the satellite time and it is not synced with any Samsara-controlled clock",
					// "s3_proto_value.accel_event_data.recent_gps.latitude":                                        "The gps latitude reported by the device at the time of the associated ts field",
					// "s3_proto_value.accel_event_data.recent_gps.longitude":                                       "The gps longitude reported by the device at the time of the associated ts field",
					// "s3_proto_value.accel_event_data.recent_gps.speed":                                           "The speed of the vehicle from gps reported in milliknots at the time of the associated ts field",
					// "s3_proto_value.accel_event_data.recent_gps.heading":                                         "The heading of the vehicle from gps reported in millidegrees at the time of the associated ts field",
					// "s3_proto_value.accel_event_data.recent_gps.event_offset_ms":                                 "The difference in milliseconds between the time this gps datapoint was reported and the time the event was triggered on the device (event_ms). Calculated as gps.ts - event_ms. A negative offset indicates the gps datapoint occurred before the event trigger. While the absolute timestamp for this datapoint is already included in the ts field, this is included for consistency with the other accel_event_data fields",
					// "s3_proto_value.accel_event_data.recent_gps.ecu_speed":                                       "The speed of the vehicle from ecu reported in milliknots at the time of the associated ts field. Only accurate if the ecu_speed_valid field is true",
					// "s3_proto_value.accel_event_data.recent_gps.ecu_speed_valid":                                 "Indicates that the ecu_speed has a speed value reported from the vehicle ecu",
					// "s3_proto_value.accel_event_data.ecu_speed":                                                  "If present, a list of the reported ECU speed on the vehicle around the window of the detected event",
					// "s3_proto_value.accel_event_data.ecu_speed.speed_milliknots":                                 "If present, the ECU speed reported by the vehicle in milliknots",
					// "s3_proto_value.accel_event_data.ecu_speed.offset_from_event_ms":                             "If present, the time of the reported ECU speed relative to the event_ms (time the event was triggered)",
					// "s3_proto_value.accel_event_data.accel_pedal":                                                "If present, a list of the reported acceleration pedal positions reported around the window of the detected event",
					// "s3_proto_value.accel_event_data.accel_pedal.position":                                       "If present, the position of the acceleration pedal reported by the vehicle. A value between 0-1000 where 0 is completely disengaged and 1000 is completely engaged",
					// "s3_proto_value.accel_event_data.accel_pedal.offset_from_event_ms":                           "If present, the time of the reported acceleration pedal position relative to the event_ms (time the event was triggered)",
					// "s3_proto_value.accel_event_data.brake":                                                      "If present, a list of the reported brake pedal positions reported around the window of the detected event",
					// "s3_proto_value.accel_event_data.brake.brake_on":                                             "If present, the position of the brake pedal reported by the vehicle. True is the brake is engaged, false if not",
					// "s3_proto_value.accel_event_data.brake.offset_from_event_ms":                                 "If present, the time of the reported brake pedal position relative to the event_ms (time the event was triggered),",
					// "s3_proto_value.accel_event_data.cruise_control":                                             "If present, a list of the reported cruise control values around the window of the detected event",
					// "s3_proto_value.accel_event_data.cruise_control.cruise_control_activated":                    "If present, whether cruise control is activated on the vehicle",
					// "s3_proto_value.accel_event_data.cruise_control.offset_from_event_ms":                        "If present, the time of the reported cruise control value relative to the event_ms (time the event was triggered)",
					// "s3_proto_value.accel_event_data.oriented_harsh_detector_triggered":                          "If true, represents that the harsh events v2 oriented harsh event detector detected the event as well. Only relevant for accelerometer based events",
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDAccelerometerShadow,
			BinaryMessageField:       "AccelerometerEvent",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			ksFieldsToExclude: []string{
				"value.proto_value.accelerometer_event.harsh_accel_metadata.distracted_calibration_id",
			},
			MetadataInfo: &MetadataInfo{
				Description: "Replicates the osdAccelerometer stat type to report detections made by experimental firmware models. These events are meant for data collection and are hidden from customers. See osdAccelerometer for column descriptions.",
				Frequency:   FrequencyOnChange("Uploads when harsh events are detected by experimental models."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.accelerometer_event.event_id": "The unique identifier for the event (UUID) for the generated event.",
				},
			},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDAccelMagSamplesBatch,
			S3BinaryMessageField: "AccelMagSamplesBatch",
			Kind:                 StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Sent up by a VG or CM when it detects an event or or driver behavior that we want to surface to the user as important. Sent up both for accelerometer-detected events (e.g. crash) and AI-detected events (e.g. seatbelt). \n \n NOTE: The osDAccelerometer S3BigStat (i.e s3bigstats.osdaccelerometer) has NOT been backfilled and only has data from March 2021. If you would like a backfill please reach out to #ask-data-platform to discuss your use case.",
				Frequency:   FrequencyCustom("Every 60 seconds when enabled via config accel_mgr_config.enable_batch_log_accel_mag_samples"),
				ColumnDescriptions: map[string]string{
					"s3_proto_value.accel_mag_samples_batch.offset_ms":          "log event time ms - offset_ms is the time when the sample was taken",
					"s3_proto_value.accel_mag_samples_batch.mag_milligravities": "magnitude of acceleration in milligravities",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAcpAccessoriesLastConnect,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "AcpAccessoriesLastConnect",
			MetadataInfo: &MetadataInfo{
				Description: "List of accessories with successful pings over ACP that were last connected to the device.",
				Frequency:   FrequencyOnChange("When any new accessory returns a successful ping over ACP"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.acp_accessories_last_connect.acp_accessories.serial":              "The serial of the ACP accessory, exacly as obtained from the ACP response",
					"value.proto_value.acp_accessories_last_connect.acp_accessories.firmware_version":    "The firmware version of the ACP accessory, exactly as obtained from the ACP response",
					"value.proto_value.acp_accessories_last_connect.acp_accessories.sku":                 metadatahelpers.EnumDescription("The hardware SKU of the ACP accessory", hubproto.AcpAccessory_SKU_name),
					"value.proto_value.acp_accessories_last_connect.acp_accessories.hardware_version":    "The hardware version of the ACP accessory, exacly as obtained from the ACP response",
					"value.proto_value.acp_accessories_last_connect.acp_accessories.hardware_build_date": "The hardware build date of the ACP accessory, exacly as obtained from the ACP response",
					"value.proto_value.acp_accessories_last_connect.acp_accessories.product_type":        metadatahelpers.EnumDescription("The product type of the ACP accessory", hubproto.AcpAccessory_ProductType_name),
					"value.proto_value.acp_accessories_last_connect.acp_accessories.manufacturer":        "The manufacturer of the ACP accessory, exacly as obtained from the ACP response",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAdaptiveCruiseControlMode,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Adaptive Cruise Control (ACC) Mode",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "Current mode of the Adaptive Cruise Control system, if fitted on the vehicle.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAddressEntry,
			BinaryMessageField: "AddressEvent",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAddressesClaimedName,
			BinaryMessageField: "BusAndAddressesClaimedNames",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "J1939 Address Claim Name messages",
				Frequency:   FrequencyEveryXSeconds(300),
				ColumnDescriptions: map[string]string{
					"value.proto_value.bus_and_addresses_claimed_names.vehicle_diagnostic_bus":                                "The bus on which the addresses claimed were received",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.raw_payload":               "The raw payload of the NAME message",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.ecu_id":                    "The ECU ID",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.identity_number":           "The identity number assigned by the ECU manufacturer (SPN 2837)",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.manufacturer_code":         "The manufacturer code representing the company that manufactured the ECU (SPN 2838)",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.ecu_instance":              "The ECU instance indicating which one of a group of electronic control modules associated with a given Function is being referenced (SPN 2840)",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.function_instance":         "The function instance indicating the particular occurrence of a Function on the same Vehicle System on a given network (SPN 2839)",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.function":                  "The function indicating the function performed by the Controller Application (SPN 2841)",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.vehicle_system":            "The vehicle system indicating the system group associated with the Controller Application (SPN 2842)",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.vehicle_system_instance":   "The vehicle system instance indentifying a particular occurrence of a particular Vehicle System within a connected network (SPN 2843)",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.industry_group":            "The industry group identifying the industry group associated with the NAME function (SPN 2846)",
					"value.proto_value.bus_and_addresses_claimed_names.addresses_claimed_name_info.arbitrary_address_capable": "Whether the ECU is able to use an arbitrary source address to resolve an address claim conflict (SPN 2844)",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAddressExit,
			BinaryMessageField: "AddressEvent",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAg2XUptimeInfo,
			BinaryMessageField: "Ag2XUptimeInfo",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAggregateBrakeRegressionData,
			BinaryMessageField: "AggregateBrakeRegressionData",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Aggregate brake regression data",
				Frequency:   FrequencyCustom("Once every six hours."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.aggregate_brake_regression_data.start_time_ms":                                 "The start timestamp of the data stored in ms",
					"value.proto_value.aggregate_brake_regression_data.count":                                         "The number of brake events",
					"value.proto_value.aggregate_brake_regression_data.sum_pressure_bar":                              "The sum of the pressure values",
					"value.proto_value.aggregate_brake_regression_data.sum_braking_effort_percent":                    "The sum of the braking effort values",
					"value.proto_value.aggregate_brake_regression_data.sum_pressure_bar_squared":                      "The sum of the pressure values squared",
					"value.proto_value.aggregate_brake_regression_data.sum_braking_effort_percent_squared":            "The sum of the braking effort values squared",
					"value.proto_value.aggregate_brake_regression_data.sum_pressure_bar_times_braking_effort_percent": "The sum of the pressure values times the braking effort values",
					"value.proto_value.aggregate_brake_regression_data.count_below_braking_threshold":                 "The number of brake events below the brake performance threshold",
					"value.proto_value.aggregate_brake_regression_data.check_ebs_metadata":                            "Metadata used to track the state of the Check EBS label surfaced to customers. Populated only when the label is applicable for the score window.",
					"value.proto_value.aggregate_brake_regression_data.check_ebs_metadata.active":                     "Whether the Check EBS label should be shown for this score's window.",
					"value.proto_value.aggregate_brake_regression_data.check_ebs_metadata.last_triggered_at_ms":       "Last time we saw a qualifying event exceeding the configured pressure threshold within the score window.",
					"value.proto_value.aggregate_brake_regression_data.check_ebs_metadata.trigger_count":              "Number of qualifying events exceeding the configured pressure threshold within the score window.",
					"value.proto_value.aggregate_brake_regression_data.check_ebs_metadata.threshold_pressure_bar":     "Pressure bar threshold for indicating a potential issue with the EBS system.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAggregateDurationFrictionBrakingMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total time spent friction braking (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the vehicle was friction braking. Friction braking is defined as the vehicle speed is greater than 0 and the brake pedal is pressed.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("friction braking time", hubproto.ObdValue_name),
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
				HourlyCronSchedule: true,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAggregateDurationRetarderBrakingMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total time spent retarder braking (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the vehicle was retarder braking. Retarder braking is defined as the vehicle speed is greater than 0 and the retarder is engaged.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("retarder braking time", hubproto.ObdValue_name),
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
				HourlyCronSchedule: true,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAgMcuFlashInfo,
			BinaryMessageField: "AgMcuFlashInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Contains metadata about the MCU flash of an AG2x product.",
				Frequency:   FrequencyCustom("reported every time an attempt at flashing the MCU is made"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ag_mcu_flash_info.failed":            "Boolean indicating if the MCU flash attempt was successful.",
					"value.proto_value.ag_mcu_flash_info.fail_reason":       "The reason that was returned in the case of a failed flash attempt.",
					"value.proto_value.ag_mcu_flash_info.number_of_retries": "The numbers of retries after a failed attempt.",
				},
			},
			Tags: []amundsentags.Tag{amundsentags.AssetsTag},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDAirInletPressurePa,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Absolute air pressure at input port to intake manifold or air box (Pa)",
				Frequency:           FrequencyOnChange("1500Pa change"),
				IntValueDescription: "Absolute air pressure at input port to intake manifold or air box (Pa). J1939-DA PGN 65270 Intake/Exhaust Conditions (IC1), SPN 106",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDAirInletTempMilliC,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Temperature of air entering vehicle air induction system. (mC)",
				Frequency:           FrequencyOnChange("100mC change"),
				IntValueDescription: "Temperature of air entering vehicle air induction system (mC). J1939-DA PGN 65269 Ambient Conditions (AMB), SPN 172",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAiTwoWayAgentCallTriggered,
			BinaryMessageField: "AiTwoWayAgentCallTriggered",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "Information about an AI two way agent call that was triggered",
				Frequency:   FrequencyCustom("Whenever an AI two way agent call is triggered"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ai_two_way_agent_call_triggered.agent_run_id":                                       "HappyRobot run ID associated with this webcall",
					"value.proto_value.ai_two_way_agent_call_triggered.backend_run_id":                                     "The run ID generated by the backend application that triggered the call",
					"value.proto_value.ai_two_way_agent_call_triggered.happy_robot_workflow_parameters.api_host":           "The API host of the HappyRobot workflow",
					"value.proto_value.ai_two_way_agent_call_triggered.happy_robot_workflow_parameters.happy_robot_org_id": "The org ID of the HappyRobot account where the workflow is defined",
					"value.proto_value.ai_two_way_agent_call_triggered.happy_robot_workflow_parameters.use_case_id":        "The use case ID of the HappyRobot workflow",
					"value.proto_value.ai_two_way_agent_call_triggered.trigger_call_reason":                                metadatahelpers.EnumDescription("The reason for triggering the call", aitwowayagentproto.AiTwoWayAgentCallTriggered_TriggerCallReason_name),
					"value.proto_value.ai_two_way_agent_call_triggered.trigger_call_status":                                metadatahelpers.EnumDescription("The status of the call", aitwowayagentproto.TriggerCallStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAlertDetectionSeverityState,
			BinaryMessageField: "AlertDetectionSeverityState",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Alert detection severity that triggered an audio alert.",
				Frequency:   FrequencyOnChange("whenever an alert detection state changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.alert_detection_severity_state.event_type": metadatahelpers.EnumDescription(
						"Type of event associated with the detection.", hubproto.Cm3XAudioAlertInfo_EventType_name,
					),
					"value.proto_value.alert_detection_severity_state.severity": metadatahelpers.EnumDescription(
						"Detection severity level.", hubproto.AlertDetectionSeverity_name,
					),
					"value.proto_value.alert_detection_severity_state.detection_id": "Identifier of the detection that triggered the alert.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAlertPolicySeverityState,
			BinaryMessageField: "AlertPolicySeverityState",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Alert policy severity selected for a detection.",
				Frequency:   FrequencyOnChange("whenever an alert policy state changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.alert_policy_severity_state.event_type": metadatahelpers.EnumDescription(
						"Type of event associated with the policy decision.", hubproto.Cm3XAudioAlertInfo_EventType_name,
					),
					"value.proto_value.alert_policy_severity_state.severity": metadatahelpers.EnumDescription(
						"Alert severity chosen by policy.", hubproto.AudioAlertPolicyConfig_AlertSeverityLevel_name,
					),
					"value.proto_value.alert_policy_severity_state.detection_id": "Identifier of the detection that triggered the alert.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAmbientTemperatureMilliC,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Temperature of air surrounding vehicle (mC)",
				Frequency:           FrequencyCustom("2 hours or 2C change"),
				IntValueDescription: "Temperature of air surrounding vehicle (mC). J1939-DA PGN 65269 Ambient Conditions (AMB), SPN 171",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAnalogInputCurrent1MicroA,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Current measured on analog input 1 (uA)",
				Frequency:           FrequencyCustom("depends on the device type and configuration"),
				IntValueDescription: "Current measured on analog input 1 (uA)",
			},
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAnalogInputCurrent2MicroA,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Current measured on analog input 2 (uA)",
				Frequency:           FrequencyCustom("depends on the device type and configuration"),
				IntValueDescription: "Current measured on analog input 2 (uA)",
			},
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAnalogInputVoltage1MilliV,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Voltage measured on analog input 1 (mV)",
				Frequency:           FrequencyCustom("depends on the device type and configuration"),
				IntValueDescription: "Voltage measured on analog input 1 (mV)",
			},
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAnalogInputVoltage2MilliV,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Voltage measured on analog input 2 (mV)",
				Frequency:           FrequencyCustom("depends on the device type and configuration"),
				IntValueDescription: "Voltage measured on analog input 2 (mV)",
			},
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDAnomalyEvent,
			BinaryMessageField:       "AnomalyEvent",
			Kind:                     StatKindObjectStat,
			DataModelStat:            true,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			Tags:                     []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Anomaly reported from firmware",
				Frequency:   FrequencyCustom("important messages needing to be logged"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.anomaly_event.boot_count":   "Current boot number of the device. Boot count is incremented with each successful boot. This can be used to identify system logs on the device that may be useful.",
					"value.proto_value.anomaly_event.build":        "Current build running when the anomaly was reported",
					"value.proto_value.anomaly_event.description":  "String containing anomaly text",
					"value.proto_value.anomaly_event.device_id":    "MAC address assigned to the device reporting the anomaly",
					"value.proto_value.anomaly_event.service_name": "Firmware service where the anomly was reported",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAnticipationBrakeEvents,
			BinaryMessageField: "AnticipationBrakeData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle anticipation braking events detected",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Number of anticipation brake press transitions detected. The value increases every time a brake event is seen within the configured window of an acceleration pedal event. Values derived for both passenger and heavy duty vehicles.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.anticipation_brake_data.configured_anticipation_brake_parameters.anticipation_brake_event_delay_ms": "The configured window that was used for the detection of anticipation brake press transitions.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAPClients,
			BinaryMessageField: "ApClients",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Currently connect access point (AP) clients",
				Frequency:   FrequencyOnChange("set of clients connected changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ap_clients":               "List of clients currently connected.",
					"value.proto_value.ap_clients.ap_client.mac": "List of clients currently connected MAC addresses.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDApparentPowerVoltAmpere,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Generator Total Percent (kVA)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "This parameter reports the generator total AC apparent power, as a percentage of rated power. J1939-DA",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAssetMovingWithoutPower,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates when an asset is moving without power",
				Frequency:           FrequencyCustom("Anytime an asset is detected to be moving without power - will emit periodically while in the state"),
				IntValueDescription: "Voltage (in mV) at which the asset is moving without power",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAssetSignificantMovement,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates when an asset is moving",
				Frequency:           FrequencyCustom("When an asset is detected to be moving and periodically while moving"),
				IntValueDescription: "The int value is unused",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAssetStationary,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates when an asset is stopped",
				Frequency:           FrequencyCustom("When an asset is detected to be stopped and periodically while stopped"),
				IntValueDescription: "The int value is unused",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAssetStationaryOrPowered,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates when an asset is stopped or powered",
				Frequency:           FrequencyCustom("Anytime an asset is detected to be stationary or powered - will emit periodically while in the state"),
				IntValueDescription: "Voltage (in mV) at which the asset is either stationary or powered",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAt1DpfAshLoadPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Diesel particulate filter (DPF) ash (%)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Indicates the ash load percent of diesel particulate filter 1. 100% is the level at which diesel particulate filter ash service should be performed. 100% level is the target ash service interval (and if ash service is not immediately performed, ash loading can continue beyond 100%).",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDAt1DpfSootLoadPercent,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Diesel particulate filter (DPF) soot (%)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Indicates the soot load percent of diesel particulate filter 1.  100% is the level at which active diesel particulate filter regeneration should be triggered. 100% level is the active regeneration trigger level (and if conditions are not favorable for regeneration, soot loading can continue beyond 100%).  During normal operation and regeneration a value 0% will indicate a fully regenerated diesel particulate filter.  Values of 25%, 50% and 75% will indicate the general level of soot prior to the 100% level where an active regeneration is needed. AT1 corresponds to J1939 PGN 64891, SPN 3719.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAtisLampFault,
			BinaryMessageField: "AtisLampFault",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "An accumulation of Automatic Tire Inflation (ATIS) lamp states that have reached a set threshold for being continuously on to be considered a fault.",
				Frequency:   FrequencyCustom("Reported at the frequency at which the AtisLampStates accumulate to the threshold specified on the fault or if the ATIS input is changed on a device."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.atis_lamp_fault.atis_input":         metadatahelpers.EnumDescription("The digi input the ATIS is installed on.", atis.DigiSelection_name),
					"value.proto_value.atis_lamp_fault.is_active":          "Describes whether the ATIS lamp fault is active or inactive. That is, if it is active then the ATIS lamp has been on continuously for at least the amount of time specified in the threshold value.",
					"value.proto_value.atis_lamp_fault.threshold_value_ms": "Describes the threshold value used to determine if ATIS lamp is a fault. For example, if the threshold value is 10 minutes in milliseconds then the fault will be active only when the ATIS lamp has been on continuously for at least 10 minutes.",
					"value.proto_value.atis_lamp_fault.fault_start_ms":     "Describes when the ATIS lamp turned on first. If the is_active field is false then the fault_start_ms field should not be considered and should be the value 0",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAtisLampState,
			BinaryMessageField: "AtisLampState",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "An individual Automatic Tire Inflation System (ATIS) lamp state describing whether the ATIS lamp is on or off and what input the ATIS is installed on.",
				Frequency:   FrequencyCustom("Reported at the frequency at which the digio input reports or if the ATIS input is changed on a device."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.atis_lamp_state.atis_input": metadatahelpers.EnumDescription("The digi input the ATIS is installed on.", atis.DigiSelection_name),
					"value.proto_value.atis_lamp_state.is_lamp_on": "Describes whether the ATIS lamp is on or off.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAttachedUsbDevices,
			BinaryMessageField: "AttachedUsbDevices",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Attached USB devices seen",
				Frequency:   FrequencyOnChange("USB device connected status"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.attached_usb_devices.usb_id":        "32 bit representing a USB vendor and product ID. Format is (vendor_id<<16) + (product_id). Each USB identifier is read through linux sysfs.",
					"value.proto_value.attached_usb_devices.serial":        "Serial number given to a USB peripheral. This is not always populate on USB devices, but should be reported for both CM3x cameras and Falko USB hubs.",
					"value.proto_value.attached_usb_devices.port_topology": "String containing the usb port topology from sysfs. This is in the form <bus>-<port>[.<port>][.<port>]",
					"value.proto_value.attached_usb_devices.bcd_device":    "Device release as a 16-bit binary-coded decimal value.",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAudioAlertRecord,
			BinaryMessageField: "AudioAlertRecord",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Information about the result of an audio alert request.",
				Frequency:   FrequencyCustom("Reported after each audio alert request is processed."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.audio_alert_record.event_type": metadatahelpers.EnumDescription(
						"Type of event that triggered the audio alert request.", hubproto.Cm3XAudioAlertInfo_EventType_name,
					),
					"value.proto_value.audio_alert_record.cloud_trigger_reason": metadatahelpers.EnumDescription(
						"Trigger reason for cloud-triggered events.", hubproto.TriggerAudioAlertReq_TriggerReason_name,
					),
					"value.proto_value.audio_alert_record.audio_alert_config":             "Configuration used for audio alert playback.",
					"value.proto_value.audio_alert_record.trigger_gateway_id":             "Gateway ID of the device that initiated the alert.",
					"value.proto_value.audio_alert_record.result":                         "Playback result of the alert, whether it was played (full or interrupted), dropped, shadow-mode logged, suppressed.",
					"value.proto_value.audio_alert_record.queued":                         "Whether the alert was queued behind a higher-priority alert before playback.",
					"value.proto_value.audio_alert_record.sliding_window_rate_limit_rule": "The sliding window rate limit rule that suppressed the alert, if applicable.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDAuxiliaryVoltages,
			BinaryMessageField: "AuxiliaryVoltages",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Auxiliary voltage per input",
				Frequency:   FrequencyOnChange("Logged periodically or on major change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.auxiliary_voltages.aux_type": metadatahelpers.EnumDescription("Type of input", hubproto.ObjectStatBinaryMessage_AuxiliaryVoltage_AuxType_name),
					"value.proto_value.auxiliary_voltages.aux_mv":   "Input voltage measured in mV",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAverageACCurrentMilliAmps,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Average RMS current measured at the generator output (mA)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Average RMS current measured at the generator output (mA). J1939-DA PGN 65030 Generator Average Basic AC Quantities (GAAC), SPN 2448",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAverageACFrequencyMicroHertz,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Average AC frequency measured at the generator output (uHz)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Average AC frequency measured at the generator output (uHz). J1939-DA PGN 65030 Generator Average Basic AC Quantities (GAAC), SPN 2436",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAverageLineToLineACRMSMilliVolts,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Average Line to Line RMS voltage measured at the generator output (mV)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Average Line to Line RMS voltage measured at the generator output (mV). J1939-DA PGN 65030 Generator Average Basic AC Quantities (GAAC), SPN 2440",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDAverageLineToNeutralACRMSMilliVolts,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "The average Line to Neutral AC RMS voltage measured at the Generator output (mV)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "The average Line to Neutral AC RMS voltage measured at the Generator output (mV). J1939-DA PGN 65030 Generator Average Basic AC Quantities (GAAC), SPN 2444",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBackendComputedSpeedLimit,
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			BinaryMessageField: "BackendComputedSpeedLimit",
			MetadataInfo: &MetadataInfo{
				Description: "Backend speed limit computed from location stats",
				Frequency:   FrequencyEveryXSeconds(60 * 5),
				ColumnDescriptions: map[string]string{
					"value.proto_value.backend_computed_speed_limit.latitude_degrees":              "Current GPS latitude (degrees)",
					"value.proto_value.backend_computed_speed_limit.longitude_degrees":             "Current GPS longitude (degrees)",
					"value.proto_value.backend_computed_speed_limit.has_way_id":                    "If there is valid way id",
					"value.proto_value.backend_computed_speed_limit.way_id":                        "Way id for current latitude and longitude points",
					"value.proto_value.backend_computed_speed_limit.has_speed_limit":               "If there is valid speed limit",
					"value.proto_value.backend_computed_speed_limit.speed_limit_meters_per_second": "Speed limit for current latitude and longitude in meters per second",
					"value.proto_value.backend_computed_speed_limit.speed_limit_source":            "Speed limit source used for computing speed limit for the gps point",
					"value.proto_value.backend_computed_speed_limit.map_matching_method":           "Map matching source used for computing way id for the gps point",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				UseTieredSchedule: true,
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(64),
						PartitionChunkSize: pointer.IntPtr(50),
					},
				},
				DisableServerless: true,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBandwidthReport,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BandwidthReport",
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Usage report from the current cellular SIM in use.",
				Frequency:   FrequencyEveryXSeconds(60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.bandwidth_report.lte_category":                        metadatahelpers.EnumDescription("", hubproto.ObjectStatBinaryMessage_BandwidthReport_LteCategory_name),
					"value.proto_value.bandwidth_report.instance_type":                       "Test instance type. This is currently hard-coded to NDT7. Ndt7 measures the application-level download and upload performance using WebSockets over TLS.",
					"value.proto_value.bandwidth_report.upload_bytes":                        "Number of bytes uploaded.",
					"value.proto_value.bandwidth_report.download_bytes":                      "Number of bytes download.",
					"value.proto_value.bandwidth_report.upload_duration_ms":                  "Amonut of time spent uploading (milli-seconds)",
					"value.proto_value.bandwidth_report.latitude_nd":                         "Current GPS latitude (nano-degrees)",
					"value.proto_value.bandwidth_report.longitude_nd":                        "Current GPS longitude (nano-degrees)",
					"value.proto_value.bandwidth_report.download_duration_ms":                "Amount of time spent downloading (milliseconds)",
					"value.proto_value.bandwidth_report.send_buffer_bytes":                   "Configured send buffer size (bytes)",
					"value.proto_value.bandwidth_report.receive_buffer_bytes":                "Configured receive buffer size (bytes)",
					"value.proto_value.bandwidth_report.server":                              "Fully qualified domain name (FQDN) of the connected server.",
					"value.proto_value.bandwidth_report.avg_rtt_us":                          "Average round trip time (RTT) in micro-seconds.",
					"value.proto_value.bandwidth_report.min_rtt_us":                          "Minimum round trip time (RTT) in micro-seconds.",
					"value.proto_value.bandwidth_report.max_rtt_us":                          "Maximum round trip time (RTT) in micro-seconds.",
					"value.proto_value.bandwidth_report.cellular_sim_slot":                   metadatahelpers.EnumDescription("", hubproto.SimSlot_name),
					"value.proto_value.bandwidth_report.cellular_rat":                        metadatahelpers.EnumDescription("Current cellular", fwenumproto.Mdm9607DSDSysRAT_name),
					"value.proto_value.bandwidth_report.cellular_operator":                   "Current cellular operator.",
					"value.proto_value.bandwidth_report.cellular_rssi_dbm":                   "Current signal stregth in decible milliwatts.",
					"value.proto_value.bandwidth_report.euicc_profile.profile_name":          "Name of the active eUICC profile. Only present if the SIM is an eUICC",
					"value.proto_value.bandwidth_report.euicc_profile.service_provider_name": "Name of the service provider in the active eUICC profile. Only present if the SIM is an eUICC",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDBansheeDetected,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "The stat is reported upon Banshee connection, and then periodically while Banshee remains connected. The existence of the object stat itself means that Banshee was connected at the osDBansheeDetected's timestamp.",
				Frequency:           FrequencyCustom("The stat is reported upon Banshee connection, and then periodically while Banshee remains connected."),
				IntValueDescription: "Should always be 0.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDBarCodeScan,
			Kind:     StatKindObjectStat,
			// Uses "QRCode" field because both barcodes and QR codes currently encode the same driver assignment
			// data structure (qrcodeproto.QRCode).
			// This shared structure approach could be changed to use separate proto messages in the future.
			BinaryMessageField: "QRCode",
			Tags:               []amundsentags.Tag{amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "Bar Code driver assignment scans",
				Frequency:   FrequencyCustom("Reported when a driver scans an Bar Code (via an inward-facing CM) in a vehicle"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.q_r_code.version_id":                   "Version of the Bar code that was read by the CM.",
					"value.proto_value.q_r_code.driver_assignment_lookup_key": "External Employee ID of the driver that this Bar code belongs to.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDBarometricPressurePa,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Barometric pressure reported from vehicle (Pa)",
				Frequency:           FrequencyCustom("configuration required"),
				IntValueDescription: "Barometric pressure reported from vehicle. This is currently not configured to report. Values exist on J1939/J1979/ISO27145/J1587",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBattery,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "AnalogInputMillivolts",
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current Samsara gateway battery voltage (mV)",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Current Samsara device battery voltage (mV). Each product reads this information from sysfs and adjusts due to hardware differences feeding into the ADC.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.analog_input_millivolts.duration_ms":   "Time since the last report",
					"value.proto_value.analog_input_millivolts.current_value": "Value matching the IntValue being reported",
					"value.proto_value.analog_input_millivolts.max_value":     "Maximum value seen since the last report",
					"value.proto_value.analog_input_millivolts.min_value":     "Minimum value seen since the last report",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				UseTieredSchedule: true,
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBatteryInfo,
			BinaryMessageField: "BatteryInfo",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Battery Information used to approximate remaining device life",
				Frequency:   FrequencyOnChange("Logged at least every 12 hours"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.battery_info.cell.id":                metadatahelpers.EnumDescription("Which battery cell", nrfzephyrproto.BatteryCell_CellID_name),
					"value.proto_value.battery_info.cell.mv":                "Battery cell voltage in mV",
					"value.proto_value.battery_info.temperature_mc":         "Temperature in mC",
					"value.proto_value.battery_info.charger.hardware":       metadatahelpers.EnumDescription("Which battery charger", nrfzephyrproto.BatteryCharger_Hardware_name),
					"value.proto_value.battery_info.charger.status":         metadatahelpers.EnumDescription("Charging Status", nrfzephyrproto.BatteryCharger_Status_name),
					"value.proto_value.battery_info.charger.reg.address":    "Address of battery charger register",
					"value.proto_value.battery_info.charger.reg.value":      "Value of battery charger register at Address",
					"value.proto_value.battery_info.fuel_gauge.hardware":    metadatahelpers.EnumDescription("Which fuel gauge", nrfzephyrproto.FuelGauge_Hardware_name),
					"value.proto_value.battery_info.fuel_gauge.reg.address": "Address of Fuel Gauge register",
					"value.proto_value.battery_info.fuel_gauge.reg.value":   "Value of Fuel Gauge register at Address",
					"value.proto_value.battery_info.fuel_gauge.soc":         "Fuel Gauge State of Charge (SoC) in percent",
					"value.proto_value.battery_info.fuel_gauge.mv":          "Fuel Gauge voltage in mV",
					"value.proto_value.battery_info.fuel_gauge.ma":          "Fuel Gauge average current in mA",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDBatteryLevel,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.AssetsTag,
				amundsentags.AG46Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "The string description of the battery level of the device. This differs from osDBattery because we want to calculate the battery level async, and do not use osDBattery to determine battery level for all associated gateways.",
				Frequency:           FrequencyCustom("This will be calculated weekly by batterylevelworker."),
				IntValueDescription: "Enum value of the battery state for the device. See go/src/samsaradev.io/products/battery_levels.go for enum values.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDBatteryPotentialSwitchedMilliV,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBendixStats,
			BinaryMessageField: "BendixStats",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Periodically logged by devices configured to support the Bendix integration. Contains integration health metrics",
				Frequency:   FrequencyEveryXSeconds(300),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBleAssociationEnd,
			BinaryMessageField: "BleAssociationEnd",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Data corresponding to the end of a BLE association between a central and a peripheral",
				Frequency:   FrequencyCustom("Logged when a BLE association ends"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_association_end.relationship_uuid":                                  "UUID of the BLE association",
					"value.proto_value.ble_association_end.central_asset_id":                                   "Asset ID of the central",
					"value.proto_value.ble_association_end.start_ms":                                           "Timestamp of the start of the BLE association",
					"value.proto_value.ble_association_end.end_ms":                                             "Timestamp of the end of the BLE association",
					"value.proto_value.ble_association_end.association_snapshot.central_location.latitude":     "Latitude of the central when association ended",
					"value.proto_value.ble_association_end.association_snapshot.central_location.longitude":    "Longitude of the central when association ended",
					"value.proto_value.ble_association_end.association_snapshot.central_location.time_ms":      "Timestamp of the central when association ended",
					"value.proto_value.ble_association_end.association_snapshot.peripheral_location.latitude":  "Latitude of the peripheral when association ended",
					"value.proto_value.ble_association_end.association_snapshot.peripheral_location.longitude": "Longitude of the peripheral when association ended",
					"value.proto_value.ble_association_end.association_snapshot.peripheral_location.time_ms":   "Timestamp of the peripheral when association ended",
					"value.proto_value.ble_association_end.association_snapshot.observations_by_central":       "Number of peripheral observations by the central during the polling window",
					"value.proto_value.ble_association_end.association_snapshot.separation_distance_meters":    "Separation distance between the central and the peripheral (meters)",
					"value.proto_value.ble_association_end.association_snapshot.processing_window_start_ms":    "Timestamp of the start of the polling window for the association breaker",
					"value.proto_value.ble_association_end.association_snapshot.processing_window_end_ms":      "Timestamp of the end of the polling window for the association breaker",
					"value.proto_value.ble_association_end.break_reason":                                       "Reason for the end of the BLE association",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBleAssociationEvent,
			BinaryMessageField: "BleAssociationEvent",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Data corresponding to an event in a BLE association between a central and a peripheral",
				Frequency:   FrequencyCustom("Logged for each active association during every breaker polling window if the association has not ended"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_association_event.relationship_uuid":                                  "UUID of the BLE association",
					"value.proto_value.ble_association_event.central_asset_id":                                   "Asset ID of the central",
					"value.proto_value.ble_association_event.event_ms":                                           "Timestamp of the event",
					"value.proto_value.ble_association_event.association_snapshot.central_location.latitude":     "Latitude of the central during association event",
					"value.proto_value.ble_association_event.association_snapshot.central_location.longitude":    "Longitude of the central during association event",
					"value.proto_value.ble_association_event.association_snapshot.central_location.time_ms":      "Timestamp of the central during association event",
					"value.proto_value.ble_association_event.association_snapshot.peripheral_location.latitude":  "Latitude of the peripheral during association event",
					"value.proto_value.ble_association_event.association_snapshot.peripheral_location.longitude": "Longitude of the peripheral during association event",
					"value.proto_value.ble_association_event.association_snapshot.peripheral_location.time_ms":   "Timestamp of the peripheral during association event",
					"value.proto_value.ble_association_event.association_snapshot.observations_by_central":       "Number of peripheral observations by the central during the polling window",
					"value.proto_value.ble_association_event.association_snapshot.separation_distance_meters":    "Separation distance between the central and the peripheral (meters)",
					"value.proto_value.ble_association_event.association_snapshot.processing_window_start_ms":    "Timestamp of the start of the polling window for the association breaker",
					"value.proto_value.ble_association_event.association_snapshot.processing_window_end_ms":      "Timestamp of the end of the polling window for the association breaker",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBleAssociationStart,
			BinaryMessageField: "BleAssociationStart",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Data corresponding to the start of a BLE association between a central and a peripheral",
				Frequency:   FrequencyCustom("Logged when a BLE association starts"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_association_start.relationship_uuid":                             "UUID of the BLE association",
					"value.proto_value.ble_association_start.central_asset_id":                              "Asset ID of the central",
					"value.proto_value.ble_association_start.start_ms":                                      "Timestamp of the start of the BLE association",
					"value.proto_value.ble_association_start.relationship_type":                             "Type of the BLE association",
					"value.proto_value.ble_association_start.peripheral_location.latitude":                  "Latitude of the peripheral when association started",
					"value.proto_value.ble_association_start.peripheral_location.longitude":                 "Longitude of the peripheral when association started",
					"value.proto_value.ble_association_start.peripheral_location.time_ms":                   "Timestamp of the peripheral when association started",
					"value.proto_value.ble_association_start.observations_by_central":                       "Number of peripheral observations by the central during the processing window",
					"value.proto_value.ble_association_start.peripheral_distance_moved_with_central_meters": "Peripheral distance observed by central (meters)",
					"value.proto_value.ble_association_start.total_peripheral_distance_moved_meters":        "Total peripheral distance moved (meters)",
					"value.proto_value.ble_association_start.processing_window_start_ms":                    "Timestamp of the start of the processing window for the association producer",
					"value.proto_value.ble_association_start.processing_window_end_ms":                      "Timestamp of the end of the processing window for the association producer",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBleConnectionStats,
			BinaryMessageField: "BleConnectionStats",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Reports BLE connection statistics and slot events from gateways",
				Frequency:   FrequencyOnChange("On BLE connection state changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_connection_stats.slot_event.mac":        "MAC address of the BLE device",
					"value.proto_value.ble_connection_stats.slot_event.product_id": "Product ID of the BLE device",
					"value.proto_value.ble_connection_stats.slot_event.state":      "Connection state of the BLE device (SLOT_STATE_UNKNOWN, SLOT_STATE_CONNECTED, SLOT_STATE_DISCONNECTED)",
					"value.proto_value.ble_connection_stats.slot_event.reason":     "Reason for the dis/connection event (EVENT_REASON_UNKNOWN, EVENT_REASON_TIMEOUT, EVENT_REASON_ERROR, EVENT_REASON_YIELDED, etc.)",
					"value.proto_value.ble_connection_stats.slot_event.rssi_dbm":   "RSSI of the BLE connection in dBm",
					"value.proto_value.ble_connection_stats.used_slots":            "List of used connection slots with their product IDs",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBlePeripheralAccelData,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BlePeripheralAccelData",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.BifrostTag},
			MetadataInfo: &MetadataInfo{
				Description: "Acceleration data from BLE peripherals",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_peripheral_accel_data.x_ug":          "Array of acceleration in the x-axis in micro-g",
					"value.proto_value.ble_peripheral_accel_data.y_ug":          "Array of acceleration in the y-axis in micro-g",
					"value.proto_value.ble_peripheral_accel_data.z_ug":          "Array of acceleration in the z-axis in micro-g",
					"value.proto_value.ble_peripheral_accel_data.num_samples":   "Number of samples in the acceleration data",
					"value.proto_value.ble_peripheral_accel_data.delta_encoded": "Flag to indicate if the samples are delta encoded. If delta encoded is true, first item is the oldest",
					"value.proto_value.ble_peripheral_accel_data.in_motion":     "Whether the device is in motion",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBlePeripheralConfigCheckData,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BlePeripheralConfigCheckData",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.BifrostTag},
			MetadataInfo: &MetadataInfo{
				Description: "Config check data from BLE peripherals",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_peripheral_config_check_data.status":     metadatahelpers.EnumDescription("Config check status", bleproxyproto.ConfigCheckData_ConfigStatus_name),
					"value.proto_value.ble_peripheral_config_check_data.config":     "Serialized peripheral config",
					"value.proto_value.ble_peripheral_config_check_data.error_code": metadatahelpers.EnumDescription("Config type", bifrost.BifrostError_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBlePeripheralMockData,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BlePeripheralMockData",
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.BifrostTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Mock data for BLE peripheral testing and development",
				Frequency:   FrequencyCustom("When mock data is generated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_peripheral_mock_data.value": "Mock data value",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBleProxiedAdvertisement,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BleProxiedAdvertisement",
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Data corresponding to a BLE Proxied Advertisement, AKA Crux",
				Frequency:   FrequencyCustom("Logged when compatible peripheral(s) are observed by a central, default 1 minute per peripheral, but it is configurable"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_proxied_advertisement.peripherals.uuid":                                                 metadatahelpers.EnumDescription("BLE Service UUID", bleproxyproto.ServiceUuid_name),
					"value.proto_value.ble_proxied_advertisement.peripherals.mac_observed":                                         "MAC address observed, may or may not be encrypted",
					"value.proto_value.ble_proxied_advertisement.peripherals.num_times_observed_during_batch_period":               "Number of times the peripheral was observed during the log period (will be non-zero only if different from number of repeated peripherals)",
					"value.proto_value.ble_proxied_advertisement.peripherals.last_adv_packet_data":                                 "Verbatim advertisement data observed in last advertisement in batch period",
					"value.proto_value.ble_proxied_advertisement.peripherals.tx_power_is_invalid":                                  "Set to true if the central couldn't understand the structure of advertisement to decode TX power",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series.incremental_observed_at_offset_ds": "Array with incremental deciseconds deltas after the log's happenedAtMs that this advertisement was observed",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series.incremental_rssi_dbm":              "Array of deltas of received signal strength of the peripheral as seen by the central, in dBm",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series.incremental_tx_power_dbm":          "Array of deltas of transmit power of peripheral, in dBm (note that 0 is a valid value)",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series":                                   "Observation data that occurs during the batch period corresponding to this peripheral",
					"value.proto_value.ble_proxied_advertisement.peripherals.third_party_integration_id":                           "Device type ID used for third party BLE integrations, telling the backend what the data type is for use when parsing",
					"value.proto_value.ble_proxied_advertisement.peripherals":                                                      "Peripheral data observed during the batch period",
					"value.proto_value.ble_proxied_advertisement.batch_duration_sec":                                               "Amount of time (in seconds) the central scanned before uploading this stat",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBleProxiedConnectionDataCritical,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BleProxiedConnectionData",
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Data (of CRITICAL priority)corresponding to a BLE peripheral's internal logs, offloaded and logged by a central",
				Frequency:   FrequencyCustom("Logged when compatible peripheral(s) are connected to by a central and logs are pulled off the peripheral"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_proxied_connection_data.mac_address":      "MAC address of the peripheral",
					"value.proto_value.ble_proxied_connection_data.peripheral_ts_ms": "Timestamp of the peripheral as close to happenAtMs as can be achieved",
					"value.proto_value.ble_proxied_connection_data.peripheral_data":  "array of BlePeripheralData entries. Type is opaque to the central to decouple all knowledge of peripheral logs from central",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBleProxiedConnectionDataLow,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BleProxiedConnectionData",
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Data (of LOW priority)corresponding to a BLE peripheral's internal logs, offloaded and logged by a central",
				Frequency:   FrequencyCustom("Logged when compatible peripheral(s) are connected to by a central and logs are pulled off the peripheral"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_proxied_connection_data.mac_address":      "MAC address of the peripheral",
					"value.proto_value.ble_proxied_connection_data.peripheral_ts_ms": "Timestamp of the peripheral as close to happenAtMs as can be achieved",
					"value.proto_value.ble_proxied_connection_data.peripheral_data":  "array of BlePeripheralData entries. Type is opaque to the central to decouple all knowledge of peripheral logs from central",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBleProxiedConnectionDataMedium,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BleProxiedConnectionData",
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Data (of MEDIUM priority)corresponding to a BLE peripheral's internal logs, offloaded and logged by a central",
				Frequency:   FrequencyCustom("Logged when compatible peripheral(s) are connected to by a central and logs are pulled off the peripheral"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_proxied_connection_data.mac_address":      "MAC address of the peripheral",
					"value.proto_value.ble_proxied_connection_data.peripheral_ts_ms": "Timestamp of the peripheral as close to happenAtMs as can be achieved",
					"value.proto_value.ble_proxied_connection_data.peripheral_data":  "array of BlePeripheralData entries. Type is opaque to the central to decouple all knowledge of peripheral logs from central",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDBoostPressurePa,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle boost pressure reported (Pa)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "The gage pressure measurement of the air intake manifold. If there are multiple air pressure sensors in the intake stream, this is the last one in flow direction before entering the combustion chamber.  This should be the pressure used to drive gauges and displays. See also SPNs 1127-1130 and SPN 3562  for alternate range and resolution. If there is only one pressure measurement of the air intake manifold to report and this range and resolution is adequate, this parameter should be used. This is only reported on J1939 vehicles.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDBoostPressureTurbocharger1Pa,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle boost pressure in turbocharger 1 (Pa)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Gage pressure of air measured downstream of the compressor discharge side of the turbocharger.  See also SPN 102 for alternate range and resolution. If there is only one boost pressure to report and the range and resolution in SPN 102 is adequate, then it should be used. J1939 only",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDBoostPressureTurbocharger2Pa,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle boost pressure in turbocharger 2 (Pa)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Gage pressure of air measured downstream of the compressor discharge side of the turbocharger.  See also SPN 102 for alternate range and resolution. If there is only one boost pressure to report and the range and resolution in SPN 102  is adequate, then it should be used.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBrakeEvent,
			BinaryMessageField: "BrakeEvent",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Data about a brake event",
				Frequency:   FrequencyCustom("Depends on how often qualified brake events are reported."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.brake_event.braking_effort_percent": "The amount of braking effort applied. 100% would mean the vehicle is decelerating at 1g (full gravity force).",
					"value.proto_value.brake_event.pressure_bar":           "The pressure at which the braking effort was applied",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBrakeEvents,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle brake presses detected",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Number of brake press transitions detected. The value increases for each brake press/release seen from the vehicle. Values derived for both passenger and heavy duty vehicles.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("brake events", hubproto.ObdValue_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBrakeLiningMonitor,
			BinaryMessageField: "BrakeLiningMonitor",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.MarathonTag, amundsentags.AG53Tag},
			MetadataInfo: &MetadataInfo{
				Description: "Brake Pad/Lining statuses for each available wheel end",
				Frequency:   FrequencyEveryXSeconds(15 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.brake_lining_monitor.ecu_id":                               "Brake effort estimated at the measured pressure",
					"value.proto_value.brake_lining_monitor.wheel_end.axle_from_front":            "Axle that the brake lining data is for, 0 indexed",
					"value.proto_value.brake_lining_monitor.wheel_end.axle_side":                  metadatahelpers.EnumDescription("Left or right end of the axle", brakemonitoringproto.BrakeLiningMonitor_AxleSide_name),
					"value.proto_value.brake_lining_monitor.wheel_end.has_pad_remaining_millipct": "If the pad_remaining_millipct field is valid, as some systems only report brake_lining_status",
					"value.proto_value.brake_lining_monitor.wheel_end.pad_remaining_millipct":     "The millipercent of brake pad remaining",
					"value.proto_value.brake_lining_monitor.wheel_end.brake_lining_status":        metadatahelpers.EnumDescription("If available, reports if the pad level is sufficient", brakemonitoringproto.BrakeLiningMonitor_BrakeLiningStatus_name),
					"value.proto_value.brake_lining_monitor.wheel_end.brake_lining_sensor_status": metadatahelpers.EnumDescription("Status of the sensor ie. Connected or in an error state", brakemonitoringproto.BrakeLiningMonitor_BrakeLiningSensorStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBrakeScore,
			BinaryMessageField: "BrakeScore",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Brake score we will use to determine if a trailer's brakes are in good or bad condition",
				Frequency:   FrequencyCustom("Once every six hours."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.brake_score.braking_effort_percent_score":                             "Braking effort estimated at 6.5 bar pressure",
					"value.proto_value.brake_score.metadata.measured_pressure_bar":                           "The pressure at which it was measured",
					"value.proto_value.brake_score.metadata.version":                                         "The version of the brake score algorithm",
					"value.proto_value.brake_score.metadata.margin_of_error":                                 "The margin of error",
					"value.proto_value.brake_score.metadata.confidence_interval":                             "Confidence interval at 95% confidence",
					"value.proto_value.brake_score.metadata.regression_slope":                                "Slope of regression line of brake demand pressure vs. performance",
					"value.proto_value.brake_score.metadata.regression_brake_performance_intercept":          "Braking performance intercept of regression line of brake demand pressure vs. performance",
					"value.proto_value.brake_score.start_time_ms":                                            "Start timestamp of the range, end timestamp would be the time of the object stat",
					"value.proto_value.brake_score.event_count":                                              "Number of brake events used",
					"value.proto_value.brake_score.event_below_threshold_count":                              "Number of brake events below the brake performance threshold",
					"value.proto_value.brake_score.weighted_braking_effort_percent_score":                    "Weighted braking effort estimated at 6.5 bar pressure (emphasizes points converging to the line)",
					"value.proto_value.brake_score.weighted_metadata.measured_pressure_bar":                  "The pressure at which the weighted score was measured",
					"value.proto_value.brake_score.weighted_metadata.version":                                "The version of the brake score algorithm for the weighted score",
					"value.proto_value.brake_score.weighted_metadata.margin_of_error":                        "The margin of error for the weighted score",
					"value.proto_value.brake_score.weighted_metadata.confidence_interval":                    "Confidence interval at 95% confidence for the weighted score",
					"value.proto_value.brake_score.weighted_metadata.regression_slope":                       "Slope of regression line for the weighted brake score",
					"value.proto_value.brake_score.weighted_metadata.regression_brake_performance_intercept": "Braking performance intercept for the weighted brake score",
					"value.proto_value.brake_score.check_ebs_metadata":                                       "Metadata used to track the state of the Check EBS label surfaced to customers. Populated only when the label is applicable for the score window.",
					"value.proto_value.brake_score.check_ebs_metadata.active":                                "Whether the Check EBS label should be shown for this score's window.",
					"value.proto_value.brake_score.check_ebs_metadata.last_triggered_at_ms":                  "Last time we saw a qualifying event exceeding the configured pressure threshold within the score window.",
					"value.proto_value.brake_score.check_ebs_metadata.trigger_count":                         "Number of qualifying events exceeding the configured pressure threshold within the score window.",
					"value.proto_value.brake_score.check_ebs_metadata.threshold_pressure_bar":                "Pressure bar threshold for indicating a potential issue with the EBS system.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDBrakeStatus,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "The brake status indicating if the margin of error is less than 3%",
				Frequency:           FrequencyCustom("Less than once every six hours."),
				IntValueDescription: metadatahelpers.EnumDescription("The current state of the brake system", brakemonitoringproto.BrakeStatus_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDBusIdConnectionStates,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BusIdConnectionStates",
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Tracks the state of the various bus ID we have connected or disconnected from during a diagnostic session",
				Frequency:   FrequencyOnChange("Logs whenever a bus ID has newly connected or disconnected"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.bus_id_connection_states.bus_id":                 metadatahelpers.EnumDescription("The bus ID that this connection state message details", hubproto.BusId_name),
					"value.proto_value.bus_id_connection_states.bus_id_connection":      metadatahelpers.EnumDescription("The bus ID connection status", hubproto.BusIdConnectionState_BusIdConnection_name),
					"value.proto_value.bus_id_connection_states.vehicle_diagnostic_bus": metadatahelpers.EnumDescription("The vehicle diagnostic bus connected to the bus id", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.bus_id_connection_states.bus_id_settings":        "Contains the setting parameters related to the bus ID",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDCableChangeDetected,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDCableIdMeasuredMv,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCableUpgrade,
			BinaryMessageField: "CableUpgrade",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDCableVoltage,
			Kind:                 StatKindObjectStat,
			DataModelStat:        true,
			BinaryMessageField:   "AnalogInputMillivolts",
			S3BinaryMessageField: "ExternalVoltageSamplesBatch",
			Tags:                 []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "External voltage of the device power source",
				Frequency:           FrequencyCustom("determined by device config digio_config.analog_input_sample_period_ms"),
				IntValueDescription: "External voltage millivolts",
				ColumnDescriptions: map[string]string{
					"value.proto_value.analog_input_millivolts.duration_ms":    "Time since the last report",
					"value.proto_value.analog_input_millivolts.current_value":  "Value matching the IntValue being reported",
					"value.proto_value.analog_input_millivolts.max_value":      "Maximum value seen since the last report",
					"value.proto_value.analog_input_millivolts.min_value":      "Minimum value seen since the last report",
					"s3_proto_value.external_voltage_samples_batch.offset_ms":  "log event time ms - offset_ms is the time when the sample was taken",
					"s3_proto_value.external_voltage_samples_batch.voltage_mv": "voltage in millivolts",
					"s3_proto_value.external_voltage_samples_batch.is_live":    "true if the data is live, false if it is cached",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				UseTieredSchedule: true,
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCameraButtonEvent,
			BinaryMessageField: "CameraButtonEvent",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Camera button was pressed",
				Frequency:           FrequencyOnChange("button press"),
				IntValueDescription: "The type of button press (e.g. single, double, long)",
				ColumnDescriptions: map[string]string{
					"object_id": "CM device ID",
					"value.proto_value.camera_button_event.event_type": "The type of button press (e.g. single, double, long)",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCameraEvent,
			BinaryMessageField: "CameraEvent",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCameraSdCardState,
			BinaryMessageField: "CameraSdCardState",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "The current state of the SD card plugged into this camera product",
				Frequency:   FrequencyOnChange("On insertion and removal of SD card"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.camera_sd_card_state.state":            "The current state of the SD card (eg. inserted, not inserted, any errors while inserting, etc)",
					"value.proto_value.camera_sd_card_state.failure_reason":   "Error string if the card is in an error state",
					"value.proto_value.camera_sd_card_state.card_health":      "Health metrics for the inserted SD card",
					"value.proto_value.camera_sd_card_state.sd_card_cid":      "CID of the inserted SD card",
					"value.proto_value.camera_sd_card_state.total_storage_kb": "Total storage value of the inserted SD card in KiB",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDCanAdcCableMicroVolts,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Analog to digital (adc) voltage reading (uv)",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "Cable voltage read from and ADC MCU (microcontroller). This was meant for AG customers connected to a J1939 bus. The ADC is reported under ECU TXID 0x25, and is produced by the local ADC MCU on an AG.",
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDCanBitrateDetection,
			BinaryMessageField:       "CanBitrateDetectionResults",
			Kind:                     StatKindObjectStat,
			DataModelStat:            true,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCanBitrateDetectionV2,
			BinaryMessageField: "CanBitrateDetectionV2Results",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Results and information around the success or failure of CAN bitrate detection on a CAN bus",
				Frequency:   FrequencyCustom("after a bus bitrate detection completes (success or failure)"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.can_bitrate_detection_v2_results.bus_id":                                                        "The bus id that the bitrate detection ran on",
					"value.proto_value.can_bitrate_detection_v2_results.detected_bitrate":                                              "The detected bitrate for this bus id",
					"value.proto_value.can_bitrate_detection_v2_results.listen_only_detection_error":                                   "Populated if listen-only autodetect encountered an error during runtime",
					"value.proto_value.can_bitrate_detection_v2_results.one_shot_detection_error":                                      "Populated if one-shot autodetect encountered an error during runtime",
					"value.proto_value.can_bitrate_detection_v2_results.listen_only_detection_metadata.data_frame_count":               "Count of data frames seen during listen-only window for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.listen_only_detection_metadata.error_frame_count":              "Count of error frames seen during listen-only window for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.listen_only_detection_metadata.data_frame_bit_count":           "Total data bit count seen during listen-only window for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.listen_only_detection_metadata.runtime_ms":                     "The listen-only window duration for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.listen_only_detection_metadata.bitrate":                        "The detected listen-only bitrate for this bus id",
					"value.proto_value.can_bitrate_detection_v2_results.listen_only_detection_metadata.protocol_bit0_frame_count":      "Count of bit0 frames seen during listen-only window for a bitrate detection. Bit0 frames are a special type of frame seen from Thor controllers on silent gateways.",
					"value.proto_value.can_bitrate_detection_v2_results.listen_only_detection_metadata.bit_stuffing_error_frame_count": "Count of bit stuffing frames seen during listen-only window for a bitrate detection. In FMS vehicles we occasionally see these during a valid bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.one_shot_detection_metadata.bitrate":                           "The detected one-shot bitrate for this bus id",
					"value.proto_value.can_bitrate_detection_v2_results.one_shot_detection_metadata.runtime_ms":                        "The actual one-shot window duration for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.one_shot_detection_metadata.error_frame_count":                 "Count of error frames seen during one-shot window for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.one_shot_detection_metadata.data_frame_count":                  "Count of data frames seen during the one-shot window for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.one_shot_detection_metadata.sent_one_shot_frame_count":         "Count of sent one-shots during the window for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.detection_params.possible_bitrates":                            "The list of bitrates that detection will run on for a CAN bus id for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.detection_params.max_listen_ms":                                "The maximum duration of time allowed to try to detect a bitrate for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.detection_params.min_data_frames":                              "The minimum number of data frames needed for listen-only to succeed for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.detection_params.min_data_frames_per_error_frame_ratio":        "The minimum ratio of data-to-error frames for listen-only to succeed for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.detection_params.active_mode_min_bitrate_percent":              "The minimum threshold for active mode to be considered",
					"value.proto_value.can_bitrate_detection_v2_results.detection_params.one_shot_send_frame_interval_ms":              "The send interval for one-shot requests during a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.detection_params.one_shot_max_send_frame_count":                "The maximum number of one-shot sends allowed for a bitrate detection",
					"value.proto_value.can_bitrate_detection_v2_results.primary_bus_bitrate_detection_behavior":                        metadatahelpers.EnumDescription("Determines how the primary bus id autodetect result is handled in Universal Vehicle Loop", hubproto.CanBitrateDetection_PrimaryBusBitrateDetectionBehavior_name),
					"value.proto_value.can_bitrate_detection_v2_results.bitrate_detect_method_that_passed":                             metadatahelpers.EnumDescription("Details which autodetect method succeeded", hubproto.ObjectStatBinaryMessage_CanBitrateDetectionV2Results_BitrateDetectMethodThatPassed_name),
					"value.proto_value.can_bitrate_detection_v2_results.detected_polarity":                                             metadatahelpers.EnumDescription("The polarity of the successfully detection", objectstatproto.VehicleBusConfig_CanConfig_CanPolarity_name),
					"value.proto_value.can_bitrate_detection_v2_results.can_interface":                                                 metadatahelpers.EnumDescription("The CAN interface that the bitrate detection ran on", hubproto.CanInterface_name),
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDCanBusErrors,
			BinaryMessageField:       "CanBusErrorInfo",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCanBusType,
			BinaryMessageField: "CanBusInfo",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Firmware device establishes connection with CAN bus",
				Frequency:           FrequencyCustom("a CAN connection is established"),
				IntValueDescription: metadatahelpers.EnumDescription("Primary CAN bus type in use. Naming includes physical pins being used, the CAN network interface used, as well as the protocol in use.", logeventproto.LogEvent_ObdEvent_CanBusType_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.can_bus_info.can_bus_type_enum": metadatahelpers.EnumDescription("Secondary CAN bus type in use. Naming includes physical pins being used, the CAN network interface used, as well as the protocol in use.", logeventproto.LogEvent_ObdEvent_CanBusType_name),
					"value.proto_value.can_bus_info.bitrate":           "Bitrate of the secondary CAN interface",
				},
			},
			Production: true,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDCanConnected,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Firmware device establishes connection with a CAN bus",
				Frequency:           FrequencyCustom("a CAN connection is established"),
				IntValueDescription: metadatahelpers.EnumDescription("Passenger vehicles log after successful detection of J1979 or ISO27145 on a new CAN bus. Heavy duty vehicles log connected after at least a single CAN bus has been brought up.", logeventproto.LogEvent_ObdEvent_ObdEventTypeEnum_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCanProtocolsDetected,
			BinaryMessageField: "CanProtocolsDetected",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Information around the detected protocols on a CAN bus and if they were selected to run on the bus",
				Frequency:   FrequencyCustom("On connection to a vehicle's CAN bus"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.can_protocols_detected.bus_id":                                                 "The CAN bus id that the protocol detection ran on",
					"value.proto_value.can_protocols_detected.can_protocol_detection_params":                          "The parameters used to configure the protocol detection",
					"value.proto_value.can_protocols_detected.detected_can_protocols.protocol":                        "Protocol detected during the routine",
					"value.proto_value.can_protocols_detected.detected_can_protocols.protocol_detection_method":       metadatahelpers.EnumDescription("Details what detection method was used to detect the protocol", hubproto.ObjectStatBinaryMessage_CanProtocolsDetected_DetectedCanProtocol_ProtocolDetectionMethod_name),
					"value.proto_value.can_protocols_detected.detected_can_protocols.selected_to_run":                 "Determines if the detected protocol will run in the higher level loop",
					"value.proto_value.can_protocols_detected.detected_can_protocols.can_id_type":                     metadatahelpers.EnumDescription("The CAN id type of the protocol", objectstatproto.VehicleBusConfig_CanConfig_CanIdType_name),
					"value.proto_value.can_protocols_detected.detected_can_protocols.default_module_address":          "The default request address used by the protocol if not specified by a command (e.g. 0x7DF for standard J1979)",
					"value.proto_value.can_protocols_detected.detected_can_protocols.protocol_detect_retry_count":     "Count of protocol detection retries before passing",
					"value.proto_value.can_protocols_detected.detected_can_protocols.broadcast_pgn_allowlist_enabled": "Whether the broadcast PGN allowlist is enabled",
					"value.proto_value.can_protocols_detected.detected_can_protocols.j1939_can_ids_seen":              "The list of CANID(s) that resulted in j1939 protocol detection",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCanRecorderInfo,
			BinaryMessageField: "CanRecorderInfo",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Indicates when CAN data recording is active.",
				Frequency:   FrequencyOnChange("When CAN data recording is started or stopped."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.can_recorder_info.interfaces.name":  "Interface Name",
					"value.proto_value.can_recorder_info.interfaces.state": metadatahelpers.EnumDescription("Can Recorder State", hubproto.CanRecorderInfo_State_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCanTrafficDetectedInNotifyMode,
			BinaryMessageField: "CanTrafficDetected",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Indicates if a CAN frame is detected on the CAN bus during low power mode.",
				Frequency:   FrequencyCustom("When FF or device config enabled and if CAN frame was detected during bus standby."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.can_traffic_detected.bus_id": "The CAN bus id that the CAN frame was detected on",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCarbFailureReport,
			BinaryMessageField: "CarbFailureReport",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "CarbFailureReport contains the failure type, session message_id of the test, and whether this was the final attempt to run the CARB test for this session message_id.",
				Frequency:   FrequencyCustom("Whenever a CARB failure is required to be generated. This is at most once per vehicle diagnostic loop session."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.carb_failure_report.failure":                    metadatahelpers.EnumDescription("Details the type of failure that occurred while testing.", hubproto.CarbFailureReport_FailureType_name),
					"value.proto_value.carb_failure_report.session_message_id":         "This is the message_id of the backend request that initiated this test.",
					"value.proto_value.carb_failure_report.current_attempt_count":      "The current test attempt number for this session message_id.",
					"value.proto_value.carb_failure_report.max_attempts_allowed_count": "The configured maximum allowed test count per session message_id at the time the test executed.",
				},
			},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDCarbReport,
			S3BinaryMessageField: "CarbReport",
			Kind:                 StatKindObjectStat,
			Tags:                 []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "CarbReport contains a header and set of CAN data frames required by the CARB. Attachment B, section E4.1.1 of the State of California Air Resources Board California Standards for Remote On-Board Diagnostic Devices.",
				Frequency:   FrequencyCustom("Whenever a CARB report is required to be generated. This is at most once every 7 days."),
				ColumnDescriptions: map[string]string{
					"s3_proto_value.carb_report.report_version_number":               "This is for internal Samsara use to note of a significant change in the generation of a CARB report. This is meant to be incremented on the firmware if there is a change of note.",
					"s3_proto_value.carb_report.session_message_id":                  "This is for internal Samsara use. It is the message_id of the backend request that initiated this test.",
					"s3_proto_value.carb_report.header":                              "The data header is one of two files required by CARB. The DataHeader contains vehicle and firmware identification information. From the regulation.",
					"s3_proto_value.carb_report.header.carb_formatted_vin":           "Vehicle identification number located on the tested vehicle in CARB-specified format.",
					"s3_proto_value.carb_report.header.sae_protocol":                 "Vehicles OBD communication protocol (SAE J1939/J1979/J1979-2).",
					"s3_proto_value.carb_report.header.odometer_meters":              "Odometer reading of the vehicle at the time the OBD data is downloaded from the vehicle OBD system (required if supported).",
					"s3_proto_value.carb_report.header.total_engine_runtime_seconds": "Accumulated engine runtime over the lifetime of the vehicle, as specified in subsectino h(5.2.1.A) of the CARB HD OBD regulation (section 1971.1, title 13, CCR). When 0 this value is invalid.",
					"s3_proto_value.carb_report.header.device_firmware_version":      "The firmware/version number of the software in the ROBD device. This is the current running firmware version located in /home/root/BUILD on a VG.",
					"s3_proto_value.carb_report.header.firmware_verification_number": "A number derived from the ROBD device firmware that verifies the firmware has not been altered.",
					"s3_proto_value.carb_report.header.record_id":                    "A unique value from an ascending numerical sequence assigned by the ROBD device to each submission.",
					"s3_proto_value.carb_report.header.start_time_offset_ms":         "The time offset, relative to the time the objectstat was logged, at which the ROBD device started downloading OBD data from the vehicle OBD system for CARB testing. The backend will process this into UTC time for the CARB report.",
					"s3_proto_value.carb_report.header.bitrate":                      "The bitrate for the CAN network we are connected to. Required by the XML version of the CARB report.",
					"s3_proto_value.carb_report.header.interface":                    "The diagnostic interface the test is running on. Required by the XML version of the CARB report.",
					"s3_proto_value.carb_report.data_frames":                         "data_frames is an application layer protocol data unit consisting of information about the ECU source of information and the raw data itself. From the regulation.",
					"s3_proto_value.carb_report.data_frames.time_offset_ms":          "The time offset, relative to the time the objectstat was logged, at which a message is sent from the ROBD device to the vehicle or received from the vehicle. The backend will process this into UTC time for the CARB report.",
					"s3_proto_value.carb_report.data_frames.message_type":            "Message type for this record.",
					"s3_proto_value.carb_report.data_frames.can_id":                  "The address of the ECUs that respond to the request.",
					"s3_proto_value.carb_report.data_frames.data":                    "The data portion of the CAN message sent to or received from the vehicles OBD system.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDCellBytes,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCellularCallEndReasons,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "CellularCallEndReasons",
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCellularDataSystemStatus,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "CellularDataSystemStatus",
			MetadataInfo: &MetadataInfo{
				Description: "logs data describing the current cellular data system status as defined by the qualcomm data system determination service",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.cellular_data_system_status.mdm9607.status.primary_system.network":                          "Qualcomm Data System Determination service (DSD) network type (3GPP, 3GPP2, or WLAN). Enumerations available at https://github.com/samsara-dev/firmware-mdm9607/blob/master/apps_proc/qmi/services/data_system_determination_v01.h#L118",
					"value.proto_value.cellular_data_system_status.mdm9607.status.primary_system.rat":                              "Qualcomm Data System Determination service (DSD) radio access technology supporting current connection (LTE, WLAN, 5G, etc.) Enumerations available at https://github.com/samsara-dev/firmware-mdm9607/blob/master/apps_proc/qmi/services/data_system_determination_v01.h#L132",
					"value.proto_value.cellular_data_system_status.mdm9607.status.primary_system.service_option_mask_low_bits":     "bits 0-30 of the Qualcomm service option mask. Options defined at https://github.com/samsara-dev/firmware-mdm9607/blob/master/apps_proc/qmi/services/data_system_determination_v01.h#L154",
					"value.proto_value.cellular_data_system_status.mdm9607.status.primary_system.service_option_mask_high_bits":    "bits 31-61 of the Qualcomm service option mask. High bits are shifted down to account for splitting the mask between two proto enums. Options defined at https://github.com/samsara-dev/firmware-mdm9607/blob/master/apps_proc/qmi/services/data_system_determination_v01.h#L154",
					"value.proto_value.cellular_data_system_status.mdm9607.status.secondary_systems.network":                       "Qualcomm Data System Determination service (DSD) network type (3GPP, 3GPP2, or WLAN). Enumerations available at https://github.com/samsara-dev/firmware-mdm9607/blob/master/apps_proc/qmi/services/data_system_determination_v01.h#L118",
					"value.proto_value.cellular_data_system_status.mdm9607.status.secondary_systems.rat":                           "Qualcomm Data System Determination service (DSD) radio access technology supporting current connection (LTE, WLAN, 5G, etc.) Enumerations available at https://github.com/samsara-dev/firmware-mdm9607/blob/master/apps_proc/qmi/services/data_system_determination_v01.h#L132",
					"value.proto_value.cellular_data_system_status.mdm9607.status.secondary_systems.service_option_mask_low_bits":  "bits 0-30 of the Qualcomm service option mask. Options defined at https://github.com/samsara-dev/firmware-mdm9607/blob/master/apps_proc/qmi/services/data_system_determination_v01.h#L154",
					"value.proto_value.cellular_data_system_status.mdm9607.status.secondary_systems.service_option_mask_high_bits": "bits 31-61 of the Qualcomm service option mask. High bits are shifted down to account for splitting the mask between two proto enums. Options defined at https://github.com/samsara-dev/firmware-mdm9607/blob/master/apps_proc/qmi/services/data_system_determination_v01.h#L154",
					"value.proto_value.cellular_data_system_status.mdm9607.status.rssi_dbm":                                        "Integer value representing the signal strength of the cellular connection in decibel milliwatts",
					"value.proto_value.cellular_data_system_status.mdm9607.status.operator":                                        "Name of operator providing service for the active SIM (i.e. AT&T, Vodafone). Will be empty if the active SIM is an eUICC",
					"value.proto_value.cellular_data_system_status.mdm9607.status.sim_slot":                                        "Physical sim slot in use for currently active SIM",
					"value.proto_value.cellular_data_system_status.mdm9607.status.euicc_profile.profile_name":                      "Name of the active eUICC profile. Only present if the SIM is an eUICC",
					"value.proto_value.cellular_data_system_status.mdm9607.status.euicc_profile.service_provider_name":             "Name of the service provider in the active eUICC profile. Only present if the SIM is an eUICC",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCellularDebug,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "CellularDebug",
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCellularInterfaceState,
			BinaryMessageField: "InterfaceState",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "logs data describing the state of the current cellular interface in use. Typically sent when a new connection event occurs",
				Frequency:   FrequencyCustom("When a VG places a new call, or when the device IP or DNS is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.interface_state.cellular.uplink.up":                           "Whether the network interface is connected and operational",
					"value.proto_value.interface_state.cellular.uplink.mac":                          "String value representing the MAC address of the device's cellular interface",
					"value.proto_value.interface_state.cellular.uplink.ip":                           "String value representing the IP address of the device's cellular interface",
					"value.proto_value.interface_state.cellular.uplink.router":                       "String value representing the router address of the device's cellular interface",
					"value.proto_value.interface_state.cellular.uplink.dns1":                         "String value representing the primary domain name server of the device's cellular interface",
					"value.proto_value.interface_state.cellular.uplink.dns2":                         "String value representing the secondary domain name server of the device's cellular interface",
					"value.proto_value.interface_state.cellular.imei":                                "International Mobile Equipment Identity, numeric identifier unique to the device",
					"value.proto_value.interface_state.cellular.rssi_dbm":                            "Integer value representing the signal strength of the cellular connection in decibel milliwatts",
					"value.proto_value.interface_state.cellular.operator_s":                          "Name of operator providing service for the active SIM (i.e. AT&T, Vodafone). Will be empty if the active SIM is an eUICC",
					"value.proto_value.interface_state.cellular.iccid":                               "ICCID value for the active SIM. Will be empty if the active SIM is an eUICC",
					"value.proto_value.interface_state.cellular.sim_slot":                            "Physical sim slot in use for currently active SIM",
					"value.proto_value.interface_state.cellular.apn_used":                            "Access Point Name used to connect this device to the network",
					"value.proto_value.interface_state.cellular.euicc_profile.profile_name":          "Name of the active eUICC profile. Only present if the SIM is an eUICC",
					"value.proto_value.interface_state.cellular.euicc_profile.service_provider_name": "Name of the service provider in the active eUICC profile. Only present if the SIM is an eUICC",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCellularServingSystemInfo,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			BinaryMessageField: "CellularDebug",
			MetadataInfo: &MetadataInfo{
				Description: "logs cellular debug info (cell id, plmn) when the cell tower or plmn changes",
				Frequency:   FrequencyOnChange("when cellid / plmn changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.cellular_debug.serving_system.cell_id":             "Cell Id",
					"value.proto_value.cellular_debug.serving_system.lac":                 "Location Area Code",
					"value.proto_value.cellular_debug.serving_system.mobile_country_code": "Mobile Country Code (https://en.wikipedia.org/wiki/Mobile_country_code)",
					"value.proto_value.cellular_debug.serving_system.mobile_network_code": "Mobile Network Code (https://en.wikipedia.org/wiki/Mobile_country_code)",
					"value.proto_value.cellular_debug.serving_system.name":                "operator name (e.g. AT&T or Verizon)",
					"value.proto_value.cellular_debug.serving_system.tac":                 "Tracking Area Code",
					"value.proto_value.cellular_debug.serving_system.three_digit_mnc":     "Whether the mnc is three digit or not.",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(32),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDCentralDoorLockStatus,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Reports the central lock status of a vehicle, indicating whether the doors are locked or unlocked",
				Frequency:           FrequencyCustom("Polled by OEM integrations (e.g., SmartCar) when lock status changes or on regular intervals"),
				IntValueDescription: "Lock status value: 0 for unknown, 1 for locked, 2 for unlocked",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDChargerStatus,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDChargeUsedMicroAmpsH,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCloudBackupStatus,
			BinaryMessageField: "CloudBackupStatus",
			Kind:               StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Aggregate info about the status of cloud backup uploads.",
				Frequency:   FrequencyCustom("Periodically reported by the cloud backup service on the device."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.cloud_backup_status":                         "A struct detailing info about a device's status of cloud backup uploads.",
					"value.proto_value.cloud_backup_status.enabled":                 "Whether the cloud backup service is enabled for the device.",
					"value.proto_value.cloud_backup_status.failed_attempts":         "The number of failed upload attempts aggregated over duration.",
					"value.proto_value.cloud_backup_status.failed_uploads":          "The number of failed uploads aggregated over duration.",
					"value.proto_value.cloud_backup_status.failed_upload_bytes":     "The aggregated number of bytes in failed upload attempts.",
					"value.proto_value.cloud_backup_status.concurrent_uploads":      "The number of concurrent uploads currently in progress.",
					"value.proto_value.cloud_backup_status.max_concurrent_uploads":  "The maximum number of concurrent uploads allowed.",
					"value.proto_value.cloud_backup_status.retry_limit":             "Stop retries and move on to the next asset once this number of successive failed retry attempts has been reached.",
					"value.proto_value.cloud_backup_status.upload_asset_size_bytes": "Assets are uploaded after reaching this threshold file size in bytes.",
					"value.proto_value.cloud_backup_status.duration_ms":             "The duration over which these stats have been aggregated.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCloudBackupUploadAttemptInfo,
			BinaryMessageField: "CloudbackupUploadAttemptInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Info about an upload attempt for cloud backup.",
				Frequency:   FrequencyCustom("Reported every time a device begins to or attempts to upload media to the cloud."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.cloudbackup_upload_attempt_info":                                  "A struct detailing info about an upload attempt.",
					"value.proto_value.cloudbackup_upload_attempt_info.source":                           "A struct representing the source of the media being uploaded.",
					"value.proto_value.cloudbackup_upload_attempt_info.source.type":                      metadatahelpers.EnumDescription("The type of the source from which media is being uploaded.", cloudbackupproto.Source_SourceType_name),
					"value.proto_value.cloudbackup_upload_attempt_info.source.nvr":                       "A struct representing an NVR media source.",
					"value.proto_value.cloudbackup_upload_attempt_info.source.nvr.camera_device_id":      "The ID of the camera device the media is associated with.",
					"value.proto_value.cloudbackup_upload_attempt_info.source.nvr.stream_id":             "The ID of the camera stream the media is associated with.",
					"value.proto_value.cloudbackup_upload_attempt_info.source.nvr.channel":               metadatahelpers.EnumDescription("The channel the media is associated with.", workforcehubproto.CameraStreamChannel_name),
					"value.proto_value.cloudbackup_upload_attempt_info.request_id":                       "The ID representing the media being uploaded.",
					"value.proto_value.cloudbackup_upload_attempt_info.media_type":                       metadatahelpers.EnumDescription("The type of media being uploaded.", cloudbackupproto.MediaType_name),
					"value.proto_value.cloudbackup_upload_attempt_info.state":                            metadatahelpers.EnumDescription("The state of the media upload.", cloudbackupproto.UploadAttemptInfo_UploadState_name),
					"value.proto_value.cloudbackup_upload_attempt_info.error":                            metadatahelpers.EnumDescription("An enum representing the type of error associated with the upload.", cloudbackupproto.UploadAttemptInfo_ErrorType_name),
					"value.proto_value.cloudbackup_upload_attempt_info.error_description":                "A string representing the error associated with the upload.",
					"value.proto_value.cloudbackup_upload_attempt_info.retry_count":                      "The count of upload attempt retries that have occurred.",
					"value.proto_value.cloudbackup_upload_attempt_info.upload_url":                       "The URL the media is being uploaded to.",
					"value.proto_value.cloudbackup_upload_attempt_info.upload_attempt_start_ms":          "The timestamp for the start of the upload attempt.",
					"value.proto_value.cloudbackup_upload_attempt_info.upload_attempt_duration_ms":       "Time spent attempting upload. This field will be populated even if the upload attempt is a failure.",
					"value.proto_value.cloudbackup_upload_attempt_info.upload_file_size_bytes":           "The size of the file being uploaded in bytes.",
					"value.proto_value.cloudbackup_upload_attempt_info.video_segment_upload":             "Information about the video segment associated with this upload attempt. This will only be populated for MediaType_VIDEO.",
					"value.proto_value.cloudbackup_upload_attempt_info.video_segment_upload.start_ms":    "The timestamp of the start of the video being uploaded.",
					"value.proto_value.cloudbackup_upload_attempt_info.video_segment_upload.duration_ms": "The duration of the start of the video being uploaded.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCm3xAudioAlertInfo,
			BinaryMessageField: "Cm3XAudioAlertInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Info about an audio alert that was played by CMAudioManager.",
				Frequency:   FrequencyCustom("Reported after an audio alert is played."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.cm3x_audio_alert_info.trigger_time_ms":               "Monotonic timestamp when the audio alert was triggered",
					"value.proto_value.cm3x_audio_alert_info.playback_start_ms":             "Monotonic timestamp when the audio alert playback started",
					"value.proto_value.cm3x_audio_alert_info.playback_end_ms":               "Monotonic timestamp when the audio alert playback ended",
					"value.proto_value.cm3x_audio_alert_info.audio_duration_ms":             "Duration of the audio alert in milliseconds",
					"value.proto_value.cm3x_audio_alert_info.interrupted":                   "Whether the audio alert was interrupted",
					"value.proto_value.cm3x_audio_alert_info.event_type":                    "Type of event that triggered the audio alert",
					"value.proto_value.cm3x_audio_alert_info.frame_ms":                      "Monotonic timestamp of the frame that triggered the alert",
					"value.proto_value.cm3x_audio_alert_info.frame_processing_start_ms":     "Monotonic timestamp when frame processing started",
					"value.proto_value.cm3x_audio_alert_info.severity":                      metadatahelpers.EnumDescription("Severity level of the event", hubproto.EventSeverityLevel_name),
					"value.proto_value.cm3x_audio_alert_info.last_gps":                      "GPS data at the time of the alert",
					"value.proto_value.cm3x_audio_alert_info.device_write_start_ms":         "Monotonic timestamp when writing audio data to device started",
					"value.proto_value.cm3x_audio_alert_info.shadow_mode":                   "If true, alert was only logged and not played",
					"value.proto_value.cm3x_audio_alert_info.queued":                        "Whether the alert was queued",
					"value.proto_value.cm3x_audio_alert_info.cloud_trigger_reason":          "Reason for cloud-triggered events",
					"value.proto_value.cm3x_audio_alert_info.task_processing_started_at_ms": "Monotonic timestamp when camera audio manager began processing task",
					"value.proto_value.cm3x_audio_alert_info.request_received_at_ms":        "Monotonic timestamp when request was received by camera audio manager",
					"value.proto_value.cm3x_audio_alert_info.trigger_gateway_id":            "Gateway id of the device that triggered the audio alert. Not filled if the device that played the alert is the same one that triggered it or if the alert was cloud-triggered",
					"value.proto_value.cm3x_audio_alert_info.cloud_trigger_alert_uuid":      "Alert uuid passed through the hub request for a cloud triggered alert",
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDCM3xDDDStats,
			BinaryMessageField:       "Cm3XVisionStats",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDCM3xFCWStats,
			BinaryMessageField:       "Cm3XVisionStats",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(32),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCM3xPmicResetReasons,
			BinaryMessageField: "Cm3XPmicResetReasons",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCM3xPowerStats,
			BinaryMessageField: "Cm3XPowerStats",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "This object stat will upload metrics related to the camera power.",
				Frequency:   FrequencyEveryXSeconds(60),
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(32),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCM3xSystemStats,
			BinaryMessageField: "Cm3XSystemStats",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(32),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCM3xThermalSensors,
			BinaryMessageField: "Cm3XTsens",
			Kind:               StatKindObjectStat,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(32),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDCMAttachedGatewayId,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCoastingTimeMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Amount of time the vehicle was detected to be coasting. Coasting is the amount of time that: the brake is not pressed, speed is non-zero, and engine load is 0. Values derived for both passenger and heavy duty vehicles.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("coasting time", hubproto.ObdValue_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCoastingTimeTorqueBasedIgnoringBrakeMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Amount of time the vehicle was detected to be coasting. Coasting time counts when the following conditions are met: speed is non-zero, and engine load is 0. Values derived for both passenger and heavy duty vehicles.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("coasting time", hubproto.ObdValue_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCoastingTimeTorqueBasedWhileNotOnCruiseControlMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Amount of time the vehicle was detected to be coasting. For coasting to be reported, cruise control disabled, the brake is not pressed, speed is non-zero, and engine load is 0. Values derived for both passenger and heavy duty vehicles.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("coasting time", hubproto.ObdValue_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCoastingTimeWhileNotOnCruiseControlMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Amount of time the vehicle was detected to be coasting. Coasting time counts when the following conditions are met: speed is non-zero, the accelerator pedal is ot pressed, cruise control is not engaged, and engine load is 0. Values derived for both passenger and heavy duty vehicles.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("coasting time", hubproto.ObdValue_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCommandSchedulerStats,
			BinaryMessageField: "CommandSchedulerStats",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Logs when a gateway connects and disconnects from the cloud along with metadata about the gateway, its cellular connection, and its location",
				Frequency:   FrequencyCustom("Emitted when a gateway connects or disconnects from the cloud, but also re-emitted for gateways staying in the same connectivity state so the high watermark can be updated"),
				ColumnDescriptions: map[string]string{
					"object_id":  "DeviceId",
					"value.time": "Time of disconnect or connect event",
					"value.proto_value.command_scheduler_stats.bus_id":                                                     "The Bus ID that this scheduler is attached to (e.g. CAN0, J1708)",
					"value.proto_value.command_scheduler_stats.command_stats.command.data_identifier":                      "The data id of the command",
					"value.proto_value.command_scheduler_stats.command_stats.command.data_identifier_uint64":               "64-bit version of the data_identifier field",
					"value.proto_value.command_scheduler_stats.command_stats.command.protocol":                             "The vehicle standard this command comes from, if applicable",
					"value.proto_value.command_scheduler_stats.command_stats.command.request_id":                           "Requested ECU ID",
					"value.proto_value.command_scheduler_stats.command_stats.command.response_id":                          "ECU ID that responded",
					"value.proto_value.command_scheduler_stats.command_stats.command.vehicle_bus":                          "Vehicle Diagnostic Bus",
					"value.proto_value.command_scheduler_stats.command_stats.derated_stat.latest_derate_offset_ms":         "Duration from when the command last derated in milliseconds",
					"value.proto_value.command_scheduler_stats.command_stats.derated_stat.overall_derate_instances":        "Total number of derates for this command this session",
					"value.proto_value.command_scheduler_stats.command_stats.excluded_from_derating_by_config":             "The command is configured to be excluded from derating",
					"value.proto_value.command_scheduler_stats.command_stats.expiration_stat.expiration_offset_ms":         "Duration from when the command first expired in milliseconds",
					"value.proto_value.command_scheduler_stats.command_stats.is_stopped":                                   "True if scheduler decided to stop requesting command, this is not the same as expiration",
					"value.proto_value.command_scheduler_stats.command_stats.calculated_max_command_no_response_to_expire": "The calculated number of consecutive requests without responses before we can expire the command",
					"value.proto_value.command_scheduler_stats.command_stats.calculated_max_command_no_response_to_derate": "The calculated number of consecutive requests without responses before we can derate the command",
					"value.proto_value.command_scheduler_stats.command_stats.read_period_ms":                               "Read period for the command",
					"value.proto_value.command_scheduler_stats.command_stats.request_response_stat.any_response_count":     "Count of times we received any response from the requested command, does not count two separate ECUs responding to one command twice",
					"value.proto_value.command_scheduler_stats.command_stats.request_response_stat.request_count":          "Count of times scheduler requested the command",
					"value.proto_value.command_scheduler_stats.command_stats.request_response_stat.total_response_count":   "Count of any responses we received from the requested command, will count two separate ECUs responding to one command twice",
					"value.proto_value.command_scheduler_stats.metadata.configured_max_command_no_response_count_ceiling":  "The configured maximum number of consecutive requests without responses before we can expire the command",
					"value.proto_value.command_scheduler_stats.metadata.configured_max_command_no_response_count_floor":    "The configured minimum number of consecutive requests without responses before we can expire the command",
					"value.proto_value.command_scheduler_stats.metadata.configured_window_interval_ms":                     "Duration of time that scheduler window runs before logging results, resetting local state, and starting a new window",
					"value.proto_value.command_scheduler_stats.metadata.command_derate_enabled":                            "True if the scheduler is allowed to derate commands without responses",
					"value.proto_value.command_scheduler_stats.metadata.command_expiration_enabled":                        "True if the scheduler is allowed to expire commands without responses",
					"value.proto_value.command_scheduler_stats.metadata.derated_command_interval_ms":                       "The request interval used by derated commands",
					"value.proto_value.command_scheduler_stats.metadata.enqueue_jitter_enabled":                            "True if the scheduler is adding random jitter to request enqueuing",
					"value.proto_value.command_scheduler_stats.metadata.enqueue_jitter_ms":                                 "The +/- range of random jitter we allow for requests",
					"value.proto_value.command_scheduler_stats.metadata.minimum_jitter_period_multiple":                    "Safeguards jitter values greatly skewing a small request interval",
					"value.proto_value.command_scheduler_stats.session_id":                                                 "Session identification number used for debugging and grouping similar scheduler session stats",
					"value.proto_value.command_scheduler_stats.window_duration_ms":                                         "Window duration in milliseconds for this log",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDConnectedDeviceUpgradeInfo,
			BinaryMessageField: "ConnectedDeviceUpgradeInfo",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "A generic stat to monitor widgets/peripherals DFU process, done by gateways",
				Frequency:   FrequencyCustom("At the end of the DFU process"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.connected_device_upgrade_info.product_id":       "Product ID of the DFUed device",
					"value.proto_value.connected_device_upgrade_info.mac":              "MAC address of the DFUed device",
					"value.proto_value.connected_device_upgrade_info.upgrade_type":     "Type of the firmware image, DFUed to the device",
					"value.proto_value.connected_device_upgrade_info.rssi":             "RSSI of the connection during the DFU process",
					"value.proto_value.connected_device_upgrade_info.new_version":      "Version of the DFUed image",
					"value.proto_value.connected_device_upgrade_info.old_version":      "Previous version",
					"value.proto_value.connected_device_upgrade_info.duration_ms":      "Total duration of the DFU process",
					"value.proto_value.connected_device_upgrade_info.percent_complete": "Percentage of the DFU process completed",
					"value.proto_value.connected_device_upgrade_info.error":            "Legacy error uint32 field, use error_code instead",
					"value.proto_value.connected_device_upgrade_info.info":             "Ad hoc message",
					"value.proto_value.connected_device_upgrade_info.error_code":       "Error code if any",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDConnectedMediaInputs,
			BinaryMessageField: "ConnectedMediaInputs",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Reports information on the media inputs connected to a camera device",
				Frequency:           FrequencyOnChange("On service start and when the set of connected media inputs changes"),
				IntValueDescription: "The number of possible media inputs",
				ColumnDescriptions: map[string]string{
					"value.proto_value.connected_media_inputs.primary.video_capability.resolution":   metadatahelpers.EnumDescription("Resolution of the primary media input video input", hubproto.VideoResolutionEnum_name),
					"value.proto_value.connected_media_inputs.primary.video_capability.framerate":    "The framerate of the primary media input video input",
					"value.proto_value.connected_media_inputs.primary.audio_capability.samplerate":   "The sample rate of the primary media input audio input",
					"value.proto_value.connected_media_inputs.secondary.video_capability.resolution": metadatahelpers.EnumDescription("Resolution of the secondary media input video input", hubproto.VideoResolutionEnum_name),
					"value.proto_value.connected_media_inputs.secondary.video_capability.framerate":  "The framerate of the secondary media input video input",
					"value.proto_value.connected_media_inputs.secondary.audio_capability.samplerate": "The sample rate of the secondary media input audio input",
					"value.proto_value.connected_media_inputs.analog_1.video_capability.resolution":  metadatahelpers.EnumDescription("Resolution of the analog1 media input video input", hubproto.VideoResolutionEnum_name),
					"value.proto_value.connected_media_inputs.analog_1.video_capability.framerate":   "The framerate of the analog1 media input video input",
					"value.proto_value.connected_media_inputs.analog_1.audio_capability.samplerate":  "The sample rate of the analog1 media input audio input",
					"value.proto_value.connected_media_inputs.analog_2.video_capability.resolution":  metadatahelpers.EnumDescription("Resolution of the analog2 media input video input", hubproto.VideoResolutionEnum_name),
					"value.proto_value.connected_media_inputs.analog_2.video_capability.framerate":   "The framerate of the analog2 media input video input",
					"value.proto_value.connected_media_inputs.analog_2.audio_capability.samplerate":  "The sample rate of the analog2 media input audio input",
					"value.proto_value.connected_media_inputs.analog_3.video_capability.resolution":  metadatahelpers.EnumDescription("Resolution of the analog3 media input video input", hubproto.VideoResolutionEnum_name),
					"value.proto_value.connected_media_inputs.analog_3.video_capability.framerate":   "The framerate of the analog3 media input video input",
					"value.proto_value.connected_media_inputs.analog_3.audio_capability.samplerate":  "The sample rate of the analog3 media input audio input",
					"value.proto_value.connected_media_inputs.analog_4.video_capability.resolution":  metadatahelpers.EnumDescription("Resolution of the analog4 media input video input", hubproto.VideoResolutionEnum_name),
					"value.proto_value.connected_media_inputs.analog_4.video_capability.framerate":   "The framerate of the analog4 media input video input",
					"value.proto_value.connected_media_inputs.analog_4.audio_capability.samplerate":  "The sample rate of the analog4 media input audio input",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDConnectivityEvent,
			BinaryMessageField: "GatewayConnectivityEvent",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Logs when a gateway connects and disconnects from the cloud along with metadata about the gateway, its cellular connection, and its location",
				Frequency:   FrequencyCustom("Emitted when a gateway connects or disconnects from the cloud, but also re-emitted for gateways staying in the same connectivity state so the high watermark can be updated"),
				ColumnDescriptions: map[string]string{
					"object_id":  "DeviceId",
					"value.time": "Time of disconnect or connect event",
					"value.proto_value.gateway_connectivity_event.cellular_operator":           "Cellular operator the device was connected at the time of the event",
					"value.proto_value.gateway_connectivity_event.country":                     "Country the device was in at the time of the event",
					"value.proto_value.gateway_connectivity_event.euicc_profile_name":          "Name of the active eUICC profile. Only populated if the SIM is an eUICC",
					"value.proto_value.gateway_connectivity_event.euicc_service_provider_name": "Name of the service provider in the active eUICC profile. Only populated if the SIM is an eUICC",
					"value.proto_value.gateway_connectivity_event.gateway_id":                  "GatewayId of the device",
					"value.proto_value.gateway_connectivity_event.iccid":                       "Iccid of the device at the time of the event",
					"value.proto_value.gateway_connectivity_event.is_connected":                "True if this event represents the device connecting, false if it represents the device disconnecting",
					"value.proto_value.gateway_connectivity_event.last_updated_at_ms":          "The last unix timestamp at which this object stat was updated, and periodically updated if this remains the last event so it can be used as a high watermark for up to what time we've evaluated connectivity for this device",
					"value.proto_value.gateway_connectivity_event.latitude":                    "Latitude of the device at the time of the event",
					"value.proto_value.gateway_connectivity_event.longitude":                   "Longitude of the device at the time of the event",
					"value.proto_value.gateway_connectivity_event.org_id":                      "OrgId of the device",
					"value.proto_value.gateway_connectivity_event.product_id":                  "ProductId of the device",
					"value.proto_value.gateway_connectivity_event.sim_slot":                    metadatahelpers.EnumDescription("The active sim slot the device was using to connect to a cellular operator at the time of the event", hubproto.SimSlot_name),
					"value.proto_value.gateway_connectivity_event.state_province":              "State or province the device was in at the time of the event",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(32),
						PartitionChunkSize: pointer.IntPtr(100),
					},
				},
				// We enabled serverless for this stat in the past, but the job kept
				// timing out. We want to be able to adjust configurations to prevent
				// timeouts, so we're disabling serverless for now.
				DisableServerless: true,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDConnectivityRecovery,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			BinaryMessageField: "ConnectivityRecovery",
			MetadataInfo: &MetadataInfo{
				Description: "Logs details about device connectivity recovery after being disconnected from the hubserver",
				Frequency:   FrequencyCustom("Reported when a device reconnects to hubserver after becoming disconnected from the hubserver"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.connectivity_recovery.state_on_connect.time_unix_ms":             "Absolute timestamp when connectivity was established between the device and the hubserver",
					"value.proto_value.connectivity_recovery.state_on_connect.boot_count":               "Device boot count when connectivity was established between the device and the hubserver",
					"value.proto_value.connectivity_recovery.state_on_connect.sim_switching_enabled":    "Whether SIM switching was enabled connectivity was established between the device and the hubserver",
					"value.proto_value.connectivity_recovery.state_on_connect.active_sim_slot":          "Active SIM slot when connectivity was established between the device and the hubserver",
					"value.proto_value.connectivity_recovery.state_on_connect.interface":                metadatahelpers.EnumDescription("Connected interface type connectivity was established between the device and the hubserver", hubproto.ConnectivityRecovery_SystemState_NetworkInterface_name),
					"value.proto_value.connectivity_recovery.state_on_disconnect.time_unix_ms":          "Absolute timestamp when the device disconnected from the hubserver",
					"value.proto_value.connectivity_recovery.state_on_disconnect.boot_count":            "Device boot count when it disconnected from the hubserver",
					"value.proto_value.connectivity_recovery.state_on_disconnect.sim_switching_enabled": "Whether SIM switching was enabled when the device first disconnected from the hubserver",
					"value.proto_value.connectivity_recovery.state_on_disconnect.active_sim_slot":       "Active SIM slot when the device first disconnected from the hubserver",
					"value.proto_value.connectivity_recovery.state_on_disconnect.interface":             metadatahelpers.EnumDescription("Connected interface type just prior to the device disconnecting from the hubserver", hubproto.ConnectivityRecovery_SystemState_NetworkInterface_name),
					"value.proto_value.connectivity_recovery.state_on_reconnect.time_unix_ms":           "Absolute timestamp when the device reconnected to the hubserver",
					"value.proto_value.connectivity_recovery.state_on_reconnect.boot_count":             "Device boot count when it reconnected to the hubserver",
					"value.proto_value.connectivity_recovery.state_on_reconnect.sim_switching_enabled":  "Whether SIM switching was enabled when the device reconnected to the hubserver",
					"value.proto_value.connectivity_recovery.state_on_reconnect.active_sim_slot":        "Active SIM slot when the device reconnected to the hubserver",
					"value.proto_value.connectivity_recovery.state_on_reconnect.interface":              metadatahelpers.EnumDescription("Connected interface type when the device reconnected to the hubserver", hubproto.ConnectivityRecovery_SystemState_NetworkInterface_name),
					"value.proto_value.connectivity_recovery.num_data_call_restarts_attempted":          "Number of cellular call restarts attempted over the duration of the connectivity downtime",
					"value.proto_value.connectivity_recovery.num_modem_resets_attempted":                "Number of cellular modem resets attempted over the duration of the connectivity downtime",
					"value.proto_value.connectivity_recovery.num_sim_switches_attempted":                "Number of SIM slot switches attempted over the duration of the connectivity downtime",
					"value.proto_value.connectivity_recovery.num_reboots_attempted":                     "Number of reboots attempted over the duration of the connectivity downtime",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDCPULoadAvgLast1Min,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:            "Average CPU load over the last 1 minute",
				Frequency:              FrequencyOnChange("any change in CPU load over the last minute was above .3"),
				DoubleValueDescription: "CPU load over the last 1 minute. Reported values are from linux /proc/loadavg, using the 1 minute load average.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCriticallyLowLevel,
			BinaryMessageField: "CriticallyLowLevel",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Interval stat tracking when a level monitor is critically low",
				Frequency:   FrequencyCustom("When the level has been low for 48 straight hours or when the level returns to normal from being critically low"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.critically_low_level.is_critically_low": "True if the level is critically low",
					"value.proto_value.critically_low_level.start_ms":          "Timestamp in milliseconds when the interval starts",
					"value.proto_value.critically_low_level.end_ms":            "Timestamp in milliseconds when the interval ends",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDCruiseControlFinalSetSpeedKph,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Final speed set for the Cruise Control System, including driver set speed and any other systems such as the Adaptive Cruise Control",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "Set speed in km/h",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCruiseControlMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle duration of cruise control being enabled (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Amount of time the vehicle had a non-zero speed and had cruise control enabled. Reported mainly by heavy duty vehicles",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("cruise control time", hubproto.ObdValue_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDCruiseControlSwitchState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "State of the cruise control switch",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every 100 ms."),
				IntValueDescription: "0 = off, 1 = on, 2 = error",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCruxDebug,
			BinaryMessageField: "CruxDebug",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Debug data sent from a crux peripheral via the crux protocol. Note that the object ID will be the device ID of the Crux peripheral.",
				Frequency:   FrequencyCustom("Any time the underlying data changes for any of the fields. These are low res, so several times an hour."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.crux_debug.protocol_version":                                     "The network protocol version used to encode the data within the advertisement packet",
					"value.proto_value.crux_debug.flags":                                                "The bitwise flags present in the advertisement packet",
					"value.proto_value.crux_debug.time_since_connection":                                "The duration since the crux peripheral was last connected to by a crux central",
					"value.proto_value.crux_debug.tx_power_dbm":                                         "The transmission power (in dBm) of the crux peripheral",
					"value.proto_value.crux_debug.fw_version":                                           "The current firmware version of the crux peripheral",
					"value.proto_value.crux_debug.battery_level_mv":                                     "The battery voltage (in mV) of the crux peripheral battery",
					"value.proto_value.crux_debug.battery_level_counts":                                 "The number of battery level counts",
					"value.proto_value.crux_debug.temperature_c":                                        "The temperature (in Celsius) measured by the crux peripheral",
					"value.proto_value.crux_debug.temperature_counts":                                   "The number of temperature counts",
					"value.proto_value.crux_debug.error":                                                "The code of the last error encountered by the crux peripheral",
					"value.proto_value.crux_debug.reset_reason":                                         "The reason for the most recent reset of the crux peripheral",
					"value.proto_value.crux_debug.num_reboots":                                          "The number of reboots",
					"value.proto_value.crux_debug.mfg_specific_data":                                    "The raw advertisement packet content",
					"value.proto_value.crux_debug.observation_series":                                   "A batch of observation data for the crux peripheral",
					"value.proto_value.crux_debug.observation_series.incremental_observed_at_offset_ds": "Array with incremental deciseconds deltas after the log's happenedAtMs that the peripheral was observed",
					"value.proto_value.crux_debug.observation_series.incremental_rssi_dbm":              "Array of deltas of received signal strength of the peripheral as seen by the central, in dBm",
					"value.proto_value.crux_debug.observation_series.incremental_tx_power_dbm":          "Array of deltas of transmit power of peripheral, in dBm (note that 0 is a valid value)",
					"value.proto_value.crux_debug.security_data":                                        "Data used to verify the authenticity of the stat",
					"value.proto_value.crux_debug.security_data.counter":                                "Number of steps of rolling authentication that have passed",
					"value.proto_value.crux_debug.security_data.signature":                              "Generated by the Crux signing key from the counter, nonce, and other fields",
					"value.proto_value.crux_debug.security_data.nonce_bytes":                            "A random number used for this interval of authentication",
					"value.proto_value.crux_debug.central_id":                                           "The device ID of the central gateway that made the observation",
					"value.proto_value.crux_debug.temperature_invalid":                                  "True if the temperature is invalid. This can happen if the data is not available in the advertisement or the BLE address.",
					"value.proto_value.crux_debug.battery_level_invalid":                                "True if the battery level is invalid. This can happen if the data is not available in the advertisement or the BLE address.",
					"value.proto_value.crux_debug.reset_reason_invalid":                                 "True if the reset reason is invalid. This can happen if the data is not available in the advertisement or the BLE address.",
					"value.proto_value.crux_debug.num_reboots_invalid":                                  "True if the number of reboots is invalid. This can happen if the data is not available in the advertisement or the BLE address.",
					"value.proto_value.crux_debug.error_invalid":                                        "True if the error is invalid. This can happen if the data is not available in the advertisement or the BLE address.",
					"value.proto_value.crux_debug.fw_version_invalid":                                   "True if the firmware version is invalid. This can happen if the data is not available in the advertisement or the BLE address.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCruxPeripheralObservationBatch,
			BinaryMessageField: "PeripheralObservationBatch",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "A batch of peripheral device detections by a central gateway via the Crux protocol. This is only a subset of available data required for peripheral observation processing. This stat is attached to the central device making the observation, not the peripheral devices being observed.",
				Frequency:   FrequencyCustom("Logged for a single scanning window by a Crux central gateway, max 1 minute per central gateway."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.peripheral_observation_batch.peripheral_observations":                                                      "A list of peripherals observed by the central gateway",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.org_id":                                               "The org ID of the observed peripheral",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.hardware_id":                                          "The hardware ID of the observed peripheral",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.product_id":                                           "The product ID of the observed peripheral",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.observation_series":                                   "A batch of observation data for the observed peripheral",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.observation_series.incremental_observed_at_offset_ds": "Array with incremental deciseconds deltas after the log's happenedAtMs that the peripheral was observed",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.observation_series.incremental_rssi_dbm":              "Array of deltas of received signal strength of the peripheral as seen by the central, in dBm",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.observation_series.incremental_tx_power_dbm":          "Array of deltas of transmit power of peripheral, in dBm (note that 0 is a valid value)",
					"value.proto_value.peripheral_observation_batch.peripheral_observations.protocol_version":                                     "The network protocol version used to encode the data in the peripheral's advertisement packet",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCruxProxyTestModeData,
			BinaryMessageField: "CruxProxyTestModeData",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Data uploaded by a Crux Central by proxy for the Test Mode UUID Crux Peripheral",
				Frequency:   FrequencyCustom("Logged when compatible Crux advertisers are scanned by a gateway, max 1 minute per advertiser"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.crux_proxy_test_mode_data.rssi_dbm":                  "Received signal strength of advertiser",
					"value.proto_value.crux_proxy_test_mode_data.mac_observed":              "BLE_ADDR of advertiser converted to uint64 (aka gateway ID)",
					"value.proto_value.crux_proxy_test_mode_data.protocol_version":          "zero means invalid, non-zero corresponds to protocol version",
					"value.proto_value.crux_proxy_test_mode_data.adv_packet_verbatim":       "Verbatim advertisement packet received",
					"value.proto_value.crux_proxy_test_mode_data.adv_interval_ms":           "advertisement interval in milliseconds",
					"value.proto_value.crux_proxy_test_mode_data.uuid":                      metadatahelpers.EnumDescription("BLE Service UUID", bleproxyproto.ServiceUuid_name),
					"value.proto_value.crux_proxy_test_mode_data.product_id":                metadatahelpers.EnumDescription("Compressed Product ID", bleproxyproto.CompressedProductId_name),
					"value.proto_value.crux_proxy_test_mode_data.reset_reason":              metadatahelpers.EnumDescription("Most recent peripheral reset reason", bleproxyproto.PeripheralResetReason_name),
					"value.proto_value.crux_proxy_test_mode_data.flags":                     "bitwise flags for test mode",
					"value.proto_value.crux_proxy_test_mode_data.temperature_mc":            "temperature of peripheral in millicelcius",
					"value.proto_value.crux_proxy_test_mode_data.battery_mv":                "battery voltage in millivolts",
					"value.proto_value.crux_proxy_test_mode_data.fw_version":                "FW version",
					"value.proto_value.crux_proxy_test_mode_data.error_code":                "most recent error code",
					"value.proto_value.crux_proxy_test_mode_data.boot_count":                "number of boots for this peripheral",
					"value.proto_value.crux_proxy_test_mode_data.self_test_result":          "Bitwise flags to indicate self test results",
					"value.proto_value.crux_proxy_test_mode_data.time_since_reset":          "Time since last reset (no units, table value)",
					"value.proto_value.crux_proxy_test_mode_data.time_since_power_on_reset": "Time since power on reset (no units, table value)",
					"value.proto_value.crux_proxy_test_mode_data.mac_address_in_adv_packet": "mac address that might be duplicated in adv packet for iOS support (AKA gateway ID)",
					"value.proto_value.crux_proxy_test_mode_data.tx_power_dbm":              "TX power of the peripheral's advertisement, in dBm",
				},
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDCumulativeIdlingDurationMs,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FuelTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Created for storing cumulative idling duration in milliseconds by processing engine idle events",
				IntValueDescription: "Cumulative idling duration in milliseconds",
				Frequency:           FrequencyOnChange("These stats are generated through processing of engine idle events."),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDCurrentMapTile,
			BinaryMessageField: "CurrentTileInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Current Tile Info",
				Frequency:   FrequencyCustom("Whenever a new tile is loaded."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.current_tile_info.slippy_tile":                          "Slippy tile key in the form {zoom}-{x}-{y}.",
					"value.proto_value.current_tile_info.version":                              "Tile version.",
					"value.proto_value.current_tile_info.server_last_modified":                 "Last server-side modification to tile.",
					"value.proto_value.current_tile_info.tiles_cache_key":                      "Tile cache validation key.",
					"value.proto_value.current_tile_info.overrides_cache_key":                  "Tile override cache validation key.",
					"value.proto_value.current_tile_info.overrides_server_last_modified":       "Tile override server last modified time. Empty if override does not exist.",
					"value.proto_value.current_tile_info.did_bridge_location_lookup":           "True if an attempt to load bridge data was made.",
					"value.proto_value.current_tile_info.bridge_location_version":              "Bridge location data version.",
					"value.proto_value.current_tile_info.bridge_location_cache_key":            "Bridge location data cache key",
					"value.proto_value.current_tile_info.bridge_location_server_last_modified": "Bridge location data server last modified time. Empty if bridge location data does not exist.",
					/**
					TODO: Re-introduce these column descriptions after un-excluding the layers field. This can be done after SAFW-2039 is deployed.

					"value.proto_value.current_tile_info.layers":                               "Repeated field of layer info. ",
					"value.proto_value.current_tile_info.layers.layer_name":                    "Layer name",
					"value.proto_value.current_tile_info.layers.file_path":                     "Location of layer in the device's cache.",
					"value.proto_value.current_tile_info.layers.file_on_disk_updated":          "true if the layer's file has changed during the most recent load, false otherwise.",
					"value.proto_value.current_tile_info.layers.file_exists":                   "true if the file for this layer exists.",
					"value.proto_value.current_tile_info.layers.version":                       "Layer version.",
					"value.proto_value.current_tile_info.layers.cache_key":                     "Layer cache validation key.",
					"value.proto_value.current_tile_info.layers.server_last_modified_unix_ms":  "Layer file last modified time. Empty if layer file does not exist.",
					"value.proto_value.current_tile_info.layers.server_etag":                   "Layer ETag value, provided by the server. This is an md5 hash of the layer's file.",
					"value.proto_value.current_tile_info.layers.file_size_bytes":               "Size of the layer's file.",
					*/
				},
			},
			ksFieldsToExclude: []string{
				// Exclude layers because of a bug in LayeredTileManager causing empty layers to have garbage data in the server_last_modified field, preventing replication.
				"value.proto_value.current_tile_info.layers",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDCustomObdStart,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "The first of 2048 object stats that are reserved for custom OBD object stats",
				Frequency:           FrequencyCustom("Depends on the min_log_period_ms, max_log_period_ms and int_threshold values in the custom_loggers section of the OBD config"),
				IntValueDescription: "The int value specified by the custom configuration",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDailyUtilization,
			BinaryMessageField: "DailyUtilization",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Asset daily utilization data. The utilization percentage is calculated as: (utilization_total_ms / available_hours_ms) * 100",
				Frequency:   FrequencyCustom("Reported by asset utilization poller every x hours"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.daily_utilization.use_case_id":   "Identifier for the utilization use case (contains utiliztion definition).",
					"value.proto_value.daily_utilization.utilized_ms":   "Daily utilized time in milliseconds.",
					"value.proto_value.daily_utilization.available_ms":  "Daily available time for the asset in milliseconds.",
					"value.proto_value.daily_utilization.date":          "Date in ISO 8601 format (YYYY-MM-DD) in org timezone.",
					"value.proto_value.daily_utilization.last_event_ms": "Timestamp of the last processed utilization event in milliseconds.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDashcamConnected,
			BinaryMessageField: "DashcamConnectionState",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates whether or not VG is connected to a camera via gRPC. Includes metadata about the camera that is connected.",
				Frequency:           FrequencyCustom("Logged by VG when its gRPC connection to a camera is established/broken"),
				IntValueDescription: "Binary value, either 0 for a disconnect or 1 for a connect. Note that this is generated on the VG, and the VG communicates with the CM over GRPC to get the relevant connection state.",
				ColumnDescriptions: map[string]string{
					"object_id": "VG device id.",
					"value.proto_value.dashcam_connection_state.camera_serial":       "Camera serial may be uppercase or lowercase, and may or may not have hyphens. This field should be normalized prior to using it.",
					"value.proto_value.dashcam_connection_state.camera_product_type": metadatahelpers.EnumDescription("Camera model connected", hubproto.DashcamConnectionState_CameraType_name),
					"value.proto_value.dashcam_connection_state.camera_id":           "Camera device id",
					"value.proto_value.dashcam_connection_state.connected_state":     "True if int_value is 1, and false otherwise.",
				},
			},
			Production: true,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDashcamDriverAlbum,
			BinaryMessageField: "DashcamDriverAlbum",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDashcamDriverAlbumShadow,
			BinaryMessageField: "DashcamDriverAlbum",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Replicates the osDDashcamDriverAlbum stat type to report detections made by experimental firmware models. These events are meant for data collection and are hidden from customers.",
				Frequency:   FrequencyOnChange("Uploads when a driver album is detected by experimental models."),
				ColumnDescriptions: map[string]string{
					"object_id":                              "Emitted by CM deviceId for CM3Xs.",
					"time":                                   "Unix timestamp in ms when the device starts processing an asset for uploading.",
					"value.proto_value.dashcam_driver_album": "An array of the driver's face bounding box information.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDashcamDriverObstruction,
			BinaryMessageField: "DashcamDriverObstructionData",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "This object stat will upload state that determines whether inward facing camera is obstructed. This stat is uploaded at the start of every trip and is assumed to persist until the next differing stat is uploaded.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDashcamLedState,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "DashcamLedState",
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Dashcam Led State",
				Frequency:   FrequencyCustom("Determined by when LED changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.dashcam_led_state.enabled":   "Whether LED is on/off",
					"value.proto_value.dashcam_led_state.rgb_color": "Brightness of red, green and blue LEDs",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDashcamReport,
			BinaryMessageField: "DashcamReport",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			MetadataInfo: &MetadataInfo{
				Description: "Emitted each time a device intends to upload an asset (i.e. trip still, harsh event, retrieval). Multiple dashcam reports for the same eventId may be emitted if the device reboots and sees the request again for the first time.",
				Frequency:   FrequencyOnChange("uploader_config pulled from queue and parsed by the camera manager"),
				ColumnDescriptions: map[string]string{
					"object_id": "Emitted by CM deviceId for CM3Xs, and VG deviceId for non-CM3Xs.",
					"time":      "Unix timestamp in ms when the device starts processing an asset for uploading.",
					"value.proto_value.dashcam_report.event_id":                        "Corresponds to event_id in cmassets.dashcam_assets table. Also corresponds to the historical_video_request.id for retrievals.",
					"value.proto_value.dashcam_report.trigger_reason":                  metadatahelpers.EnumDescription("Trigger reason for the asset upload.", hubproto.DashcamReport_TriggerReason_name),
					"value.proto_value.dashcam_report.report_type":                     metadatahelpers.EnumDescription("The type of asset uploaded.", hubproto.DashcamReport_ReportType_name),
					"value.proto_value.dashcam_report.camera_type":                     metadatahelpers.EnumDescription("Camera type that recorded the asset.", hubproto.DashcamReport_CameraType_name),
					"value.proto_value.dashcam_report.gateway_id":                      "Gateway ID of the device that uploaded the asset. CM gateway ID for CM3Xs, VG gateway ID for non-Cm3Xs.",
					"value.proto_value.dashcam_report.multicam_config.request_cameras": "If a multicam asset is being uploaded, this config contains information about which stream/camera IDs are being uploaded.",
					"value.proto_value.dashcam_report.streams":                         metadatahelpers.EnumDescription("The streams requested for upload. These may not correspond to the actual streams that are uploaded (i.e. if the stream doesn't exist, we might try to upload a low-res stream, or nothing at all).", hubproto.CameraStreamSourceEnum_name),
					"value.proto_value.dashcam_report.wifi_required":                   "Whether the device must be connected to wifi while it uploads the asset.",
				},
			},
			Tags: []amundsentags.Tag{amundsentags.SafetyTag},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDashcamReportAssetCreated,
			BinaryMessageField: "DashcamReport",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Stat is emitted each time the CM3X camera manager finishes creating an asset, and the asset is ready to be uploaded.",
				Frequency:   FrequencyOnChange("camera manager done creating the asset"),
				ColumnDescriptions: map[string]string{
					"time":      "Unix timestamp in ms when the VG checked the camera connection status.",
					"object_id": "CM deviceId. Only emitted by CM3Xs as of devices on firmware >=CM19.",
					"value.proto_value.dashcam_report.event_id":                        "Corresponds to event_id in cmassets.dashcam_assets table. Also corresponds to the historical_video_request.id for retrievals.",
					"value.proto_value.dashcam_report.trigger_reason":                  metadatahelpers.EnumDescription("Trigger reason for the asset upload.", hubproto.DashcamReport_TriggerReason_name),
					"value.proto_value.dashcam_report.report_type":                     metadatahelpers.EnumDescription("The type of asset uploaded.", hubproto.DashcamReport_ReportType_name),
					"value.proto_value.dashcam_report.camera_type":                     metadatahelpers.EnumDescription("Camera type that recorded the asset.", hubproto.DashcamReport_CameraType_name),
					"value.proto_value.dashcam_report.gateway_id":                      "Gateway ID of the device that uploaded the asset. CM gateway ID for CM3Xs, VG gateway ID for non-Cm3Xs.",
					"value.proto_value.dashcam_report.multicam_config.request_cameras": "If a multicam asset is being uploaded, this config contains information about which stream/camera IDs are being uploaded.",
					"value.proto_value.dashcam_report.streams":                         metadatahelpers.EnumDescription("The streams requested for upload. These may not correspond to the actual streams that are uploaded (i.e. if the stream doesn't exist, we might try to upload a low-res stream, or nothing at all).", hubproto.CameraStreamSourceEnum_name),
					"value.proto_value.dashcam_report.wifi_required":                   "Whether the device must be connected to wifi while it uploads the asset.",
				},
			},
			Tags: []amundsentags.Tag{amundsentags.SafetyTag},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDDashcamSeatbelt,
			BinaryMessageField:       "DashcamSeatbeltData",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDashcamState,
			BinaryMessageField: "DashcamState",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reports whether the CM/Octo is recording and the reasons for recording",
				Frequency:           FrequencyCustom("CM2X logs on state change, CM3X/Octo logs on state change and heartbeat (every minute)"),
				IntValueDescription: metadatahelpers.EnumDescription("The current dashcam recording state. This is uploaded from either the VG34 (if CM2X is used), or the CM3X/Octo.", hubproto.CameraState_State_name),
				ColumnDescriptions: map[string]string{
					"object_id": "CM deviceId for CM3X, VG deviceId for non-CM3X.",
					"value.proto_value.dashcam_state.camera_state":                        metadatahelpers.EnumDescription("The current dashcam recording state.", hubproto.CameraState_State_name),
					"value.proto_value.dashcam_state.recording_reason":                    metadatahelpers.EnumDescription("The reasons dashcam is recording.", hubproto.CameraState_RecordingReason_name),
					"value.proto_value.dashcam_state.recording_status.primary.high_res":   metadatahelpers.EnumDescription("The recording status for the primary high resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.primary.low_res":    metadatahelpers.EnumDescription("The recording status for the primary low resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.primary.audio":      metadatahelpers.EnumDescription("The recording status for the primary audio stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.secondary.high_res": metadatahelpers.EnumDescription("The recording status for the secondary high resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.secondary.low_res":  metadatahelpers.EnumDescription("The recording status for the secondary low resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.secondary.audio":    metadatahelpers.EnumDescription("The recording status for the secondary audio stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_1.high_res":  metadatahelpers.EnumDescription("The recording status for the analog 1 high resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_1.low_res":   metadatahelpers.EnumDescription("The recording status for the analog 1 low resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_1.audio":     metadatahelpers.EnumDescription("The recording status for the analog 1 audio stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_2.high_res":  metadatahelpers.EnumDescription("The recording status for the analog 2 high resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_2.low_res":   metadatahelpers.EnumDescription("The recording status for the analog 2 low resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_2.audio":     metadatahelpers.EnumDescription("The recording status for the analog 2 audio stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_3.high_res":  metadatahelpers.EnumDescription("The recording status for the analog 3 high resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_3.low_res":   metadatahelpers.EnumDescription("The recording status for the analog 3 low resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_3.audio":     metadatahelpers.EnumDescription("The recording status for the analog 3 audio stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_4.high_res":  metadatahelpers.EnumDescription("The recording status for the analog 4 high resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_4.low_res":   metadatahelpers.EnumDescription("The recording status for the analog 4 low resolution video stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
					"value.proto_value.dashcam_state.recording_status.analog_4.audio":     metadatahelpers.EnumDescription("The recording status for the analog 4 audio stream.", hubproto.CameraRecordingStatus_StreamRecordingStatus_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride:   pointer.IntPtr(32),
						EnableUcKinesisStats: true,
						PartitionChunkSize:   pointer.IntPtr(50),
					},
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDDashcamStreamStatus,
			BinaryMessageField:       "DashcamStreamStatus",
			Kind:                     StatKindObjectStat,
			DataModelStat:            true,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			Tags:                     []amundsentags.Tag{amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "Reports details about camera recording",
				Frequency:   FrequencyCustom("Reported once a minute while recording."),
				ColumnDescriptions: map[string]string{
					"object_id": "CM deviceId for CM3X, VG deviceId for CM2X.",
					"value.proto_value.dashcam_stream_status.last_timestamp_deleted_ms":                            "The earliest unix timestamp where *high-resolution* footage is available on the device.",
					"value.proto_value.dashcam_stream_status.last_low_res_timestamp_deleted_ms":                    "The earliest unix timestamp where *low-resolution* footage is available on the device.",
					"value.proto_value.dashcam_stream_status.stream_status.stream_source_enum":                     metadatahelpers.EnumDescription("The stream source for the respective entry in the stream status array.", hubproto.CameraStreamSourceEnum_name),
					"value.proto_value.dashcam_stream_status.stream_status.stream_video_info.bitrate":              "The bitrate (bps) of the raw recorded stream.",
					"value.proto_value.dashcam_stream_status.stream_status.stream_video_info.framerate":            "The framerate (fps) of the raw recorded stream.",
					"value.proto_value.dashcam_stream_status.stream_status.stream_video_info.codec":                metadatahelpers.EnumDescription("The codec for the raw recorded stream.", hubproto.VideoInfo_Codec_name),
					"value.proto_value.dashcam_stream_status.stream_status.stream_video_info.resolution":           metadatahelpers.EnumDescription("Resolution of the raw recorded stream.", hubproto.VideoResolutionEnum_name),
					"value.proto_value.dashcam_stream_status.stream_status.stream_video_info.idr_interval_seconds": metadatahelpers.EnumDescription("Specifies the keyframe rate in seconds between each i-frame in the recorded stream.", hubproto.VideoInfo_IdrIntervalSeconds_name),
					"value.proto_value.dashcam_stream_status.stream_status.stream_video_info.bitrate_control":      metadatahelpers.EnumDescription("Bitrate control dictates how the encoder allocates the encoded audio and video data within the file.", hubproto.BitrateControlType_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDashcamTargetState,
			BinaryMessageField: "DashcamTargetState",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reports whether the CM/Octo should be recording and the reason for recording",
				Frequency:           FrequencyCustom("Camera logs on state change and heartbeat (every minute)"),
				IntValueDescription: metadatahelpers.EnumDescription("The current target for the dashcam recording state. This is uploaded from the CM3X/Octo", hubproto.CameraTargetState_State_name),
				ColumnDescriptions: map[string]string{
					"object_id": "DeviceId for CM3X/Octo.",
					"value.proto_value.dashcam_target_state.camera_target_state": metadatahelpers.EnumDescription("The current state of dashcam recording", hubproto.CameraTargetState_State_name),
					"value.proto_value.dashcam_target_state.recording_reason":    metadatahelpers.EnumDescription("The reasons we are recording", hubproto.CameraState_RecordingReason_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride:   pointer.IntPtr(32),
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDeadReckoningDebug,
			BinaryMessageField: "DeadReckoningDebug",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDeepstreamPipelineFailure,
			BinaryMessageField: "DeepstreamPipelineFailure",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Deepstream Pipeline frame flow stats",
				Frequency:   FrequencyCustom("Once per pipeline failure"),
				ColumnDescriptions: map[string]string{
					"value.time": "The time in Ms the failure occured.",
					"value.proto_value.deepstream_pipeline_failure":                     "Struct describing a specific pipeline failure.",
					"value.proto_value.deepstream_pipeline_failure.failed_pipeline":     metadatahelpers.EnumDescription("The pipeline that failed.", workforcehubproto.DeepstreamPipelineFailure_Pipeline_name),
					"value.proto_value.deepstream_pipeline_failure.camera_device_id":    "The ID of the camera device for the pipeline failure.",
					"value.proto_value.deepstream_pipeline_failure.stream_id":           "The ID of the stream for the pipeline failure.",
					"value.proto_value.deepstream_pipeline_failure.channel_id":          metadatahelpers.EnumDescription("The channel for the pipeline failure.", workforcehubproto.CameraStreamChannel_name),
					"value.proto_value.deepstream_pipeline_failure.failure_description": "Description of the failure.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDeepstreamPipelineStats,
			BinaryMessageField: "DeepstreamPipelineStats",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Deepstream Pipeline falures",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.deepstream_pipeline_stats":                                           "Struct containing the deepstream video pipeline stats.",
					"value.proto_value.deepstream_pipeline_stats.aggregates":                                "Struct containing stats about aggregate pipelines (inference).",
					"value.proto_value.deepstream_pipeline_stats.aggregates.camera_device_id":               "The ID of the camera device the media is associated with.",
					"value.proto_value.deepstream_pipeline_stats.aggregates.stream_id":                      "The ID of the stream the media is associated with.",
					"value.proto_value.deepstream_pipeline_stats.aggregates.channel_id":                     metadatahelpers.EnumDescription("The channel the media is associated with.", workforcehubproto.CameraStreamChannel_name),
					"value.proto_value.deepstream_pipeline_stats.aggregates.start_time_ms":                  "The time in Ms this stats began collection.",
					"value.proto_value.deepstream_pipeline_stats.aggregates.duration_ms":                    "The duration in Ms this stats was collected.",
					"value.proto_value.deepstream_pipeline_stats.aggregates.monitors":                       "List of monitor structs for this object stat.",
					"value.proto_value.deepstream_pipeline_stats.aggregates.monitors.stage":                 metadatahelpers.EnumDescription("What stage of the pipeline this is for.", workforcehubproto.DeepstreamPipelineStats_Section_Monitor_Stage_name),
					"value.proto_value.deepstream_pipeline_stats.aggregates.monitors.interval_buffer_count": "The number of buffers passing through this stage for this stat.",
					"value.proto_value.deepstream_pipeline_stats.streams":                                   "Struct containing stats about each pipeline stream .",
					"value.proto_value.deepstream_pipeline_stats.streams.camera_device_id":                  "The ID of the camera device the media is associated with.",
					"value.proto_value.deepstream_pipeline_stats.streams.stream_id":                         "The ID of the stream the media is associated with.",
					"value.proto_value.deepstream_pipeline_stats.streams.channel_id":                        metadatahelpers.EnumDescription("The channel the media is associated with.", workforcehubproto.CameraStreamChannel_name),
					"value.proto_value.deepstream_pipeline_stats.streams.start_time_ms":                     "The time in Ms this stats began collection.",
					"value.proto_value.deepstream_pipeline_stats.streams.duration_ms":                       "The duration in Ms this stats was collected.",
					"value.proto_value.deepstream_pipeline_stats.streams.monitors":                          "List of monitor structs for this object stat.",
					"value.proto_value.deepstream_pipeline_stats.streams.monitors.stage":                    metadatahelpers.EnumDescription("What stage of the pipeline this is for.", workforcehubproto.DeepstreamPipelineStats_Section_Monitor_Stage_name),
					"value.proto_value.deepstream_pipeline_stats.streams.monitors.interval_buffer_count":    "The number of buffers passing through this stage for this stat.",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDEFTankLevelMillipercent,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaintenanceTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Diesel Exhaust Fluid (DEF) remaining fluid (millipercent)",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Amount of Diesel Exhaust Fluid in the vehicle DEF tank. Report in millipercent",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaAccelEngineTorqueOverLimitMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta total time engine torque over limit (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta amount of time the engine torque was over the configured threshold. The threshold is configured in EcodriverConfig.AccelMinEngineTorque. This is derived from osDAccelEngineTorqueOverLimitWhileNotOnCruiseControlMs.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaAccelEngineTorqueOverLimitWhileNotOnCruiseControlMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta total time engine torque over limit while cruise control disabled (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta amount of time the engine torque was over the configured threshold. The threshold is configured in EcodriverConfig.AccelMinEngineTorque. This is derived from osDAccelEngineTorqueOverLimitWhileNotOnCruiseControlMs.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDeltaAcceleratorPedalTimeGreaterThan95PercentMs,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta total time accelerator pedal pressed over threshold (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta total amount of time the accelerator pedal was above 95% depressed and the vehicle is moving. This is derived from osDAcceleratorPedalTimeGreaterThan95PercentMs",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("accelerator pedal time", hubproto.ObdValue_name),
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaAnticipationBrakeEvents,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta vehicle anticipation braking events detected",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta number of anticipation brake press transitions detected. The value increases every time a brake event is seen within 1 second of an acceleration pedal event. The 1 second delay is not configurable. Values derived for both passenger and heavy duty vehicles. This is a summed stat of osDAnticipationBrakeEvents",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaBrakeEvents,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta vehicle brake presses detected",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta number of brake press transitions detected. The value increases for each brake press/release seen from the vehicle. Values derived for both passenger and heavy duty vehicles. This stat is derived from osDBrakeEvents.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaCoastingTimeMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta amount of time the vehicle was detected to be coasting. Coasting is the amount of time that: the brake is not pressed, speed is non-zero, and engine load is 0. Values derived for both passenger and heavy duty vehicles. This is derived from osDCoastingTimeMs",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaCoastingTimeTorqueBasedWhileNotOnCruiseControlMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta amount of time the vehicle was detected to be coasting. For coasting to be reported, cruise control disabled, the brake is not pressed, speed is non-zero, and engine load is 0. Values derived for both passenger and heavy duty vehicles. Delta from osDCoastingTimeTorqueBasedWhileNotOnCruiseControlMs.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaCoastingTimeWhileNotOnCruiseControlMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta amount of time time the vehicle was detected to be coasting. Coasting time counts when the following conditions are met: speed is non-zero, the accelerator pedal is ot pressed, cruise control is not engaged, and engine load is 0. Values derived for both passenger and heavy duty vehicles. Delta from osDDerivedCoastingTimeWhileNotOnCruiseControlMs.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaCruiseControlMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta vehicle duration of cruise control being enabled (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta of time the vehicle had a non-zero speed and had cruise control enabled. Reported mainly by heavy duty vehicles",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaEvChargingEnergyMicroWh,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta vehicle energy accumulated while charging (uWh)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta of micro watt-hours of energy accumulated while charging. Summed from osDDeltaEvChargingEnergyMicroWh",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDeltaEvDistanceDrivenOnElectricPowerKm,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         metadatahelpers.DeprecatedDescription("Summed total distance travelled on electric power (km)"),
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta of total distance, over time, driven on the current trip with only electric power. Odometer is typically used, and sums changes in odometer over times when RPM is 0. This may not accumulate correctly if the vehicle generates a synthetic RPM value. The RPM check is necessary in the case of hybrid electric vehicles, where its possible to travel part of a trip on electric, and another part on an ICE engine. RPM being zero implies the electric battery is solely in use.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaEvDistanceDrivenOnElectricPowerMeters,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta distance travelled on electric power (m)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Sum of the total distance, over time, driven on the current trip with only electric power. Odometer is typically used, and sums changes in odometer over times when RPM is 0. This may not accumulate correctly if the vehicle generates a synthetic RPM value. The RPM check is necessary in the case of hybrid electric vehicles, where its possible to travel part of a trip on electric, and another part on an ICE engine. RPM being zero implies the electric battery is solely in use.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaEvEnergyConsumedMicroWh,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta electric vehicle energy consumed while driving (uWh)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Micro watt-hours of energy used while driving. This can be calculated a number of ways, but mainly: the charging status and the battery volts and current, or an accumulated amount of energy tracked by the vehicle. This is non-standard for passenger vehicles, but part of the more recent J1939 standards. Delta osDEvEnergyConsumedMicroWh.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaEvTotalEnergyRegeneratedWhileDrivingMicroWh,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta electric vehicle energy consumed while driving (uWh)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Micro watt-hours of energy accumulated while driving. This can be calculated a number of ways, but mainly: the charging status and the battery volts and current, or an accumulated amount of energy tracked by the vehicle. This is non-standard for passenger vehicles, but part of the more recent J1939 standards. Delta from osDEvEnergyRegeneratedWhileDrivingMicroWh.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDeltaFuelConsumed,
			BinaryMessageField: "DiagnosticFeatureData",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta amount of liquid fuel consumed (ml)",
				Frequency:           FrequencyCustom("at least 1L of fuel being consumed, pre VG-22. Every 2 minutes post VG-22"),
				IntValueDescription: "Total amount of vehicle liquid fuel consumed. Vehicles support different methods for calculating fuel consumption. The method prioritization is configurable. The prioritization is a list of calculation methods ranked from high to low priority. The default priority order was decided based on the number of inputs required to calculate fuel consumption. This is derived from osDFuelConsumed.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_feature_data.obd_value":             metadatahelpers.EnumDescription("Method identifier in use.*_METHOD_* is the key to look for (post VG-22 FW only)", hubproto.ObdValue_name),
					"value.proto_value.diagnostic_feature_data.method_data.value":     "Amount of fuel consumed by the vehicle using the associated tracking_method (post VG-22)",
					"value.proto_value.diagnostic_feature_data.method_data.obd_value": metadatahelpers.EnumDescription("Method identifier in use.*_METHOD_* is the key to look for (post VG-22 FW only)", hubproto.ObdValue_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				HourlyCronSchedule: true,
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDeltaGpsDistance,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDeltaRpmGreenBandMs,
			BinaryMessageField: "ConfiguredRpmGreenBand",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Delta duration of vehicle running in a specific RPM range",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Delta amount of time the vehicle was running in a green-band RPM range. By default, this range is 800-1700 RPM. This range is configurable. This stat is derived from osDRpmGreenBandMs.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.configured_rpm_green_band.lower_limit_rpm": "Lower limit used for green band RPM range. Configurable, default 800RPM",
					"value.proto_value.configured_rpm_green_band.upper_limit_rpm": "Upper limit used for green band RPM range. Configurable, default 1700RPM",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDenoisedFuelLevel,
			BinaryMessageField: "DenoisedFuelLevel",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Processed fuel level data with noise reduction applied to raw ECU fuel level measurements",
				Frequency:   FrequencyCustom("Emitted when fuel level denoising processing is completed"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.denoised_fuel_level.fuel_level_millipercent": "Denoised fuel level in millipercent",
					"value.proto_value.denoised_fuel_level.is_modified":             "Boolean indicating whether this data point was modified during the denoising process",
					"value.proto_value.denoised_fuel_level.is_noise":                "Boolean indicating whether this data point was identified as noise",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDenoisedFuelLevelV2,
			BinaryMessageField: "DenoisedFuelLevelV2",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Processed fuel level data V2 with noise reduction applied to raw ECU fuel level measurements",
				Frequency:   FrequencyCustom("Emitted when fuel level denoising processing is completed"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.denoised_fuel_level_v2.data.fuel_level_millipercent":     "Denoised fuel level in millipercent",
					"value.proto_value.denoised_fuel_level_v2.data.has_fuel_level_millipercent": "Boolean indicating if fuel level is present",
					"value.proto_value.denoised_fuel_level_v2.experiments":                      "Experimental denoised fuel level data",
					"value.proto_value.denoised_fuel_level_v2.source_data":                      "Source data used for denoising",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDenoisedFuelLevelV2Shadow,
			BinaryMessageField: "DenoisedFuelLevelV2",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Shadow stat for osDDenoisedFuelLevelV2",
				Frequency:   FrequencyCustom("Emitted when fuel level denoising processing is completed"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.denoised_fuel_level_v2.data.fuel_level_millipercent":     "Denoised fuel level in millipercent",
					"value.proto_value.denoised_fuel_level_v2.data.has_fuel_level_millipercent": "Boolean indicating if fuel level is present",
					"value.proto_value.denoised_fuel_level_v2.experiments":                      "Experimental denoised fuel level data",
					"value.proto_value.denoised_fuel_level_v2.source_data":                      "Source data used for denoising",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedAccelEngineTorqueOverLimitMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed total time engine torque over limit (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the engine torque was over the configured threshold. The threshold is configured in EcodriverConfig.AccelMinEngineTorque. This is derived from osDAccelEngineTorqueOverLimitWhileNotOnCruiseControlMs.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedAccelEngineTorqueOverLimitWhileNotOnCruiseControlMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed total time engine torque over limit while cruise control disabled (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the engine torque was over the configured threshold. The threshold is configured in EcodriverConfig.AccelMinEngineTorque. This is derived from osDAccelEngineTorqueOverLimitWhileNotOnCruiseControlMs.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedAcceleratorPedalTimeGreaterThan95PercentMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed total time accelerator pedal pressed over threshold (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Summed total amount of time the accelerator pedal was above 95% depressed and the vehicle is moving. This is derived from osDAcceleratorPedalTimeGreaterThan95PercentMs",
			},
			InternalOverrides: &DataplatformOverrides{
				HourlyCronSchedule: true,
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedAnticipationBrakeEvents,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed vehicle anticipation braking events detected",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total number of anticipation brake press transitions detected. The value increases every time a brake event is seen within 1 second of an acceleration pedal event. The 1 second delay is not configurable. Values derived for both passenger and heavy duty vehicles. This is a summed stat of osDAnticipationBrakeEvents",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedBrakeEvents,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed vehicle brake presses detected",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total number of brake press transitions detected. The value increases for each brake press/release seen from the vehicle. Values derived for both passenger and heavy duty vehicles. This stat is derived from osDBrakeEvents.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDerivedCargoState,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "The overall cargo state based on pinned sensors.",
				Frequency:           FrequencyCustom("Up to every 5 minutes, based on the frequency of the underlying sensor data."),
				IntValueDescription: "The overall cargo state of the device. Enum is mapped in the cargo package, but 0 Unknown, 1 Empty, 2 PartiallyEmpty, 3 Full.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedCoastingTimeMs,
			Kind:          StatKindObjectStat,
			Production:    true,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the vehicle was detected to be coasting. Coasting is the amount of time that: the brake is not pressed, speed is non-zero, and engine load is 0. Values derived for both passenger and heavy duty vehicles. This is derived from osDCoastingTimeMs",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
				HourlyCronSchedule: true,
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedCoastingTimeTorqueBasedWhileNotOnCruiseControlMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the vehicle was detected to be coasting. For coasting to be reported, cruise control disabled, the brake is not pressed, speed is non-zero, and engine load is 0. Values derived for both passenger and heavy duty vehicles. Derived from osDCoastingTimeTorqueBasedWhileNotOnCruiseControlMs.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						EnableUcKinesisStats: true,
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDerivedCoastingTimeWhileNotOnCruiseControlMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total vehicle coasting time detected (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Summed amount of time time the vehicle was detected to be coasting. Coasting time counts when the following conditions are met: speed is non-zero, the accelerator pedal is ot pressed, cruise control is not engaged, and engine load is 0. Values derived for both passenger and heavy duty vehicles. Derived from osDDerivedCoastingTimeWhileNotOnCruiseControlMs.",
			},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedCruiseControlMs,
			Kind:          StatKindObjectStat,
			Production:    true,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total vehicle duration of cruise control being enabled (ms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the vehicle had a non-zero speed and had cruise control enabled. Reported mainly by heavy duty vehicles",
			},
			InternalOverrides: &DataplatformOverrides{
				HourlyCronSchedule: true,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDerivedEngineEngageEvent,
			Kind:               StatKindObjectStat,
			Production:         false,
			Tags:               []amundsentags.Tag{amundsentags.FuelTag, amundsentags.TelematicsTag},
			BinaryMessageField: "EngineEngageEvent",
			MetadataInfo: &MetadataInfo{
				Description:         "Created for engine engage events. The active and end events have aggregate info for consumption and duration.",
				IntValueDescription: "The engage event state. Same value as value.proto_value.engine_engage_event.engage_state",
				Frequency:           FrequencyOnChange("These stats are generated through processing of engine state stats being engaged."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.engine_engage_event.event_uuid":                                   "The unique identifier for an event. Shared between its start, active, and end events.",
					"value.proto_value.engine_engage_event.engage_state":                                 "Either 1 (STARTED), 2 (ACTIVE), or 3 (ENDED).",
					"value.proto_value.engine_engage_event.start_ms":                                     "The start time of the event.",
					"value.proto_value.engine_engage_event.duration_ms":                                  "The duration of the event.",
					"value.proto_value.engine_engage_event.consumption_info":                             "Consumption information about the event.",
					"value.proto_value.engine_engage_event.consumption_info.fuel_consumed_ml":            "How much fuel was consumed during the event.",
					"value.proto_value.engine_engage_event.consumption_info.gaseous_fuel_consumed_grams": "How much gaseous fuel was consumed during the event",
					"value.proto_value.engine_engage_event.consumption_info.energy_consumed_kwh":         "How much energy was consumed during the event",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDerivedEngineIdleEvent,
			Kind:               StatKindObjectStat,
			Production:         false,
			Tags:               []amundsentags.Tag{amundsentags.FuelTag, amundsentags.TelematicsTag},
			BinaryMessageField: "EngineIdleEvent",
			MetadataInfo: &MetadataInfo{
				Description:         "Created for idling events, with additional relevant context. The active and end events have aggregate info for consumption and duration.",
				IntValueDescription: "The idling state. Same value as value.proto_value.engine_idle_event.idling_state",
				Frequency:           FrequencyOnChange("These stats are generated through processing of engine state stats being idle."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.engine_idle_event.event_uuid":                                    "The unique identifier for an idling event. Shared between its start and end events.",
					"value.proto_value.engine_idle_event.idling_state":                                  "Either 1 (STARTED), 2 (ACTIVE), or 3 (ENDED).",
					"value.proto_value.engine_idle_event.start_ms":                                      "The start time of the idling event.",
					"value.proto_value.engine_idle_event.duration_ms":                                   "The duration of the idling event.",
					"value.proto_value.engine_idle_event.context":                                       "Contextual information about the idling event.",
					"value.proto_value.engine_idle_event.context.pto_state":                             "Whether power takeoff was active or not. Used to break up idling events. Either 0 (UNKNOWN), 1 (ACTIVE), or 2 (INACTIVE).",
					"value.proto_value.engine_idle_event.context.active_pto_inputs":                     "Information about which PTO inputs were active.",
					"value.proto_value.engine_idle_event.context.ambient_air_temperature_milli_celsius": "The ambient temperature during the idling event.",
					"value.proto_value.engine_idle_event.context.location":                              "The location of the idling event.",
					"value.proto_value.engine_idle_event.consumption_info":                              "Consumption information about the idling event.",
					"value.proto_value.engine_idle_event.consumption_info.fuel_consumed_ml":             "How much fuel was consumed during the idling event.",
					"value.proto_value.engine_idle_event.consumption_info.gaseous_fuel_consumed_grams":  "How much gaseous fuel was consumed during the idling event",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDerivedEngineMsFromEquipmentActivity,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Accumulated engine milliseconds derived from osDEquipmentActivity by detecting on/off periods. One of the sources of Engine Hours.",
				Frequency:           FrequencyOnChange("osDEquipmentActivity"),
				IntValueDescription: "Accumulated engine milliseconds derived from osDEquipmentActivity by detecting on/off periods. The manual engine hours (provided by a customer) should be used as offset to calculate the actual (synthetic) engine hours value.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDerivedEngineSecondsFromCableVoltage,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine seconds derived from osDCableVoltage by detecting engine on/off periods. One of the sources of Engine Hours.",
				Frequency:           FrequencyCustom("same as osDCableVoltage"),
				IntValueDescription: "Engine seconds derived from osDCableVoltage by detecting engine on/off periods. The manual engine hours (provided by a customer) should be used as offset to calculate the actual engine hours value.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(32),
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedEngineSecondsFromIgnitionCycle,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total engine seconds summed from ignition power cycle. One of the sources of Engine Hours.",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total engine seconds summed by the time since engine ignition. Summed from osDEngineGauge.proto_value.engine_gauge_event.engine_on_secs",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSEURegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDerivedEvChargeStatus,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "EvChargeStatusInfo",
			Tags:               []amundsentags.Tag{amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description: "Active charge statuses of the EV and the device timezone",
				Frequency:   FrequencyCustom("When any of the active charge statuses change or the device timezone changes."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ev_charge_status_info.statuses.complete":                            "If the current SoC is at or above the target charge level in its charge profile, default to 80% if no profile.",
					"value.proto_value.ev_charge_status_info.statuses.missed_target_charge":                "If the vehicle either is below target charge level (stop surfacing the event after 60min) after the departure time, or stopped charging in between its scheduled start charge and departure time without reaching its target charge level.",
					"value.proto_value.ev_charge_status_info.statuses.expected_to_miss_target_charge":      "If the vehicle is charging during its scheduled charge time, but won't hit the target charge by its scheduled departure time based on current charging speed. Only be available when target charge is <= 80%.",
					"value.proto_value.ev_charge_status_info.statuses.charging":                            "If the vehicle is charging",
					"value.proto_value.ev_charge_status_info.statuses.low":                                 "If the current SoC is at or below the low charge level set in its charge profile, defaults to 20% if no profile.",
					"value.proto_value.ev_charge_status_info.statuses.late_for_scheduled_charge":           "If the vehicle has not started charging at its scheduled start charge time (15 minute tolerance). Disappears at the defined departure time (if available), otherwise, it will persist until the vehicle triggers another status with a higher priority.",
					"value.proto_value.ev_charge_status_info.device_timezone":                              "The device's timezone.",
					"value.proto_value.ev_charge_status_info.highest_priority_charge_status_changed_at_ms": "The time at which the highest priority charge status changed, prior to and also including the stat in question.",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedEvChargingEnergyMicroWh,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed electric vehicle energy accumulated while charging (uWh)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of micro watt-hours of energy accumulated while charging. Summed from osDDeltaEvChargingEnergyMicroWh",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDerivedEvDistanceDrivenOnElectricPowerKm,
			Kind:       StatKindObjectStat,
			Production: true,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         metadatahelpers.DeprecatedDescription("Summed total distance travelled on electric power (km)"),
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Sum of the total distance, over time, driven on the current trip with only electric power. Odometer is typically used, and sums changes in odometer over times when RPM is 0. This may not accumulate correctly if the vehicle generates a synthetic RPM value. The RPM check is necessary in the case of hybrid electric vehicles, where its possible to travel part of a trip on electric, and another part on an ICE engine. RPM being zero implies the electric battery is solely in use.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedEvDistanceDrivenOnElectricPowerMeters,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed total distance travelled on electric power (m)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Sum of the total distance, over time, driven on the current trip with only electric power. Odometer is typically used, and sums changes in odometer over times when RPM is 0. This may not accumulate correctly if the vehicle generates a synthetic RPM value. The RPM check is necessary in the case of hybrid electric vehicles, where its possible to travel part of a trip on electric, and another part on an ICE engine. RPM being zero implies the electric battery is solely in use.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDerivedEvEnergyConsumedMicroWh,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed total electric vehicle energy consumed while driving (uWh)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Micro watt-hours of energy used while driving. This can be calculated a number of ways, but mainly: the charging status and the battery volts and current, or an accumulated amount of energy tracked by the vehicle. This is non-standard for passenger vehicles, but part of the more recent J1939 standards. Derived osDEvEnergyConsumedMicroWh.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDerivedEvReachingTargetChargeAtMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Time at which charging for EV is projected to reach its target charge based on its charge profile",
				Frequency:           FrequencyCustom("When the EV starts charging, or when the EV is both charging and the projected time changes by a significant amount"),
				IntValueDescription: "UTC time (in ms) at which charging for an EV is projected to reach its target charge based on the charge profile it is assigned to",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDerivedEvTotalEnergyRegeneratedWhileDrivingMicroWh,
			Kind:       StatKindObjectStat,
			Production: true,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed total electric vehicle energy consumed while driving (uWh)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Micro watt-hours of energy accumulated while driving. This can be calculated a number of ways, but mainly: the charging status and the battery volts and current, or an accumulated amount of energy tracked by the vehicle. This is non-standard for passenger vehicles, but part of the more recent J1939 standards. Derived from osDEvEnergyRegeneratedWhileDrivingMicroWh.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDerivedFuelConsumed,
			BinaryMessageField: "DiagnosticFeatureData",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed total amount of liquid fuel consumed (ml)",
				Frequency:           FrequencyCustom("at least 1L of fuel being consumed, pre VG-22. Every 2 minutes post VG-22"),
				IntValueDescription: "Total amount of vehicle liquid fuel consumed. Vehicles support different methods for calculating fuel consumption. The method prioritization is configurable. The prioritization is a list of calculation methods ranked from high to low priority. The default priority order was decided based on the number of inputs required to calculate fuel consumption. This is derived from osDFuelConsumed.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_feature_data.obd_value":             metadatahelpers.EnumDescription("Method identifier in use.*_METHOD_* is the key to look for (post VG-22 FW only)", hubproto.ObdValue_name),
					"value.proto_value.diagnostic_feature_data.method_data.value":     "Amount of fuel consumed by the vehicle using the associated tracking_method (post VG-22)",
					"value.proto_value.diagnostic_feature_data.method_data.obd_value": metadatahelpers.EnumDescription("Method identifier in use.*_METHOD_* is the key to look for (post VG-22 FW only)", hubproto.ObdValue_name),
				},
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDerivedGpsDistance,
			Kind:       StatKindObjectStat,
			Production: true,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(32),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDerivedPingCount,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDerivedRpmGreenBandMs,
			BinaryMessageField: "ConfiguredRpmGreenBand",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Summed duration of vehicle running in a specific RPM range",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Total amount of time the vehicle was running in a green-band RPM range. By default, this range is 800-1700 RPM. This range is configurable. This stat is derived from osDRpmGreenBandMs.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.configured_rpm_green_band.lower_limit_rpm": "Lower limit used for green band RPM range. Configurable, default 800RPM",
					"value.proto_value.configured_rpm_green_band.upper_limit_rpm": "Upper limit used for green band RPM range. Configurable, default 1700RPM",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDerivedTotalAssetEngineMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total engine milliseconds derived from osDDigioInput1 by detecting on/off periods. One of the sources of Engine Hours.",
				Frequency:           FrequencyOnChange("osDDigioInput1"),
				IntValueDescription: "Total engine milliseconds derived from osDDigioInput1 by detecting on/off periods. The manual engine hours (provided by a customer) should be used as offset to calculate the actual engine hours value.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDerivedTotalVehicleEngineMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total engine milliseconds derived from osDEngineState by detecting on/off periods. One of the sources of Engine Hours.",
				Frequency:           FrequencyOnChange("osDEngineState"),
				IntValueDescription: "Total engine milliseconds derived from osDEngineState by detecting on/off periods. The manual engine hours (provided by a customer) should be used as offset to calculate the actual engine hours value.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDeviceEngineFaultOffEvent,
			BinaryMessageField: "VehicleFaultEdgeEvent",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "This stat indicates that an engine fault off event occurred for a specific vehicle.",
				Frequency:   FrequencyCustom("These stats are generated through processing of engine fault state stats."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.vehicle_fault_edge_event":                             "VehicleFaultEdgeEvent contains the vehicle fault event information.",
					"value.proto_value.vehicle_fault_edge_event.j1939_faults":                "J1939 engine faults that turned off at the time.",
					"value.proto_value.vehicle_fault_edge_event.passenger_faults":            "Passenger engine fautls that turned off at the time.",
					"value.proto_value.vehicle_fault_edge_event.oem_faults":                  "OEM engine fautls that turned off at the time.",
					"value.proto_value.vehicle_fault_edge_event.j1939_faults.fault_code":     "The J1939 fault code.",
					"value.proto_value.vehicle_fault_edge_event.j1939_faults.lamp":           metadatahelpers.EnumDescription("The type of J1939 lamp", hubproto.ObjectStatBinaryMessage_VehicleFaultEdgeEvent_Lamp_name),
					"value.proto_value.vehicle_fault_edge_event.j1939_faults.data":           "The corresponding J1939 engine fault stat data",
					"value.proto_value.vehicle_fault_edge_event.passenger_faults.fault_code": "The Passenger fault code.",
					"value.proto_value.vehicle_fault_edge_event.passenger_faults.lamp":       "The Passenger lamp.",
					"value.proto_value.vehicle_fault_edge_event.passenger_faults.data":       "The corresponding Passenger engine fault stat data",
					"value.proto_value.vehicle_fault_edge_event.oem_faults.fault_code":       "The OEM fault code.",
					"value.proto_value.vehicle_fault_edge_event.oem_faults.data":             "The corresponding OEM engine fault stat data",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDeviceEngineFaultOnEvent,
			BinaryMessageField: "VehicleFaultEdgeEvent",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "This stat indicates that an engine fault on event occurred for a specific vehicle.",
				Frequency:   FrequencyCustom("These stats are generated through processing of engine fault state stats."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.vehicle_fault_edge_event":                             "VehicleFaultEdgeEvent contains the vehicle fault event information.",
					"value.proto_value.vehicle_fault_edge_event.j1939_faults":                "J1939 engine faults that turned on at the time.",
					"value.proto_value.vehicle_fault_edge_event.passenger_faults":            "Passenger engine fautls that turned on at the time.",
					"value.proto_value.vehicle_fault_edge_event.oem_faults":                  "OEM engine fautls that turned on at the time.",
					"value.proto_value.vehicle_fault_edge_event.j1939_faults.fault_code":     "The J1939 fault code.",
					"value.proto_value.vehicle_fault_edge_event.j1939_faults.lamp":           metadatahelpers.EnumDescription("The type of J1939 lamp", hubproto.ObjectStatBinaryMessage_VehicleFaultEdgeEvent_Lamp_name),
					"value.proto_value.vehicle_fault_edge_event.j1939_faults.data":           "The corresponding J1939 engine fault stat data",
					"value.proto_value.vehicle_fault_edge_event.passenger_faults.fault_code": "The Passenger fault code.",
					"value.proto_value.vehicle_fault_edge_event.passenger_faults.lamp":       "The Passenger lamp.",
					"value.proto_value.vehicle_fault_edge_event.passenger_faults.data":       "The corresponding Passenger engine fault stat data",
					"value.proto_value.vehicle_fault_edge_event.oem_faults.fault_code":       "The OEM fault code.",
					"value.proto_value.vehicle_fault_edge_event.oem_faults.data":             "The corresponding OEM engine fault stat data",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDevicePowerState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "The power state of the device",
				Frequency:           FrequencyCustom("Anytime there is a state change in the device power state"),
				IntValueDescription: "Represents the power state of the asset",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDiagnosticLockAddedInfo,
			BinaryMessageField: "DiagnosticLockSetInfo",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "OBD v1 lock added information",
				Frequency:   FrequencyCustom("only logged when a new lock for an obd value is established"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_lock_set_info.chosen_tx_id": "The txid, or ecuId, of the source we locked to for this obd value",
					"value.proto_value.diagnostic_lock_set_info.obd_value":    metadatahelpers.EnumDescription("The obd value this lock information is considering", hubproto.ObdValue_name),
					"value.proto_value.diagnostic_lock_set_info.priority":     "The priority of the source locked to. For example, high or low resolution odometer",
					"value.proto_value.diagnostic_lock_set_info.seen_tx_ids":  "All txids, or ecuIds, seen before we locked to the source for this obd value",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDiagnosticMessagesSeen,
			BinaryMessageField: "DiagnosticMessagesSeen",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Messages seen on a vehicle hardwired connection",
				Frequency:   FrequencyCustom("once per diagnostic session after a vehicle connection has been sustained for 1 minute"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_messages_seen.msg_id":               "Each incoming message from a vehicle is from a diagnostic standard. J1587 reports the incoming message PID. Passenger standards J1979/ISO27145/ISO14229 report the service and DID. J1939 reports the PGN of the message",
					"value.proto_value.diagnostic_messages_seen.msg_id_uint64":        "64-bit version of the msg_id field",
					"value.proto_value.diagnostic_messages_seen.txid":                 "ECU address that sent the message",
					"value.proto_value.diagnostic_messages_seen.bus_type":             "CAN bus data was received from. CAN bus types are defined in logeventproto.LogEvent_ObdEvent_CanBusType",
					"value.proto_value.diagnostic_messages_seen.last_bytes":           "Contains the last message bytes sent. This is not enabled by default",
					"value.proto_value.diagnostic_messages_seen.last_bytes_valid":     "If true, the associated last_bytes field is valid",
					"value.proto_value.diagnostic_messages_seen.last_reported_ago_ms": "Difference between time reported and the last request time",
					"value.proto_value.diagnostic_messages_seen.total_count":          "Times this message was seen",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput1,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #1 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput10,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #10 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput11,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #11 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput12,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #12 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput13,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #13 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput14,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #14 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput15,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #15 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput16,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #16 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput17,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #17 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput18,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #18 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput19,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #19 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput2,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #2 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput20,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #20 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput21,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #21 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput22,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #22 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput23,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #23 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput24,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #24 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput25,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #25 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput26,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #26 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput27,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #27 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput28,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #28 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput29,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #29 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput3,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #3 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput30,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #30 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput31,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #31 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput32,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #32 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput33,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #33 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput34,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #34 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput35,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #35 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput36,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #36 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput37,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #37 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput38,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #38 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput39,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #39 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput4,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #4 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput40,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #40 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput5,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #5 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput6,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #6 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput7,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #7 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput8,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #8 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioDomainInput9,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Digio values from custom digio type assigned to #9 domain slot",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput1,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput10,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput2,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput3,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput4,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput5,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput6,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput7,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput8,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDigioInput9,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived1,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput1",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput1, roughly every ~1 second"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived10,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput10",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput10, roughly every ~15 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived11,
			Kind:       StatKindObjectStat,
			Production: false,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput11",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput11, roughly every ~15 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived12,
			Kind:       StatKindObjectStat,
			Production: false,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput12",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput12, roughly every ~15 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived13,
			Kind:       StatKindObjectStat,
			Production: false,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput13",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput13, roughly every ~15 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived2,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput2",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput2, roughly every ~1.2 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived3,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput3",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput3, roughly every ~0.15 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived4,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput4",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput4, roughly every ~3 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived5,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput5",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput5, roughly every ~3 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived6,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput6",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput6, roughly every ~9 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived7,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput7",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput7, roughly every ~15 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived8,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput8",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput8, roughly every ~15 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDDigioInputDerived9,
			Kind:       StatKindObjectStat,
			Production: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Derived from osDDigioInput9",
				Frequency:           FrequencyOnChange("Derived from osDDigioInput9, roughly every ~17 seconds"),
				IntValueDescription: "Represents the integer value from the digital input signal.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputAtisLamp,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain input for ATIS lamp control",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for ATIS lamp.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputAuxiliaryEngine,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain input for auxiliary engine control",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for auxiliary engine.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputBoom,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for boom",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for boom.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputDoors,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for doors",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for doors.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputEightWayLights,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for eight-way lights",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for eight-way lights.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputEmergencyAlarm,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for emergency alarm",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for emergency alarm.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputEmergencyLights,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for emergency lights",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for emergency lights.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputEquipmentActivity,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for equipment activity",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for equipment activity.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputFrontAxleDrive,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for front axle drive",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for front axle drive.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputGenerator,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for generator",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for generator.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputOther,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for other equipment",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for other equipment.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputPanicButton,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for panic button",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for panic button.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputPlow,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for plow",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for plow.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputPowerTakeOff,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for power take-off",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for power take-off.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputPrivacyButton,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for privacy button",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for privacy button.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputReefer,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for reefer",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for reefer.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputSalter,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for salter",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for salter.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputSecondaryFuelSource,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for secondary fuel source",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for secondary fuel source.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputStopPaddle,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for stop paddle",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for stop paddle.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputSweeper,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for sweeper",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for sweeper.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputVirtualEcuPto,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for virtual ECU PTO",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for virtual ECU PTO.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDigioStandardDomainInputWeightSensor,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Standard domain digio inputs for weight sensor",
				Frequency:           FrequencyOnChange("Digital input state changes"),
				IntValueDescription: "Represents the integer value from the digital input signal for weight sensor.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDiskStats,
			BinaryMessageField: "DiskStats",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports disk storage information including UBI filesystem details, free space, and encryption status",
				Frequency:   FrequencyCustom("Whenever a config push is made"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.disk_stats.ubi_infos.volumes_count":                          "Number of UBI volumes.",
					"value.proto_value.disk_stats.ubi_infos.logical_eraseblock_size":                "Size of logical erase blocks in bytes.",
					"value.proto_value.disk_stats.ubi_infos.total_amount_of_logical_eraseblocks":    "Total number of logical erase blocks available.",
					"value.proto_value.disk_stats.ubi_infos.amount_of_available_logic_eraseblocks":  "Number of logical erase blocks currently available for use.",
					"value.proto_value.disk_stats.ubi_infos.count_of_bad_physical_eraseblocks":      "Number of physical erase blocks marked as bad.",
					"value.proto_value.disk_stats.ubi_infos.count_of_reserved_physical_eraseblocks": "Number of physical erase blocks reserved by the system.",
					"value.proto_value.disk_stats.ubi_infos.current_maximum_erase_counter_value":    "Current maximum erase counter value across all blocks.",
					"value.proto_value.disk_stats.ubi_infos.minimum_output_unit_size":               "Minimum output unit size in bytes.",
					"value.proto_value.disk_stats.free_space_info_home":                             "Free disk space information for the home directory.",
					"value.proto_value.disk_stats.free_space_info_home.free_space_kbytes":           "Available free space in kilobytes.",
					"value.proto_value.disk_stats.free_space_info_home.free_space_percent":          "Available free space as a percentage of total disk space.",
					"value.proto_value.disk_stats.disk_encryption.status":                           metadatahelpers.EnumDescription("Current encryption status of the disk", hubproto.ObjectStatBinaryMessage_DiskStats_DiskEncryption_Status_name),
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDistanceServiceMeters,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Distance til next service required (m)",
				Frequency:           FrequencyOnChange("reported as vehicle faults appear"),
				IntValueDescription: "The distance which can be traveled by the vehicle before the next service inspection is required.  A negative distance is transmitted if the service inspection has been passed.  The component that requires service is identified by the service component identification (see SPN 911-913, 1379, and 1584). J1939-DA PGN 65216 (SERV Service Distance), SPN 914. Only supported for J1939 vehicles.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDoorLockStatus,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Door lock status for first student school buses",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: metadatahelpers.EnumDescription("Door lock status", hubproto.DoorLockStatus_name),
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDoorOpenStatus,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Door open status for first student school buses",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: metadatahelpers.EnumDescription("Door open status", hubproto.DoorOpenStatus_name),
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDpfLampStatus,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "J1939 DPF Lamp Status",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Command to control the diesel particulate filter lamp. We only monitor for three values: 0 - OFF, 1 - ON, 4 - ON blink fast. A 1 is reported if the DPF lamp status is on, and 0 otherwise. This SP would be off when diesel particulate filter lamp is unlit.  The on - solid should indicate that diesel particulate filter active regeneration is needed at the lowest level of urgency and that operator intervention is required.  A faster blink state indicates a more severe condition requiring regeneration. J1939-DA PGN 64892 (Diesel Particulate Filter Control 1) [DPFC1], SPN 3697.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDDriverAlertnessWarningSystemState,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "State of the truck's embedded Driver Alertness Warning System",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "0: System installed but disabled, 1: Initializing, 2: System temporarily not available, 3: System available, 4: System monitoring driver behavior",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDriverIRLedEnabled,
			BinaryMessageField: "DriverIRLedState",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reports CM3x IR LED state",
				Frequency:           FrequencyCustom("Reported when state/priority/source changes"),
				IntValueDescription: "Binary value representing IR LED state - 0 for disabled or 1 for enabled",
				ColumnDescriptions: map[string]string{
					"object_id": "CM device id",
					"value.proto_value.driver_i_r_led_state.enabled":  "current IR LED state",
					"value.proto_value.driver_i_r_led_state.priority": "priority of the active request",
					"value.proto_value.driver_i_r_led_state.source":   metadatahelpers.EnumDescription("client who requested the current state", hubproto.DriverIRLedState_Source_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDDriverSignInState,
			BinaryMessageField: "DriverSignInState",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Driver sign in state",
				Frequency:           FrequencyCustom("When driver signs in via NFC card / QR code or is signed out after end assignment timeout elapses"),
				IntValueDescription: "Binary value, either 0 for signed out or 1 for signed in",
				ColumnDescriptions: map[string]string{
					"object_id": "CM device id.",
					"value.proto_value.driver_sign_in_state.type":                metadatahelpers.EnumDescription("sign in method used", hubproto.DriverSignInState_Type_name),
					"value.proto_value.driver_sign_in_state.id_string":           "ID of sign in method used - either NFC card number or QR code driver assignment lookup key",
					"value.proto_value.driver_sign_in_state.is_loaded_from_disk": "Whether the driver assignment reported was loaded from the persisted state on disk",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDDummyInternalTrainingStat,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Will be used for running an internal training for Firmware Experience at Samsara. Could be evolved into a more of a boot camp like training to onboard individuals and get them familiar with the build process.",
				Frequency:           FrequencyCustom("This stat has no logging frequency, it is a test stat and has no valid data"),
				IntValueDescription: "No meaning for this column as this is a test stat with invalid data",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEbpmsBrakeEventData,
			BinaryMessageField: "EbpmsBrakeEventData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag},
			MetadataInfo: &MetadataInfo{
				Description: "Data associated to a signular brake event used for caulalating electronic brake performace",
				Frequency:   FrequencyCustom("Uploaded on brake events"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ebpms_brake_event_data.event_duration_ms":                                        "Total Brake event duration in ms",
					"value.proto_value.ebpms_brake_event_data.tractor_signals.can_demand_source":                        metadatahelpers.EnumDescription("What the arbitrated source for CAN demand pressure was ", brakemonitoringproto.EbpmsBrakeEventData_SignalDataSource_name),
					"value.proto_value.ebpms_brake_event_data.tractor_signals.can_demand_pressure.offset_from_start_ms": "Timestamp relative to the time associated with the object stat entry in ms",
					"value.proto_value.ebpms_brake_event_data.tractor_signals.can_demand_pressure.pressure_pa":          "ISO CAN demand pressure in pa",
					"value.proto_value.ebpms_brake_event_data.tractor_signals.retarder_source":                          metadatahelpers.EnumDescription("What the arbitrated source for tractor retarder status was", brakemonitoringproto.EbpmsBrakeEventData_SignalDataSource_name),
					"value.proto_value.ebpms_brake_event_data.tractor_signals.retarder_status.offset_from_start_ms":     "Timestamp relative to the time associated with the object stat entry in ms",
					"value.proto_value.ebpms_brake_event_data.tractor_signals.retarder_status.status":                   metadatahelpers.EnumDescription("Retarder status during the brake event", brakemonitoringproto.EbpmsBrakeEventData_Status_name),
					"value.proto_value.ebpms_brake_event_data.trailer_signals.wheel_speed_source":                       metadatahelpers.EnumDescription("What the arbitrated source for wheel speed was", brakemonitoringproto.EbpmsBrakeEventData_SignalDataSource_name),
					"value.proto_value.ebpms_brake_event_data.trailer_signals.wheel_speed.offset_from_start_ms":         "Timestamp relative to the time associated with the object stat entry in ms",
					"value.proto_value.ebpms_brake_event_data.trailer_signals.wheel_speed.speed_meters_per_hour":        "Wheel speed in meters per hour",
					"value.proto_value.ebpms_brake_event_data.ebs_dbg_msgs.offset_from_start_ms":                        "Timestamp relative to the time associated with the object stat entry in ms",
					"value.proto_value.ebpms_brake_event_data.ebs_dbg_msgs.msg_id":                                      "Message ID of the CAN Message",
					"value.proto_value.ebpms_brake_event_data.ebs_dbg_msgs.payload":                                     "Payload in raw bytes from the associated CAN message",
					"value.proto_value.ebpms_brake_event_data.gps.offset_from_start_ms":                                 "Timestamp relative to the time associated with the object stat entry in ms",
					"value.proto_value.ebpms_brake_event_data.gps.latitude_nanodeg":                                     "Latitude in nanodegrees",
					"value.proto_value.ebpms_brake_event_data.gps.longitude_nanodeg":                                    "Longitude in nanodegrees",
					"value.proto_value.ebpms_brake_event_data.gps.hdop_thousandths":                                     "Hdop associated with the GPS fix",
					"value.proto_value.ebpms_brake_event_data.gps.vdop_thousandths":                                     "Vdop associated with the GPS fix",
					"value.proto_value.ebpms_brake_event_data.gps.accuracy_mm":                                          "Accuracy reported related to the GPS fix in mm",
					"value.proto_value.ebpms_brake_event_data.gps.speed_mm_per_s":                                       "Speed at the time of the GPS fix in mm per sec",
					"value.proto_value.ebpms_brake_event_data.gps.altitude_mm":                                          "Altitude at the time of the GPS fix in mm",
					"value.proto_value.ebpms_brake_event_data.gps.altitude_accuracy_mm":                                 "Altitude accuracy at the time of the GPS fix in mm",
					"value.proto_value.ebpms_brake_event_data.gps.num_sats_used_in_fix":                                 "Number of satelites used in the GPS fix solution",
					"value.proto_value.ebpms_brake_event_data.axle_load_kg":                                             "Axle load as reported by the EBS at the start of the brake event",
					"value.proto_value.ebpms_brake_event_data.red_warn_lamp":                                            metadatahelpers.EnumDescription("If the Red Warning lamp was on during the brake event", brakemonitoringproto.EbpmsBrakeEventData_Status_name),
					"value.proto_value.ebpms_brake_event_data.amber_warn_lamp":                                          metadatahelpers.EnumDescription("If the Red Warning lamp was on during the brake event", brakemonitoringproto.EbpmsBrakeEventData_Status_name),
					"value.proto_value.ebpms_brake_event_data.supply_pressure_status":                                   metadatahelpers.EnumDescription("If the supply pressure was sufficent to achieve the demand for the event", brakemonitoringproto.EbpmsBrakeEventData_SupplyPressureSufficientStatus_name),
					"value.proto_value.ebpms_brake_event_data.tractor_abs_ctrl_status":                                  metadatahelpers.EnumDescription("If the tractors ABS control status was active during the event", brakemonitoringproto.EbpmsBrakeEventData_Status_name),
					"value.proto_value.ebpms_brake_event_data.trailer_abs_ctrl_status":                                  metadatahelpers.EnumDescription("If the trailers ABS control status was active during the event", brakemonitoringproto.EbpmsBrakeEventData_Status_name),
					"value.proto_value.ebpms_brake_event_data.ecu_id":                                                   "Source address of the EBS system",
					"value.proto_value.ebpms_brake_event_data.event_segmentation.segment_state":                         metadatahelpers.EnumDescription("Segment state, used to indicate if a brake event will have muliple objectstat entries", brakemonitoringproto.EbpmsBrakeEventData_EventSegmentationState_name),
					"value.proto_value.ebpms_brake_event_data.event_segmentation.start_event_time_ms":                   "Timestamp of the first object stat for a brake event, used to relate all chucks of the same event together",
					"value.proto_value.ebpms_brake_event_data.event_segmentation.segment_counter":                       "Segment counter used to indicate the packet sequence number in a segmented event",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEbpmsResetEvent,
			BinaryMessageField: "EbpmsResetEvent",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag},
			MetadataInfo: &MetadataInfo{
				Description: "Data associated to a reset event for a EBPMS asset",
				Frequency:   FrequencyCustom("Uploaded on customer indicated reset events"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ebpms_reset_event.reset_effective_at_ms": "Timestamp of the customer indicated reset event, brake performance values will begin calculating from this timestamp",
					"value.proto_value.ebpms_reset_event.user_id":               "User id of the customer who initiated the reset event",
					"value.proto_value.ebpms_reset_event.reset_reason":          "Reason for the reset event (maintenance, inspection, roller brake test, etc.)",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEbpmsSignalAvailability,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Bitmap indicating what EBPMS required signals were seen during a disagnostic session",
				Frequency:           FrequencyCustom("Updated on change as new signals are seen and at shutdown"),
				IntValueDescription: metadatahelpers.EnumDescription("Bitmask indicating which signals were seen", brakemonitoringproto.EbpmsSignalAvailable_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEbpSpeedCorrectionFactorMilliRatio,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Correction factor for converting EBS reported wheel speed to true speed, based on correlating GPS speed/or another trustworthy source to EBS wheel speed",
				Frequency:           FrequencyCustom("Once per power cycle and on change of greater than 1%"),
				IntValueDescription: "Correction factor in MilliRatio for converting EBS reported wheel speed to true speed, based on correlating GPS speed/or another trustworthy source to EBS wheel speed",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEbsLoadPlateInfo,
			BinaryMessageField: "EbsLoadPlateInfo",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag},
			MetadataInfo: &MetadataInfo{
				Description: "Data associated to a specific asset in regards to the affixed load plate and the EBS's operating criteria",
				Frequency:   FrequencyCustom("Uploaded once per power cycle"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ebs_load_plate_info.axle_load.axle_load_io.unladen_pressure_millibar": "The suspension pressure at which point it considered unladen",
					"value.proto_value.ebs_load_plate_info.axle_load.axle_load_io.laden_pressure_millibar":   "The suspension pressure at which point it considered laden",
					"value.proto_value.ebs_load_plate_info.axle_load.axle_load_io.unladen_axle_weight_kg":    "The corresposing axle weight at that suspension pressure point when unladen",
					"value.proto_value.ebs_load_plate_info.axle_load.axle_load_io.laden_axle_weight_kg":      "The corresposing axle weight at that suspension pressure point when laden",
					"value.proto_value.ebs_load_plate_info.brake_press_io.demand_press_millibar":             "The demand pressure breakpoint (input) for use to convert the input pressure to output pressure",
					"value.proto_value.ebs_load_plate_info.brake_press_io.laden_output_press_millibar":       "The output pressure for the associated demand pressure when fully laden",
					"value.proto_value.ebs_load_plate_info.brake_press_io.unladen_press_defined":             "If the unladen output pressure is available/valid",
					"value.proto_value.ebs_load_plate_info.brake_press_io.unladen_output_press_millibar":     "The output pressure for the associated demand pressure when fully unladen",
					"value.proto_value.ebs_load_plate_info.max_input_pressure_millibar":                      "The maximum input pressure for the system",
					"value.proto_value.ebs_load_plate_info.onset_pressure_millibar":                          "The pressure at whichpoint braking will actually commence",
					"value.proto_value.ebs_load_plate_info.brake_calc_number":                                "The brake calculation number programmed into the EBS",
					"value.proto_value.ebs_load_plate_info.trailer_model":                                    "The trailer type as programmed into the EBS",
					"value.proto_value.ebs_load_plate_info.chassis_number":                                   "The Chassis number as programmed into the EBS",
					"value.proto_value.ebs_load_plate_info.trailer_manufacturer":                             "The trailer manufacturer as programmed into the EBS",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEcuBatteryVoltage,
			BinaryMessageField: "EcuBatteryVoltage",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AG52Tag, amundsentags.AssetsTag, amundsentags.MarathonTag},
			MetadataInfo: &MetadataInfo{
				Description: "The battery voltage reported by an ECU on the network ",
				Frequency:   FrequencyCustom("Reports when ECU Battery voltage changes a specific amount or every minute whichever comes first"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ecu_battery_voltage.voltage_milliv":  "Battery voltage as reported by an ECU",
					"value.proto_value.ecu_battery_voltage.ecu_id":          "Network ID of the sending node",
					"value.proto_value.ecu_battery_voltage.protocol_source": "Network protocol the data was collected over",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEcuComponentId,
			BinaryMessageField: "EcuComponentId",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AG52Tag, amundsentags.AssetsTag, amundsentags.MarathonTag},
			MetadataInfo: &MetadataInfo{
				Description: "Component ID of ECUs on the network",
				Frequency:   FrequencyOnChange("Reports when Component ID updates or more ECus communicate on the network"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ecu_component_id.make":            "Make of the ECU",
					"value.proto_value.ecu_component_id.model":           "Model of the ECU",
					"value.proto_value.ecu_component_id.serial_number":   "SN of the ECU",
					"value.proto_value.ecu_component_id.unit_number":     "Unit number",
					"value.proto_value.ecu_component_id.has_unit_number": "If the unit number was available (J1587 does not have it but J1939 does)",
					"value.proto_value.ecu_component_id.ecu_id":          "Network ID of the sending node",
					"value.proto_value.ecu_component_id.protocol_source": "Protocol source used to collect data",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEcuFuelLevelMillipercent,
			BinaryMessageField: "EcuFuelLevelStats",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Detailed stats regarding ECU fuel level sources",
				Frequency:   FrequencyEveryXSeconds(60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.latest_fuel_level_millipercent":           "Latest fuel level of this source in millipercent seen during the log interval",
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.min_fuel_level_millipercent":              "Minimum fuel level of this source in millipercent seen during the log interval",
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.max_fuel_level_millipercent":              "Maximum fuel level of this source in millipercent seen during the log interval",
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.mean_fuel_level_millipercent":             "Mean fuel level of this source in millipercent seen during the log interval",
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.count_seen":                               "Number of times this source was seen during the log interval",
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.fuel_level_method":                        metadatahelpers.EnumDescription("Fuel method used for percentage", hubproto.EcuFuelLevelStats_EcuFuelLevel_FuelLevelMethod_name),
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.fuel_level_source.vehicle_diagnostic_bus": metadatahelpers.EnumDescription("Vehicle diagnostic bus", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.fuel_level_source.ecu_id":                 "ECU ID of this fuel level source",
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.fuel_level_source.msg_id":                 "Message ID of this fuel leve source",
					"value.proto_value.ecu_fuel_level_stats.ecu_fuel_levels.fuel_level_source.obd_protocol":           metadatahelpers.EnumDescription("Obd Protocol", hubproto.ObdProtocol_name),
					"value.proto_value.ecu_fuel_level_stats.metadata.configured_log_interval_ms":                      "Configured log interval for stat",
					"value.proto_value.ecu_fuel_level_stats.metadata.configured_fuel_tank_volume_ml":                  "A configurable value set in the backend to indicate tank size to derive fuel percent from the fuel remaining obd value",
					"value.proto_value.ecu_fuel_level_stats.metadata.actual_log_interval_ms":                          "Actual log interval that elapsed before stat was logged",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEcuHistoryTotalRunTimeSec,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         metadatahelpers.DeprecatedDescription("ECU history total run time (secs)"),
				Frequency:           FrequencyCustom("deprecated"),
				IntValueDescription: "Total historical ECU run time. J1939 PGN 65201, SPN 1033 ECU run time",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEcuSoftwareId,
			BinaryMessageField: "EcuSoftwareId",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag},
			MetadataInfo: &MetadataInfo{
				Description: "The reported Software id from ECU(s) on the network",
				Frequency:   FrequencyCustom("Once per power cycle"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ecu_software_id.software_id": "Software id reported by the node ",
					"value.proto_value.ecu_software_id.ecu_id":      "ECU ID used by reported node",
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDEdgeSpeedLimit, // deprecated, switch to osDEdgeSpeedLimitV2
			BinaryMessageField:       "EdgeSpeedLimit",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			MetadataInfo: &MetadataInfo{
				Description: metadatahelpers.DeprecatedDescription("Please use osDEdgeSpeedLimitV2"),
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDEdgeSpeedLimitV2,
			BinaryMessageField:       "EdgeSpeedLimit",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
			ksFieldsToExclude: []string{
				// Exclude layers because of a bug in LayeredTileManager causing empty layers to have garbage data in the server_last_modified field, preventing replication.
				"value.proto_value.edge_speed_limit.current_tile_info.layers",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEldEngineMilliknotsDebugOnly,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Reports the engine speed in milliknots for ELD purposes. Used for debugging functionality.",
				Frequency:           FrequencyCustom("Reported every 1 second, on 3mph delta"),
				IntValueDescription: "Engine speed in milliknots",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEldEvent,
			BinaryMessageField: "EldEvents",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports ELD events generated on VG as per ELD mandate",
				Frequency:   FrequencyCustom("Generated when the event occurs on the vehicle. There is a predefined list of event types that are reported, but they don't have a fixed frequency."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.eld_events.type":                               "The domain type of ELD event that occurred",
					"value.proto_value.eld_events.records":                            "The ELD event records associated with the event",
					"value.proto_value.eld_events.exemption_declarations":             "The ELD exemption declarations associated with the event",
					"value.proto_value.eld_events.prompt_lifecycle_changes":           "The ELD prompt lifecycle changes associated with the event",
					"value.proto_value.eld_events.team_driving_configuration_changes": "The ELD team driving configuration changes associated with the event",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEldOdometerLatestExpired,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Firmware ELD odometer stored reading removed",
				Frequency:           FrequencyCustom("Reported on ELD odometer value being cleared"),
				IntValueDescription: "The value, in meters, of the ELD odometer stored on device that has been cleared. ELD odometer is stored on device to understand what was reported in a previous diagnostic session to avoid reporting jumps in value.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEldOdometerMeters,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current vehicle odometer distance for ELD purposes (m)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Odometer value, in meters, currently being read from the vehicle",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(32),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEngineActivity,
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			BinaryMessageField: "DiagnosticFeatureData",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine activity determined by engine activity feature in the OBD package. Engine activity is used to determine engine state",
				Frequency:           FrequencyCustom("Generated on change and every x seconds, where x is configurable but 15 seconds by default"),
				IntValueDescription: "Defined in FeatureMethodStates enum - TRUE (active), FALSE (inactive), UNKNOWN",
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_feature_data.obd_value":             metadatahelpers.EnumDescription("Engine activity method in use to determine engine activity.", hubproto.ObdValue_name),
					"value.proto_value.diagnostic_feature_data.method_data.value":     "FeatureMethodsStates value TRUE, FALSE, UNKNOWN of lower priority methods, just for debugging.",
					"value.proto_value.diagnostic_feature_data.method_data.obd_value": metadatahelpers.EnumDescription("Lower priority engine activity method, just for debugging.", hubproto.ObdValue_name),
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEngineActivityMethod,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Simple reporting of engine activity method in use to determine engine activity, which is used to determine engine state.",
				Frequency:           FrequencyCustom("Generated on change and every 5 mins by default and no faster than 30 seconds (configurable)"),
				IntValueDescription: metadatahelpers.EnumDescription("Engine activity method in use to determine engine activity.", hubproto.ObdValue_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEngineFault,
			BinaryMessageField: "VehicleFaultEvent",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Passenger and heavy duty vehicle faults",
				Frequency:   FrequencyOnChange("reported as vehicle faults appear"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.vehicle_fault_event.j1939_faults": "List of heavy duty vehicle faults derived from PGN DM1, which are currently active diagnostic trouble codes. J1939-73 for more information.",

					"value.proto_value.vehicle_fault_event.j1939_faults.tx_id":               "Vehicle ECU address sending faults",
					"value.proto_value.vehicle_fault_event.j1939_faults.mil_status":          "Malfunction Indicator Lamp (MIL). A lamp used to relay only emissions-related trouble code information. This lamp is only illuminated when there is an emission-related trouble code active. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.red_lamp_status":     "Flash Red Stop Lamp (RSL). This lamp is used to relay trouble code information that is of a severe enough condition that it warrants stopping the vehicle. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.amber_lamp_status":   "Flash Amber Warning Lamp (AWL) This parameter provides the capability to flash the AWL. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.protect_lamp_status": "Flash Protect Lamp (FPL). This parameter provides the capability to flash the protect lamp. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.spn":                 "Suspect Parameter Number. This 19-bit number is used to identify the item for which diagnostics are being reported. The SPN is used for multiple purposes, some of those that are specific to diagnostics are: 1. to identify a least repairable subsystem that has failed; 2. to identify subsystems and or assemblies that may not have hard failures but may be exhibiting abnormal operating performance; 3. identifying a particular event or condition that will be reported; and 4. to report a component and non-standard failure mode. SPNs are assigned to each individual parameter in a Parameter Group and to items that are relevant to diagnostics but are not a parameter in a Parameter Group. SPNs are independent of the source address for the message. However, the source address may be necessary to determine which controller on the network performed the diagnosis. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.fmi":                 "Failure Mode Identifier The FMI defines the type of failure detected in the subsystem identified by an SPN. Note that the failure may not be an electrical failure but may instead be a subsystem failure or condition needing to be reported to the service technician and maybe also to the operator. Conditions can include system events or status that need to be reported. The FMI, SPN, SPN Conversion Method and Occurrence Count fields combine to form a given diagnostic trouble code. The currently defined FMIs are listed in APPENDIX A. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.occurance_count":     "Times this fault was seen",

					"value.proto_value.vehicle_fault_event.j1939_faults.backend_only_j1939_fault_data.fmi_description":               "Failure mode identifier description. Firmware only reports the raw FMI code, the backend decodes the FMI value to a description. J1939-73 contains the descriptions in Appendix A.",
					"value.proto_value.vehicle_fault_event.j1939_faults.backend_only_j1939_fault_data.dtc_description":               "Diagnostic trouble code description. Firmware only uploads the raw DTC codes, the backend has the translations for all DTCs.",
					"value.proto_value.vehicle_fault_event.j1939_faults.backend_only_j1939_fault_data.volvo_repair_instructions_url": "Volvo integration for repair help.",
					"value.proto_value.vehicle_fault_event.j1939_faults.fault_protocol_source":                                       "The source of the J1939 fault (J1939 or ISO27145).",

					"value.proto_value.vehicle_fault_event.passenger_faults":                "List of J1979 sourced emissions related diagnostic faults. J1979 implements J2012 for diagnostic faults for passenger vehicles.",
					"value.proto_value.vehicle_fault_event.passenger_faults.tx_id":          "Vehicle ECU address sending faults",
					"value.proto_value.vehicle_fault_event.passenger_faults.mil_status":     "The malfunctioning indicator lamp (MIL) is used to report trouble codes that are emissions related. Trouble codes that are not emissions related will not illuminate the MIL.The MIL status shall indicate OFF during the key-on, engine-off functional bulb check or while indicating I/M readiness unless the MIL has also been commanded ON for a detected malfunction. The ON status shall reflect whether there are any confirmed DTCs stored that are currently illuminating the MIL and, at the option of the manufacturer, any pending DTCs that are currently blinking or illuminating the MIL (e.g. catalyst damaging misfire). J1979 EE Diagnostic Test Modes, J2012",
					"value.proto_value.vehicle_fault_event.passenger_faults.dtcs":           "4 byte value that identifies the kind of trouble, the associated failure mode and its occurrence count. J1979 2016",
					"value.proto_value.vehicle_fault_event.passenger_faults.pending_dtcs":   "Pending codes (also known as continuous monitor codes) will be registered when an intermittent fault occurs. If that fault does not happen again after x number of start/stop cycles, the ECU will erase the code from memory. If the fault is persistent it becomes a DTC",
					"value.proto_value.vehicle_fault_event.passenger_faults.permanent_dtcs": "The purpose of this service is to enable the external test equipment to obtain all DTCs with permanent DTC status. These are DTCs that are confirmed and are retained in the non-volatile memory of the server until the appropriate monitor for each DTC has determined that the malfunction is no longer present and is not commanding the MIL on. J1939-73",
					"value.proto_value.vehicle_fault_event.passenger_faults.monitor_status": `There are two different types of readiness monitors: continuous and non-continuous. Continuous monitors are different in design from the non-continuous ones. Continuous monitors are being constantly tested and evaluated while the engine is running. The non-continuous monitors need certain conditions to be met before a test can be completed. Readiness monitor test result yields the monitor status. Each readiness monitor will have its own output status. The completion status can be:

		Complete or ready meaning that the test has been completed. It means that the OBD-II system has checked this emissions control system and it has passed the test. OBD Auto Doctor indicates this by green check mark.

    Incomplete or not ready meaning the test is not completed. It means that the OBD2 system has not been able to run this routine or it has failed. OBD Auto Doctor indicates this by red exclamation mark.

    Disabled meaning that the test has been disabled for the rest of this monitoring cycle. A monitor can be disabled when there is no easy way for the driver to operate the vehicle to allow the monitor to run. For example, the ambient air temperature might be too low or too high.
`,
					"value.proto_value.vehicle_fault_event.passenger_faults.ignition_type":                        "Contained as part of the monitor status, this field is 0 for spark ignition monitors, and 1 for compression ignition. Note that electric vehicles do not need to follow these emissions related standards.",
					"value.proto_value.vehicle_fault_event.passenger_faults.mil_valid":                            "True if the mil field is valid",
					"value.proto_value.vehicle_fault_event.passenger_faults.dtcs_valid":                           "True if the dtcs field is valid",
					"value.proto_value.vehicle_fault_event.passenger_faults.pending_dtcs_valid":                   "True if mil field is valid.",
					"value.proto_value.vehicle_fault_event.passenger_faults.permanent_dtcs_valid":                 "True if permanent_dtcs field is valid",
					"value.proto_value.vehicle_fault_event.passenger_faults.monitor_status_valid":                 "True if monitor_status field is valid",
					"value.proto_value.vehicle_fault_event.passenger_faults.ignition_type_valid":                  "True if ignition_type field is valid.",
					"value.proto_value.vehicle_fault_event.passenger_faults.fault_protocol_source":                "The source of the passenger fault (J1979 or ISO27145).",
					"value.proto_value.vehicle_fault_event.passenger_faults.dtcs_with_severity_and_class":         "List of DTCs, same as in dtcs field, but with severity and class info parsed from severityMask byte",
					"value.proto_value.vehicle_fault_event.passenger_faults.pending_dtcs_with_severity_and_class": "List of pending DTCs, same as in pending_dtcs field, but with severity and class info parsed from severityMask byte",

					"value.proto_value.vehicle_fault_event.j1587_faults.tx_id":                             "Vehicle ECU address sending faults",
					"value.proto_value.vehicle_fault_event.j1587_faults.trailer_abs_fault_lamp_status":     "Fault Lamp status for the trailer Antilock brake system",
					"value.proto_value.vehicle_fault_event.j1587_faults.fault_protocol_source":             "What the network source was that populated the J1587 fault event",
					"value.proto_value.vehicle_fault_event.j1587_faults.fault_codes_valid":                 "If the fault code field has valid data",
					"value.proto_value.vehicle_fault_event.j1587_faults.j1587_fault_codes.id":              "The fault id of the fault (PID (parameter id) or SID (subsystem id))",
					"value.proto_value.vehicle_fault_event.j1587_faults.j1587_fault_codes.is_pid":          "Denotes if the id field is a PID or SID",
					"value.proto_value.vehicle_fault_event.j1587_faults.j1587_fault_codes.fmi":             "Failure Mode Identifier The FMI defines the type of failure detected in the system identified by the PID or SID.",
					"value.proto_value.vehicle_fault_event.j1587_faults.j1587_fault_codes.occurance_count": "The number of times the conditions were met to trigger the fault",
					"value.proto_value.vehicle_fault_event.j1587_faults.j1587_fault_codes.active":          "Denotes if the fault code is currently active or inactive",

					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.manufacturer":                       metadatahelpers.EnumDescription("The manufacturer designation for the fault codes uploaded", hubproto.ObjectStatBinaryMessage_VehicleFaultEvent_ProprietaryProtocolFault_Manufacturer_name),
					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.ecu_id":                             "The ECU id of the node sending the data",
					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.red_warning_lamp":                   metadatahelpers.EnumDescription("The status of the red warning lamp", hubproto.ObjectStatBinaryMessage_VehicleFaultEvent_ProprietaryProtocolFault_LampStatus_name),
					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.amber_warning_lamp":                 metadatahelpers.EnumDescription("The status of the amber warning lamp", hubproto.ObjectStatBinaryMessage_VehicleFaultEvent_ProprietaryProtocolFault_LampStatus_name),
					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.time_since_last_rx_sec":             "The amount of time since we recicved the fault code message",
					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.fault.fault_code.dtc":               "A singular numeric value fault code",
					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.fault.fault_code.spn_fmi_fault.spn": "Suspect parameter number of the SPN FMI fault type",
					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.fault.fault_code.spn_fmi_fault.fmi": "Failure Mode identifier of the SPN FMI fault type",
					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.fault.fault_code_status":            metadatahelpers.EnumDescription("The status of the fault code", hubproto.ObjectStatBinaryMessage_VehicleFaultEvent_ProprietaryProtocolFault_Fault_FaultCodeStatus_name),
					"value.proto_value.vehicle_fault_event.proprietary_protocol_faults.fault.fault_code_type":              metadatahelpers.EnumDescription("The Fault code type used to denote what field will be populated", hubproto.ObjectStatBinaryMessage_VehicleFaultEvent_ProprietaryProtocolFault_Fault_FaultCodeType_name),
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDEngineGauge,
			BinaryMessageField:       "EngineGaugeEvent",
			Kind:                     StatKindObjectStat,
			DataModelStat:            true,
			Production:               true,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			Tags:                     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Instrument cluster values",
				Frequency:   FrequencyEveryXSeconds(2 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.engine_gauge_event.air_temp_milli_c":               "Ambient Air Temperature. Temperature of air surrounding vehicle. J1939-DA SPN 171. J1979 Service 01 PID 46.",
					"value.proto_value.engine_gauge_event.barometer_pa":                   "Barometric Pressure. Absolute air pressure of the atmosphere. J1939-DA SPN 108. J1979 Service 01 PID 33.",
					"value.proto_value.engine_gauge_event.battery_milli_v":                "Battery Potential / Power Input 1. This parameter measures the first source of battery potential as measured at the input of the ECU/actuator etc. coming from one or more batteries, irrespective of the distance between the component and the battery.  This SP is also used when ECUs are interconnected in a series configuration, where the source of power is coming directly or indirectly from the same battery/batteries. If more than one battery is included in the first set of batteries and the potential for each battery is desired, then SPNs 7902, 7910, 7918, & 7926 shall be used. J1939-DA SPN 168. J1979 Service 01, PID 42.",
					"value.proto_value.engine_gauge_event.coolant_temp_milli_c":           "Engine Coolant Temperature. Temperature of liquid found in engine cooling system. J1939-DA SPN 110. J1979 Service 01, PID 05.",
					"value.proto_value.engine_gauge_event.engine_on_secs":                 "Current engine on time since ignition. Only reported on passenger vehicles. J1979 Service 01, PID 1F",
					"value.proto_value.engine_gauge_event.engine_load_percent":            "Engine Percent Load At Current Speed. The ratio of actual engine percent torque (indicated) to maximum indicated torque available at the current engine speed, clipped to zero torque during engine braking. J1939-DA PGN 61443 (EEC2), SPN 92. J1979 Service 01, PID 04.",
					"value.proto_value.engine_gauge_event.fuel_level_percent":             "Fuel Level 1. Ratio of volume of fuel to the total volume of fuel storage container. When Fuel Level 2 (SPN 38) is not used, Fuel Level 1 represents the total fuel in all fuel storage containers.  When Fuel Level 2 is used, Fuel Level 1 represents the fuel level in the primary or left-side fuel storage container. J1939-DA PGN 65276 (Dash Display), SPN 96. J1979 Service 01, PID 2F.",
					"value.proto_value.engine_gauge_event.fuel_temp_milli_c":              "Engine Fuel 1 Temperature 1. Temperature of fuel (or gas) of the first fuel type. See SPN 3468 for a second temperature measurement of the first fuel type. J1939-DA, PGN 65262 (Engine Temperature 1), SPN 174. Not reported on passenger vehicles.",
					"value.proto_value.engine_gauge_event.mnfld_temp_milli_c":             "Manifold surface temperature. Only reported on passenger vehicles. J1979 Service 01 PID 84.",
					"value.proto_value.engine_gauge_event.oil_pressure_k_pa":              "Engine Oil Pressure 1. Gage pressure of oil in engine lubrication system as provided by oil pump.  See SPN 7468 for alternate resolution. J1939-DA PGN 65263 (Engine Fluid Level/Pressure 1), SPN 100. Not reported on passenger vehicles.",
					"value.proto_value.engine_gauge_event.engine_rpm":                     "Engine Speed. Actual engine speed which is calculated over a minimum crankshaft angle of 720 degrees divided by the number of cylinders. J1939-DA PGN 61444 (Electronic Engine Controller 1) [EEC1], SPN 190. J1979 Service 01 PID 0C.",
					"value.proto_value.engine_gauge_event.odometer_meters":                "Total Vehicle Distance. Accumulated distance traveled by the vehicle during its operation. Sourced from high or low resolution odometer sources, depending on the vehicle. J1939-DA SPN 917 (high resolution) or SPN 245 (low resolution). J1979 Serivce 01 PID A6, high resolution only on most passenger vehicles.",
					"value.proto_value.engine_gauge_event.fuel_economy_meters_per_k_g":    "Engine Instantaneous Fuel Economy. Current fuel economy at current vehicle velocity. J1939-DA PGN 65266 (Fuel Economy (Liquid)) [LFE1], SPN 184. Not reported on passenger vehicles.",
					"value.proto_value.engine_gauge_event.engine_hours_secs":              metadatahelpers.DeprecatedDefaultDescription,
					"value.proto_value.engine_gauge_event.tire_pressure_front_left_k_pa":  "Tire Pressure. Pressure at which air is contained in cavity formed by tire and rim. J1939-DA PGN 65268 (Tire Condition Message 1) [TIRE1], SPN 241. Used in combination with SPN 929 for tire location. Not standard on passenger vehicles.",
					"value.proto_value.engine_gauge_event.tire_pressure_front_right_k_pa": "Tire Pressure. Pressure at which air is contained in cavity formed by tire and rim. J1939-DA PGN 65268 (Tire Condition Message 1) [TIRE1], SPN 241. Used in combination with SPN 929 for tire location. Not standard on passenger vehicles.",
					"value.proto_value.engine_gauge_event.tire_pressure_back_left_k_pa":   "Tire Pressure. Pressure at which air is contained in cavity formed by tire and rim. J1939-DA PGN 65268 (Tire Condition Message 1) [TIRE1], SPN 241. Used in combination with SPN 929 for tire location. Not standard on passenger vehicles.",
					"value.proto_value.engine_gauge_event.tire_pressure_back_right_k_pa":  "Tire Pressure. Pressure at which air is contained in cavity formed by tire and rim. J1939-DA PGN 65268 (Tire Condition Message 1) [TIRE1], SPN 241. Used in combination with SPN 929 for tire location. Not standard on passenger vehicles.",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEngineImmobilizer,
			BinaryMessageField: "EngineImmobilizerStatus",
			Kind:               StatKindObjectStat,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEngineMilliknots,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current engine speed (mkn)",
				Frequency:           FrequencyOnChange("reported as frequently as speed data is validated"),
				IntValueDescription: "Current vehicle speed, reported in milliknots.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
					infraconsts.SamsaraAWSEURegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEngineOilLevelDeciPercent,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEngineOilTempMicroC,
			Kind:     StatKindObjectStat,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEngineRpm,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			BinaryMessageField: "EngineRpm",
			MetadataInfo: &MetadataInfo{
				Description: "Engine RPM",
				Frequency:   FrequencyEveryXSeconds(2 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.engine_rpm.last_value":       "The last reported engine rpm value",
					"value.proto_value.engine_rpm.period_max_value": "The max rpm value seen in the reported period",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEngineSeconds,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine runtime (s)",
				Frequency:           FrequencyOnChange("reported after every 3 mintues of engine ontime accumulated"),
				IntValueDescription: "Accumulated time of operation of engine.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEngineState,
			BinaryMessageField: "EngineState",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine runtime (s)",
				Frequency:           FrequencyOnChange("reported as frequently as speed data is validated"),
				IntValueDescription: metadatahelpers.EnumDescription("Current engine state", logeventproto.LogEvent_ObdEvent_EngineEvent_EngineState_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.engine_state.offset_ms":                             "The amount of time it took to go into the current device state. For example, we only consider an engine idle after 2 minutes has passed on the firmware where speed is 0 but engine rpm is non-zero. On the backend, the 2 minutes is used to note that the firmware first recognized the idle state before the timestamp of the objectstat. This is mainly used for reporting purposes.",
					"value.proto_value.engine_state.offset_type":                           metadatahelpers.EnumDescription("Type of vehicle event the offset_ms is associated with.", hubproto.ObjectStatBinaryMessage_EngineState_EngineStateOffsetType_name),
					"value.proto_value.engine_state.has_read_movement_this_session":        "Whether or not a movement source has been read by the engine state logger during this OBD session.",
					"value.proto_value.engine_state.movement_requirement_for_idle_enabled": "Whether or not a movement source is required for the engine state logger to consider the engine IDLE.",
					"value.proto_value.engine_state.has_valid_cached_movement":             "Whether or not a movement source has been read by the engine state logger either this session or from the cache.",
					"value.proto_value.engine_state.engine_activity_internal_feature_used": "Whether we consider the engine activity feature when determining the engine state",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				UseTieredSchedule:  true,
				HourlyCronSchedule: true,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEngineStateLogOnly,
			BinaryMessageField: "EngineState",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine on, off, or idle LOG ONLY. To be used when validating a different version of engine state reporting in firmware.",
				Frequency:           FrequencyOnChange("Reported when state changes"),
				IntValueDescription: metadatahelpers.EnumDescription("Current engine state", logeventproto.LogEvent_ObdEvent_EngineEvent_EngineState_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.engine_state.offset_ms":                             "The amount of time it took to go into the current device state. For example, we only consider an engine idle after 2 minutes has passed on the firmware where speed is 0 but engine rpm is non-zero. On the backend, the 2 minutes is used to note that the firmware first recognized the idle state before the timestamp of the objectstat. This is mainly used for reporting purposes.",
					"value.proto_value.engine_state.offset_type":                           metadatahelpers.EnumDescription("Type of vehicle event the offset_ms is associated with.", hubproto.ObjectStatBinaryMessage_EngineState_EngineStateOffsetType_name),
					"value.proto_value.engine_state.has_read_movement_this_session":        "Whether or not a movement source has been read by the engine state logger during this OBD session.",
					"value.proto_value.engine_state.movement_requirement_for_idle_enabled": "Whether or not a movement source is required for the engine state logger to consider the engine IDLE.",
					"value.proto_value.engine_state.has_valid_cached_movement":             "Whether or not a movement source has been read by the engine state logger either this session or from the cache.",
					"value.proto_value.engine_state.engine_activity_internal_feature_used": "Whether we consider the engine activity feature when determining the engine state",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEngineTotalFuelUsedMilliLiters,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEngineTotalIdleFuelUsedMilliLiters,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEngineTotalIdleTimeMinutes,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Total engine idle time as reported by the vehicle's ECU",
				Frequency:           FrequencyCustom("Frequency varies by vehicle manufacturer"),
				IntValueDescription: "Total accumulated engine lifetime idle time in minutes. This stat is only available on vehicles that support reporting total idle time through their diagnostic protocols.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEquipmentActivity,
			BinaryMessageField: "EquipmentActivity",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Indicates if Heavy Equipment is On. Triggers engine based trips",
				Frequency:   FrequencyEveryXSeconds(10 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.equipment_activity.state": metadatahelpers.EnumDescription("Equipment Activity", hubproto.EquipmentActivity_State_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEquipmentActivityInputDebug,
			BinaryMessageField: "EquipmentActivityInputDebug",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Debug information about the equipment activity input. This debug stat includes the current state of equipment activity, all input signals, the last update time for each input, and potential input sources.",
				Frequency:   FrequencyOnChange("This stat is updated whenever any of the input signals change."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.equipment_activity_input_debug.equipment_state":                     "The current state of the equipment activity.",
					"value.proto_value.equipment_activity_input_debug.equipment_last_update_age_ms":        "The age of the equipment activity state last change in ms at the time of the stat.",
					"value.proto_value.equipment_activity_input_debug.obd_engine_state":                    "The current state of the OBD engine.",
					"value.proto_value.equipment_activity_input_debug.obd_engine_last_update_age_ms":       "The age of the OBD engine state last change in ms at the time of the stat.",
					"value.proto_value.equipment_activity_input_debug.aux_input_signal_enabled":            "Whether the auxiliary input signal is enabled.",
					"value.proto_value.equipment_activity_input_debug.aux_input_signal_state":              "The current state of the auxiliary input signal.",
					"value.proto_value.equipment_activity_input_debug.aux_input_signal_last_update_age_ms": "The age of the auxiliary input signal state last change in ms at the time of the stat.",
					"value.proto_value.equipment_activity_input_debug.voltage_fft_state":                   "The current state of the voltage spectrum FFT algorithm.",
					"value.proto_value.equipment_activity_input_debug.voltage_fft_last_update_age_ms":      "The age of the voltage spectrum FFT algorithm state last change in ms at the time of the stat.",
					"value.proto_value.equipment_activity_input_debug.movement_state":                      "The current state of the movement.",
					"value.proto_value.equipment_activity_input_debug.movement_last_update_age_ms":         "The age of the movement state change in ms at the time of the stat.",
					"value.proto_value.equipment_activity_input_debug.vibration_state":                     "The current state of the vibration.",
					"value.proto_value.equipment_activity_input_debug.vibration_last_update_age_ms":        "The age of the vibration state last change in ms at the time of the stat.",
					"value.proto_value.equipment_activity_input_debug.always_on_enabled":                   "Whether the always on feature is enabled.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEquipmentRPMProductivitySeconds,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{},
			MetadataInfo: &MetadataInfo{
				Description:         "Productivity as measured by RPM being above threshold",
				Frequency:           FrequencyEveryXSeconds(60 * 60),
				IntValueDescription: "Number of productive seconds (based on RPM being above asset threshold). Missing value indicates no productive seconds recorded",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEv24VoltDcDcInverterCurrentMilliAmps,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle 24 DC/DC inverter output current (mA)",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "EV high 24 DC/DC inverter output current in milli-amps.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvAverageCellTemperatureMilliCelsius,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity average battery cell temperature (mC)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "EV high capacity battery average cell temperature in milli-celcius. Note that this is not supported via J1979 and requires passenger vehicles to be onboarded.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEvBatteryEqualizationState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.MarathonTag, amundsentags.AssetsTag, amundsentags.AG53Tag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "EV Battery Equalization State",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: metadatahelpers.EnumDescription("The Current discrete state of the battery equalization state reported every 5 mins", hubproto.BatteryEqualizationState_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEvBatteryLifetimeDischargeAmpHours,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.MarathonTag, amundsentags.AssetsTag, amundsentags.AG53Tag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total Amp-Hours discharged from the assets battery",
				Frequency:           FrequencyCustom("Updated on Change but no faster than once every 60 seconds"),
				IntValueDescription: "Total Amp-Hours discharged from the assets battery",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEvBatteryTechnologyType,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.MarathonTag, amundsentags.AssetsTag, amundsentags.AG53Tag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "EV Battery Technology Type",
				Frequency:           FrequencyOnChange("Once per session and on change"),
				IntValueDescription: metadatahelpers.EnumDescription("The battery composition/technology type", hubproto.BatteryTechnologyType_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEvBatteryTotalCapacityMilliampHour,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Tags: []amundsentags.Tag{amundsentags.MarathonTag, amundsentags.AssetsTag, amundsentags.AG53Tag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "EV Battery Total Capacity",
				Frequency:           FrequencyOnChange("Once per session and on change"),
				IntValueDescription: "The total capacity of the battery",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEvBatteryWaterLevelState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.MarathonTag, amundsentags.AssetsTag, amundsentags.AG53Tag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "EV Battery Water Level State",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: metadatahelpers.EnumDescription("The Current discrete state of the battery water level reported every 5 mins", hubproto.BatteryWaterLevelState_name),
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvChargerMilliAmp,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle charging amps (mA)",
				Frequency:           FrequencyEveryXSeconds(10 * 60),
				IntValueDescription: "Instantaneous milliamp reading from the current charger status. This is reported as 0 every 10 minutes if there is no charging data available",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvChargerMilliVolt,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle charging voltage (mV)",
				Frequency:           FrequencyEveryXSeconds(10 * 60),
				IntValueDescription: "Instantaneous millivolt reading from the current charger status. This is reported as 0 every 10 minutes if there is no charging data available",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEvChargingEnergyMicroWh,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle energy accumulated while charging (uWh)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Micro watt-hours of energy accumulated while charging. This can be calculated a number of ways, but mainly: the charging status and the battery volts and current, or an accumulated amount of energy tracked by the vehicle. This is non-standard for passenger vehicles, but part of the more recent J1939 standards.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("energy accumulated", hubproto.ObdValue_name),
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvChargingErrorStatus,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle type of charging error from either the bus or the charger",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: metadatahelpers.EnumDescription("Current charging error", hubproto.EvChargingErrorState_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEvChargingStatus,
			Kind:               StatKindObjectStat,
			Production:         true,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			BinaryMessageField: "EvChargingStatusInfo",
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle charging status",
				Frequency:           FrequencyOnChange("charge status change while the vehicle is stationary"),
				IntValueDescription: metadatahelpers.EnumDescription("Current charging status", hubproto.EvChargingState_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ev_charging_status_info.speed_kmph":               "Vehicle speed km/h",
					"value.proto_value.ev_charging_status_info.charge_rate_kw":           "Battery Charging Rate Kw",
					"value.proto_value.ev_charging_status_info.battery_current_amps":     "Battery Charging Current Amps",
					"value.proto_value.ev_charging_status_info.monitoring_state":         metadatahelpers.EnumDescription("Current charging status", hubproto.EvChargingStatusInfo_MonitoringState_name),
					"value.proto_value.ev_charging_status_info.charge_in_progress_state": metadatahelpers.EnumDescription("Current charging status", hubproto.EvChargingState_name),
					"value.proto_value.ev_charging_status_info.charge_rate_state":        metadatahelpers.EnumDescription("Current charging status", hubproto.EvChargingState_name),
					"value.proto_value.ev_charging_status_info.battery_current_state":    metadatahelpers.EnumDescription("Current charging status", hubproto.EvChargingState_name),
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvChargingType,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Type of charger the EV is currently charging from.",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Type of charger the EV is currently charging from.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEvDistanceDrivenOnElectricPowerKm,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         metadatahelpers.DeprecatedDescription("Distance travelled on electric power (km)"),
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "The total distance driven on the current trip with only electric power. Odometer is typically used, and sums changes in odometer over times when RPM is 0. This may not accumulate correctly if the vehicle generates a synthetic RPM value. The RPM check is necessary in the case of hybrid electric vehicles, where its possible to travel part of a trip on electric, and another part on an ICE engine. RPM being zero implies the electric battery is solely in use. Replaced by osDEvDistanceDrivenOnElectricPowerMeters",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEvDistanceDrivenOnElectricPowerMeters,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Distance travelled on electric power (m)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "The total distance driven on the current trip with only electric power. Odometer is typically used, and sums changes in odometer over times when RPM is 0. This may not accumulate correctly if the vehicle generates a synthetic RPM value. The RPM check is necessary in the case of hybrid electric vehicles, where its possible to travel part of a trip on electric, and another part on an ICE engine. RPM being zero implies the electric battery is solely in use.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("distance driven", hubproto.ObdValue_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEvEnergyConsumedMicroWh,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle energy consumed while driving (uWh)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Micro watt-hours of energy used while driving. This can be calculated a number of ways, but mainly: the charging status and the battery volts and current, or an accumulated amount of energy tracked by the vehicle. This is non-standard for passenger vehicles, but part of the more recent J1939 standards.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("energy consumed", hubproto.ObdValue_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEventBasedRecordingSafetyEventsForClip,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "EventBasedRecordingSafetyEventsForClip",
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Safety events relevant to a clip saved to long term storage, related to event based recording",
				Frequency:   FrequencyCustom("Determined by when a clip is saved to long term storage"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.event_based_recording_safety_events_for_clip.clip_name":                                              "The name of the clip",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.type":                                     "The type of safety event",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.harsh_event":                              "The harsh event details",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.harsh_event.trigger_time_unix_ms":         "The time the harsh event was triggered in unix ms",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.harsh_event.harsh_accel_type":             "The type of harsh event",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.harsh_event.event_id":                     "The ID of the harsh event",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.harsh_event.gateway_id":                   "The ID of the gateway that triggered the harsh event",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.camera_button_press":                      "The camera button press details",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.camera_button_press.trigger_time_unix_ms": "The time the camera button press was triggered in unix ms",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.panic_button_press":                       "The panic button press details",
					"value.proto_value.event_based_recording_safety_events_for_clip.safety_events.panic_button_press.trigger_time_unix_ms":  "The time the panic button press was triggered in unix ms",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvHighCapacityBatteryMilliAmp,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity instantaneous battery current (mA)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Instantaneous EV high capacity battery current in milli-amps. Note that this is not supported via J1979 and requires passenger vehicles to be onboarded.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvHighCapacityBatteryMilliVolt,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity instantaneous battery voltage (mV)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Instantaneous EV high capacity battery voltage in milli-volts. Note that this is not supported via J1979 and requires passenger vehicles to be onboarded.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEvHighCapacityBatteryRemainingEnergyWh,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity total energy remaining (watt-hours)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Total energy remaining as reported by the vehicle. Note that this value increases or decreases based on usage",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvHighCapacityBatteryStateOfHealthMilliPercent,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity state of health (m%)",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "EV high capacity battery state of health in milli-percent. State of health refers to how much energy the batteries can hold compared to the initial capacity of the battery pack. Note that this is not supported via J1979 and requires passenger vehicles to be onboarded.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDeviceToDriverCards,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "DriverIdCards",
			MetadataInfo: &MetadataInfo{
				Description: "List of driver cards detected by a device in its vicinity",
				Frequency:   FrequencyEveryXSeconds(60),
				ColumnDescriptions: map[string]string{
					"object_id":                                    "Device ID",
					"value.time":                                   "Timestamp of the objectstat",
					"value.int_value":                              "The number of driver cards detected by the device in its vicinity",
					"value.proto_value.driver_id_cards":            "An array of driver cards detected by the device's receiver",
					"value.proto_value.driver_id_cards.id":         "Driver card ID",
					"value.proto_value.driver_id_cards.rssi_value": "RSSI (signal strength in dBm)",
					"value.proto_value.driver_id_cards.battery_mv": "Battery voltage of the driver card",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEvInstantaneousPowerWatts,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.MarathonTag, amundsentags.AssetsTag, amundsentags.AG53Tag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Instantaneous Power used by the asset",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Instantaneous Power used by the asset Positive for using energy, negative for regeneration",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvLastChargeAcWallEnergyConsumedWh,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvMaxAllowedStateOfChargeMilliPercent,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity maximum State of Charge allowed for operation",
				Frequency:           FrequencyCustom("Fixed value reported once per session"),
				IntValueDescription: "EV high capacity battery maximum allowed SoC in milli-percent",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvMaxCellTemperatureMilliCelsius,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity maximum battery cell temperature (mC)",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "EV high capacity battery maximum cell temperature in milli-celcius.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvMinAllowedStateOfChargeMilliPercent,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity minimum State of Charge allowed for operation",
				Frequency:           FrequencyCustom("Fixed value reported once per session"),
				IntValueDescription: "EV high capacity battery minimum allowed SoC in milli-percent",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvMinCellTemperatureMilliCelsius,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity minimum battery cell temperature (mC)",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "EV high capacity battery minimum cell temperature in milli-celcius.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDEvRawStateOfChargeMillipercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "EV high capacity battery remaining charge (%)",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "Debug value for the current unprocessed charge output",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDEvTotalEnergyRegeneratedWhileDrivingMicroWh,
			BinaryMessageField: "DiagnosticFeatureData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle energy accumulated through regeneration (uWh)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Micro watt-hours of energy accumulated while driving. This can be calculated a number of ways, but mainly: the charging status and the battery volts and current, or an accumulated amount of energy tracked by the vehicle. This is non-standard for passenger vehicles, but part of the more recent J1939 standards.",
				ColumnDescriptions:  metadatahelpers.DiagnosticFeatureDataColumns("energy accumulated", hubproto.ObdValue_name),
			},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDEvUsableStateOfChargeMilliPercent,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electric vehicle high capacity battery remaining charge (%)",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "Current vehicle reported charge remaining as a percent of total capacity.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDExhaustGasPressurePa,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Exhaust Pressure 1 (Pa)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Gage pressure of the exhaust gases as measured at the turbine intake of the turbocharger. This SP to be used for inline engines or exhaust bank 1 of multiple bank engines. See SPN 5749 for exhaust bank 2 and See SPN 6384 for alternate range and resolution. J1939-DA",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDExternalBrakeRequestReason,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "External Brake Request Reason",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "Reason for the Automated Emergency Braking System (AEBS) to request external braking.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFalkoConnected,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "FalkoConnected",
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Falko (samsara USB hub) connect event",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.falko_connected.serial_number":        "Serial number of the connected Falko USB hub.",
					"value.proto_value.falko_connected.firmware_version":     "Firmware version running on the connected Falko. The firmware versions are maintained by the firmware team.",
					"value.proto_value.falko_connected.product_option_bytes": "Falko product string is 'Vehicle Port Expander XXXX' which is 27 bytes (including null char). XXXX are the option bytes.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFillEvent,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "FillEvent",
			MetadataInfo: &MetadataInfo{
				Description: "Records a fill event of a container based on pre-defined configurations.",
				Frequency:   FrequencyCustom("Generated by the levelinferrer app based on incoming data from KinesisStats."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.fill_event.duration_milliseconds": "The duration of the fill event in milliseconds",
					"value.proto_value.fill_event.volume_milliliters":    "The volume of vessel contents in milliliters transported in the fill event",
					"value.proto_value.fill_event.mass_grams":            "The mass of vessel contents in grams transported in the fill event",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFillLevel,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "FillLevel",
			MetadataInfo: &MetadataInfo{
				Description:         "Records the inferred fill level of a container based on pre-defined configurations.",
				IntValueDescription: "Fill Percent",
				Frequency:           FrequencyCustom("Generated by the levelinferrer app based on incoming data from KinesisStats."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.fill_level.fill_millipercent":                     "The fill level of a vessel relative to its capacity",
					"value.proto_value.fill_level.fill_volume_milliliters":               "The volume of vessel contents in milliliters (only reported if the vessel is configured with a volume capacity)",
					"value.proto_value.fill_level.fill_mass_grams":                       "The mass of vessel contents in grams (only reported if the vessel is configured with a mass capacity)",
					"value.proto_value.fill_level.available_capacity_volume_milliliters": "Unused capacity of the vessel in milliliters (only reported if the vessel is configured with a volume capacity)",
					"value.proto_value.fill_level.available_capacity_mass_grams":         "Unused capacity of the vessel in grams (only reported if the vessel is configured with a mass capacity)",
					"value.proto_value.fill_level.criticality":                           metadatahelpers.EnumDescription("The status of the fill level based on user-defined thresholds", hubproto.FillLevelCriticality_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFillLevelChange,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "FillLevelChange",
			MetadataInfo: &MetadataInfo{
				Description: "Reports the fill level changes of a container",
				Frequency:   FrequencyCustom("Generated by the levelinferrer app based on incoming data from KinesisStats."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.fill_level_change.delta_mass_ingress_grams":         "The ingress mass in vessel contents compare to lastdatapoint in gram",
					"value.proto_value.fill_level_change.delta_mass_egress_grams":          "The egress mass in vessel contents compare to lastdatapoint in gram",
					"value.proto_value.fill_level_change.delta_volume_ingress_milliliters": "The ingress volume in vessel contents compare to lastdatapoint in milliliters",
					"value.proto_value.fill_level_change.delta_volume_egress_milliliters":  "The ingress volume in vessel contents compare to lastdatapoint in milliliters",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFillLevelSummary,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "FillLevelSummary",
			MetadataInfo: &MetadataInfo{
				Description: "Represents aggregate fill level stats over a window of time",
				Frequency:   FrequencyCustom("Generated by the levelinferrer app with frequency dependent on application-specific logic and on incoming raw data."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.fill_level_summary.primary.level.millipercent":       "Aggregated estimate of the relative fill level during the summarized window in thousands of percents",
					"value.proto_value.fill_level_summary.primary.level.mass_grams":         "Aggregated estimate of the absolute fill level during the summarized window in grams (only populated when capacity is specified as a mass)",
					"value.proto_value.fill_level_summary.primary.level.volume_milliliters": "Aggregated estimate of the absolute fill level during the summarized window in milliliters (only populated when capacity is specified as a volume)",

					"value.proto_value.fill_level_summary.primary.ingress.millipercent":       "Total estimated relative fill increase during the summarized window in thousands of percents",
					"value.proto_value.fill_level_summary.primary.ingress.mass_grams":         "Total estimated absolute fill increase during the summarized window in grams (only populated when capacity is specified as a mass)",
					"value.proto_value.fill_level_summary.primary.ingress.volume_milliliters": "Total estimated absolute fill increase during the summarized window in milliliters (only populated when capacity is specified as a volume)",

					"value.proto_value.fill_level_summary.primary.egress.millipercent":       "Total estimated relative fill decrease during the summarized window in thousands of percents",
					"value.proto_value.fill_level_summary.primary.egress.mass_grams":         "Total estimated absolute fill decrease during the summarized window in grams (only populated when capacity is specified as a mass)",
					"value.proto_value.fill_level_summary.primary.egress.volume_milliliters": "Total estimated absolute fill decrease during the summarized window in milliliters (only populated when capacity is specified as a volume)",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFirmwareMetrics,
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			BinaryMessageField: "FirmwareMetrics",
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Metrics reported by firmware and stored by the device",
				Frequency:   FrequencyCustom("Determined by device config firmware_metrics.report_interval_secs"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.firmware_metrics.build":                       "Current build running when the metrics were reported",
					"value.proto_value.firmware_metrics.product_name":                "Product name reported by firmware, typically config.public_product_name",
					"value.proto_value.firmware_metrics.hardware_version":            "Identifies the version of hardware on which the firmware is running",
					"value.proto_value.firmware_metrics.duration_ms":                 "The duration in ms over which the metrics were collected",
					"value.proto_value.firmware_metrics.metrics":                     "List of metrics collected",
					"value.proto_value.firmware_metrics.metrics.name":                "Name of the metric",
					"value.proto_value.firmware_metrics.metrics.metric_type":         metadatahelpers.EnumDescription("The metric type", hubproto.FirmwareMetrics_Metric_MetricType_name),
					"value.proto_value.firmware_metrics.metrics.value":               "The value of the metric, interpreted based on its type",
					"value.proto_value.firmware_metrics.metrics.tags":                "List of tags associated with this metric when it was reported",
					"value.proto_value.firmware_metrics.metrics.gauge_average_count": "The total number of samples which used to calculate the gauge average metric, whose usage is all_tags_value = sum(metric.value * metric.gauge_average_count for each metric) / sum(metric.gauge_average_count for each metric)",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDFirmwareTripState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Firmware trip state from gpsd for which the timestamp of the log is the trip state publish time. Note that the trip stop time precedes the trip state publisher publishing the off trip message by the trip dwell time duration.",
				Frequency:           FrequencyCustom("when the value changes or every 10 minutes"),
				IntValueDescription: "1 if on trip and 0 if off trip",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFluidLevel,
			BinaryMessageField: "FluidLevel",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the fluid level of a device",
				Frequency:   FrequencyCustom("Reported every 5 seconds"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.fluid_level.level":         "The current state of the fluid level sensor",
					"value.proto_value.fluid_level.start_time_ms": "The time the sensor entered its current state.",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDForwardLaneImagerStatus,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "State of the truck's embedded Forward Lane Imager",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "0: fully operational, 1: initializing, 2: partially blocked, 3: fully blocked, 4: misaligned, 5: view degraded, 6-13: reserved, 14: error",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFSMTransition,
			BinaryMessageField: "FsmTransition",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Tracks finite state machine transitions for device recovery, including the FSM name, from/to states, trigger events, and correlation information",
				Frequency:   FrequencyCustom("Logged when a state transition occurs in the device recovery FSM"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.fsm_transition.fsm_name":            "Name of the finite state machine (e.g., 'recovery', 'suspicion')",
					"value.proto_value.fsm_transition.from":                "State the FSM is transitioning from",
					"value.proto_value.fsm_transition.to":                  "State the FSM is transitioning to",
					"value.proto_value.fsm_transition.trigger":             "Event that triggered the state transition",
					"value.proto_value.fsm_transition.correlation_id":      "Unique identifier to correlate the transition to the object stat that triggered it",
					"value.proto_value.fsm_transition.correlation_time_ms": "Timestamp of the object stat that triggered the transition",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFuelConsumed,
			BinaryMessageField: "FuelConsumptionInfo",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Amount of liquid fuel consumed (ml)",
				Frequency:           FrequencyCustom("at least 1L of fuel being consumed"),
				IntValueDescription: "Amount of vehicle liquid fuel consumed. Vehicles support different methods for calculating fuel consumption. The method prioritization is configurable. The prioritization is a list of calculation methods ranked from high to low priority. The default priority order was decided based on the number of inputs required to calculate fuel consumption.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.fuel_consumption_info.tracking_method":                          "Fuel calculation used for reporting value. Fuel tracking methods are defined in objectstatproto.FuelTrackingMethod",
					"value.proto_value.fuel_consumption_info.fuel_tracker_infos.tracking_method":       "Fuel calculation used for reporting value. Fuel tracking methods are defined in objectstatproto.FuelTrackingMethod",
					"value.proto_value.fuel_consumption_info.fuel_tracker_infos.fuel_consumed_milli_l": "Amount of fuel consumed by the vehicle using the assoicated tracking_method",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFuelConsumedDebug,
			BinaryMessageField: "FuelConsumptionInfo",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.FuelTag, amundsentags.DebugTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Amount of liquid fuel consumed (ml)",
				Frequency:           FrequencyCustom("at least 1L of fuel being consumed"),
				IntValueDescription: "Amount of vehicle liquid fuel consumed. Vehicles support different methods for calculating fuel consumption. The method prioritization is configurable. The prioritization is a list of calculation methods ranked from high to low priority. The default priority order was decided based on the number of inputs required to calculate fuel consumption. Debug is only reported when a ranked fuel method is not available to report.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.fuel_consumption_info.tracking_method":                          "Fuel calculation used for reporting value. Fuel tracking methods are defined in objectstatproto.FuelTrackingMethod",
					"value.proto_value.fuel_consumption_info.fuel_tracker_infos.tracking_method":       "Fuel calculation used for reporting value. Fuel tracking methods are defined in objectstatproto.FuelTrackingMethod",
					"value.proto_value.fuel_consumption_info.fuel_tracker_infos.fuel_consumed_milli_l": "Amount of fuel consumed by the vehicle using the assoicated tracking_method",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFuelConsumedGaseous,
			BinaryMessageField: "FuelConsumptionInfo",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Amount of gaseous fuel consumed (grams)",
				Frequency:           FrequencyEveryXSeconds(2 * 60),
				IntValueDescription: "Amount of vehicle gaseous fuel consumed.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDFuelConsumptionRateMlPerHour,
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			BinaryMessageField: "FuelConsumptionInfo",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Liquid fuel consumption rate (ml/hr)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Liquid fuel consumption rate (ml/hr). This is primarly supported on passenger vehicles. Heavy duty vehicles typically report the total amount of fuel used",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDFuelDeliveryPressureKPa,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.IndustrialTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine fuel delivery pressure (kPa)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Gage pressure of fuel in system as delivered from supply pump to the injection pump. See SPN 7469 for alternate resolution. See also SPN 5578 for Fuel Delivery Absolute Pressure. J1939-DA",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDFuelLevel1DeciPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.IndustrialTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Fuel level 1 (%)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Ratio of volume of fuel to the total volume of fuel storage container. When Fuel Level 2 (SPN 38) is not used, Fuel Level 1 represents the total fuel in all fuel storage containers. When Fuel Level 2 is used, Fuel Level 1 represents the fuel level in the primary or left-side fuel storage container - J1939-DA. Only used by industrial, telematics surfaces fuel level percent in osDEngineGauge.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDFuelLevel2DeciPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.IndustrialTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Fuel level 2 (%)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Ratio of volume of fuel to the total volume of fuel in the second or right-side storage container.  When Fuel Level 2 is not used, Fuel Level 1 (SPN 96) represents the total fuel in all fuel storage containers - J1939-DA. Only used by industrial, telematics surfaces fuel level percent in osDEngineGauge. Telematics does not surface the secondary fuel tank level.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDFuelSensorResistorOhms,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Fuel sensor resistor value (Ohms)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Resistor value in ohms from the fuel sensor used to measure fuel levels in the vehicle tank.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDFuelType,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Vehicle fuel type",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Fuel types are defined in objectstatproto.FuelType. Supported on passenger and heavy duty vehicles. Passenger vehicles will typically use the fuel type for estimating fuel density. This is required for fuel tracking methods such as MAP and MAF.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDFunctionalRequestForService01Pid0,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Request from functional address (e.g. 0x7DF or 0x18DB33F1) for Service 01 PID 0 (PIDs supported [0x01-0x20]",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Value does not matter, just that stat was logged",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDFunctionalRequestForService01Pid0D,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Request from functional address (e.g. 0x7DF or 0x18DB33F1) for Service 01 PID 0D, ECU Speed",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Value does not matter, just that stat was logged",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDFunctionalRequestForService04,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Request from functional address (e.g. 0x7DF or 0x18DB33F1) for Service 04, Clear DTCs",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Value does not matter, just that stat was logged",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDFunctionalRequestForService07,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Request from functional address (e.g. 0x7DF or 0x18DB33F1) for Service 07, Show pending DTCs",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Value does not matter, just that stat was logged",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDFunctionalRequestForService09Pid08,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Request from functional address (e.g. 0x7DF or 0x18DB33F1) for Service 09 PID 08, In-use performance tracking for spark ignition vehicles",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Value does not matter, just that stat was logged",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDFunctionalRequestForService09Pid0B,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Request from functional address (e.g. 0x7DF or 0x18DB33F1) for Service 09 PID 0B, In-use performance tracking for compression ignition vehicles",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Value does not matter, just that stat was logged",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayMicroAccelEvent,
			BinaryMessageField: "GatewayMicroAccelEvent",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDGatewayMicroBackendConnectivity,
			BinaryMessageField:       "GatewayMicroBackendConnectivity",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDGatewayMicroConfig,
			BinaryMessageField:       "GatewayMicroConfig",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayMicroConfigUpdateAttempt,
			BinaryMessageField: "GatewayMicroConfigUpdateAttempt",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDGatewayMicroDiagnosticStatus,
			BinaryMessageField:       "GatewayMicroDiagnosticStatus",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayMicroGPSInstrumentation,
			BinaryMessageField: "GatewayMicroGpsInstrumentation",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDGatewayMicroLogBatchStats,
			BinaryMessageField:       "GatewayMicroLogBatchStats",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayMicroNetworkScan,
			BinaryMessageField: "GatewayMicroNetworkScan",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayMicroOTA,
			BinaryMessageField: "GatewayMicroOta",
			Kind:               StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayMicroResetReason,
			BinaryMessageField: "GatewayMicroResetReason",
			Kind:               StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDGatewayMicroTotalSelfDischargeMicroAmpsH,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayMicroWifiScan,
			BinaryMessageField: "GatewayMicroWifiScan",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayPlugged,
			BinaryMessageField: "GatewayPowerStateEvent",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "This stat indicates that a gateway plugged event occured for a specific vehicle.",
				Frequency:   FrequencyCustom("These stats are generated through processing of gateway power state stats."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.gateway_power_state_event.processed_at_ms": "Time where gateway was first plugged",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayUnplugged,
			BinaryMessageField: "GatewayPowerStateEvent",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "This stat indicates that a gateway unplugged event occured for a specific vehicle.",
				Frequency:   FrequencyCustom("These stats are generated through processing of gateway power state stats."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.gateway_power_state_event.processed_at_ms": "Time where gateway was first unplugged",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGatewayUpgradeAttempt,
			BinaryMessageField: "GatewayUpgradeAttempt",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGenericCameraCommandIssued,
			BinaryMessageField: "GenericCameraCommandIssued",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports data about an issued Generic Camera Command (request metadata, response, etc.)",
				Frequency:   FrequencyCustom("Every time a Generic Camera Command is issued"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.generic_camera_command_issued.camera":               "Info about the camera targeted by this command",
					"value.proto_value.generic_camera_command_issued.command_query_params": "The provided params (name, value pairs)",
					"value.proto_value.generic_camera_command_issued.duration_ms":          "Duration to complete the command (b/w SG & camera)",
					"value.proto_value.generic_camera_command_issued.endpoint":             "The Vivotek endpoint triggered by this call",
					"value.proto_value.generic_camera_command_issued.error":                "The returned error from the camera API call (empty string if no error)",
					"value.proto_value.generic_camera_command_issued.full_url_issued":      "The full URL issued to the camera",
					"value.proto_value.generic_camera_command_issued.hostname":             "Hostname of camera targeted by this command",
					"value.proto_value.generic_camera_command_issued.issued_at_ms":         "The unix timestamp (ms) when the command was issued",
					"value.proto_value.generic_camera_command_issued.org_id":               "The orgID of this device/camera",
					"value.proto_value.generic_camera_command_issued.response":             "The response from the Vivotek API call",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGenericProxyReadingsDebug,
			BinaryMessageField: "GenericProxyReadingsDebug",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Contains readings, in a generic format, from a peripheral that the device can receive data from. Only one of [BLE, J1939, Modbus] Metadata will be populated based on the peripheral type.",
				Frequency:   FrequencyCustom("Depends on the peripheral type."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.generic_proxy_readings_debug.samsara_peripheral_type_id":                        "The peripheral type ID. Defined in package peripheralintegrationsproto.",
					"value.proto_value.generic_proxy_readings_debug.last_seen_data":                                    "The last seen data from the peripheral. This is a byte array.",
					"value.proto_value.generic_proxy_readings_debug.timestamp_last_seen_data_ms":                       "Timestamp in ms of the last seen data.",
					"value.proto_value.generic_proxy_readings_debug.watch_window_duration_ms":                          "The duration of the watch window in ms.",
					"value.proto_value.generic_proxy_readings_debug.watch_window_count":                                "The number of data packets seen in the watch window. Only the most recent is uploaded.",
					"value.proto_value.generic_proxy_readings_debug.gateway_location":                                  "Location of the gateway.",
					"value.proto_value.generic_proxy_readings_debug.gateway_location.latitude_nanodegrees":             "Latitude of the gateway in nanodegrees.",
					"value.proto_value.generic_proxy_readings_debug.gateway_location.longitude_nanodegrees":            "Longitude of the gateway in nanodegrees.",
					"value.proto_value.generic_proxy_readings_debug.gateway_location.altitude_millimeters":             "Altitude of the gateway in millimeters.",
					"value.proto_value.generic_proxy_readings_debug.gateway_location.accuracy_millimeters":             "Accuracy of the gateway's location in millimeters.",
					"value.proto_value.generic_proxy_readings_debug.gateway_location.gps_speed_millimeters_per_second": "Speed of the gateway in millimeters per second.",
					"value.proto_value.generic_proxy_readings_debug.gateway_location.in_motion":                        "Whether the gateway is in motion.",
					"value.proto_value.generic_proxy_readings_debug.ble_metadata":                                      "BLE metadata. Only populated if the peripheral type uses BLE.",
					"value.proto_value.generic_proxy_readings_debug.ble_metadata.ble_address":                          "BLE address of the peripheral.",
					"value.proto_value.generic_proxy_readings_debug.ble_metadata.ble_rssi_dbm":                         "BLE RSSI (signal strength in dBm) of the peripheral.",
					"value.proto_value.generic_proxy_readings_debug.j1939_metadata":                                    "J1939 metadata. Only populated if the peripheral type uses J1939.",
					"value.proto_value.generic_proxy_readings_debug.j1939_metadata.pgn":                                "Parameter Group Number (PGN) of the J1939 message.",
					"value.proto_value.generic_proxy_readings_debug.j1939_metadata.source_address":                     "Source address of the J1939 message.",
					"value.proto_value.generic_proxy_readings_debug.j1939_metadata.source_name":                        "Source name of the J1939 message.",
					"value.proto_value.generic_proxy_readings_debug.j1939_metadata.bus_id":                             "Bus ID of the J1939 message.",
					"value.proto_value.generic_proxy_readings_debug.modbus_metadata":                                   "Modbus metadata. Only populated if the peripheral type uses Modbus.",
					"value.proto_value.generic_proxy_readings_debug.modbus_metadata.server_address":                    "Server address of the Modbus message.",
					"value.proto_value.generic_proxy_readings_debug.modbus_metadata.function_code":                     "Function code of the Modbus message.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGeolocationRequest,
			BinaryMessageField: "GeolocationRequest",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Contains surrounding network information (cellular, wifi) to geolocate the device in case of failure to get a GPS fix",
				Frequency:   FrequencyCustom("Every ping cycle and/or custom interval"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.geolocation_request.gps.latitude_nd":             "GPS latitude",
					"value.proto_value.geolocation_request.gps.longitude_nd":            "GPS longitude",
					"value.proto_value.geolocation_request.cellular.towers.cell_id":     "Cellular cell ID",
					"value.proto_value.geolocation_request.cellular.towers.area_code":   "Cellular area code",
					"value.proto_value.geolocation_request.cellular.towers.mcc":         "Cellular Mobile Country Codes",
					"value.proto_value.geolocation_request.cellular.towers.mnc":         "Cellular Mobile Network Codes",
					"value.proto_value.geolocation_request.cellular.towers.rsrp_dbm":    "Cellular Reference Signal Received Power",
					"value.proto_value.geolocation_request.wifi.access_points.ssid":     "Access point name",
					"value.proto_value.geolocation_request.wifi.access_points.bssid":    "Access point MAC address",
					"value.proto_value.geolocation_request.wifi.access_points.rssi_dbm": "Access point rssi[dbm]",
					"value.proto_value.geolocation_request.wifi.access_points.channel":  "Access point channel",
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDGPSDataExtended,
			Kind:                     StatKindObjectStat,
			BinaryMessageField:       "GpsFixLogExtended",
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDGpsDistance,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGpsHealth,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "GpsHealth",
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
			MetadataInfo: &MetadataInfo{
				Description: "Contains information about GPS receiver health. All data except the periods and durations describe information about the most recent position fix.",
				Frequency:   FrequencyEveryXSeconds(15 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.gps_health":                                         "Information about the health of the GPS receiver",
					"value.proto_value.gps_health.fix_data":                                "Information about when the GPS receiver had a position fix",
					"value.proto_value.gps_health.fix_data.duration_ms":                    "The amount of time the GPS receiver had a position fix",
					"value.proto_value.gps_health.no_fix_data":                             "Informaton about when the GPS receiver did not have a position fix",
					"value.proto_value.gps_health.no_fix_data.duration_ms":                 "The amount of time the GPS receiver did not have a position fix",
					"value.proto_value.gps_health.periods":                                 "Chronological list of periods that describe the GPS state over the reporting interval",
					"value.proto_value.gps_health.periods.gps_state":                       metadatahelpers.EnumDescription("The state of the GPS receiver during this period", hubproto.ObjectStatBinaryMessage_GpsHealth_Period_GpsState_value),
					"value.proto_value.gps_health.periods.duration_ms":                     "How long the GPS receiver was in this state",
					"value.proto_value.gps_health.fix_satellites_mean_snr_dbhz":            metadatahelpers.DeprecatedDescription("Incorrectly calculated average of the signal to noise ratios of the satellites used in the position fix. It calculated by averaging the dB values directly, which unevenly weights values by the nature of the logarithmic scale"),
					"value.proto_value.gps_health.systems_seen":                            "List of all GNSS constellations with at least one satellite in view",
					"value.proto_value.gps_health.systems_seen.gnss_system_name":           metadatahelpers.EnumDescription("GNSS contellation", hubproto.ObjectStatBinaryMessage_Mdm9607GpsReceptionInfo_GnssSvInfo_GnssSystemName_value),
					"value.proto_value.gps_health.systems_seen.total_satellite_count":      "Number of satellites from constellation that are in view",
					"value.proto_value.gps_health.systems_seen.tracked_satellite_count":    "Number of satellites from constellation that are being tracked (typically synonymous with being used in fix)",
					"value.proto_value.gps_health.fix_constellations":                      metadatahelpers.EnumDescription("GNSS constellations being used in position fix", hubproto.ObjectStatBinaryMessage_Mdm9607GpsReceptionInfo_GnssSvInfo_GnssSystemName_value),
					"value.proto_value.gps_health.speed_valid_duration_ms":                 "The amount of time the GPS receiver has provided a valid GPS speed",
					"value.proto_value.gps_health.fix_satellites_linear_mean_snr_dbhz":     "The correctly calculated average of the signal to noise ratios of the satellites used in the position fix. Calculated as 10 * log10((10^(SNR_dB_1/10)+...+10^(SNR_dB_n/10))/n)",
					"value.proto_value.gps_health.visible_satellites_linear_mean_snr_dbhz": "The correctly calculated average of the signal to noise ratios of all satellites in view. Calculated as 10 * log10((10^(SNR_dB_1/10)+...+10^(SNR_dB_n/10))/n)",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDGpsTimeToFirstFixMs,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			BinaryMessageField:       "GpsTimeToFirstFixInfo",
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDGRPCHubServerDeviceHeartbeat,
			BinaryMessageField: "GrpcHubServerDeviceHeartbeat",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
		},
		{StatType: objectstatproto.ObjectStatEnum_osDHealthStatus,
			BinaryMessageField: "DeviceHealthStatus",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Device Health Status",
				Frequency:   FrequencyOnChange("Emitted when there is any change in gateway health status."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.device_health_status.status": "The device health status.",
				},
			}},
		{
			StatType: objectstatproto.ObjectStatEnum_osDHEv1CrashDetectionRunning,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "State of the HEv1 crash detection algorithm.",
				Frequency:   FrequencyOnChange("Emitted when there is any state change and at least every 5 minutes."),
				ColumnDescriptions: map[string]string{
					"value.int_value": metadatahelpers.EnumDescription("Algorithm state.", hubproto.HarshEventAlgorithmState_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDHEv1HarshEventDetectionRunning,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			MetadataInfo: &MetadataInfo{
				Description: "State of the HEv1 harsh accel/brake/turn detection algorithm.",
				Frequency:   FrequencyOnChange("Emitted when there is any state change and at least every 5 minutes."),
				ColumnDescriptions: map[string]string{
					"value.int_value": metadatahelpers.EnumDescription("Algorithm state.", hubproto.HarshEventAlgorithmState_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDHEv2CrashDetectionRunning,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Kind: StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "State of the HEv2 crash detection algorithm.",
				Frequency:   FrequencyOnChange("Emitted when there is any state change and at least every 5 minutes."),
				ColumnDescriptions: map[string]string{
					"value.int_value": metadatahelpers.EnumDescription("Algorithm state.", hubproto.HarshEventAlgorithmState_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDHEv2HarshEventDetectionRunning,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "State of the HEv2 harsh accel/brake/turn detection algorithm.",
				Frequency:   FrequencyOnChange("Emitted when there is any state change and at least every 5 minutes."),
				ColumnDescriptions: map[string]string{
					"value.int_value": metadatahelpers.EnumDescription("Algorithm state.", hubproto.HarshEventAlgorithmState_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDHubServerDeviceHeartbeat,
			BinaryMessageField:   "HubServerDeviceHeartbeat",
			DataModelStat:        true,
			Kind:                 StatKindObjectStat,
			Production:           true,
			AdditionalAdminTeams: []components.TeamInfo{team.CoreServices},
			MetadataInfo: &MetadataInfo{
				Description: "Indicates when this device was last connected to the backend, the nature of its connection to the backend, and metadata about the device (e.g., build, config version, etc.)",
				Frequency:   FrequencyOnChange("Emitted when a device connects to the backend, and updated every two minutes when a device stays connected to the backend"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.hub_server_device_heartbeat.last_heartbeat_at_ms":                                "when this heartbeat was last updated",
					"value.proto_value.hub_server_device_heartbeat.heartbeat_period_sec":                                "the amount of time between emission of this heartbeat and the next one if the device is still connected",
					"value.proto_value.hub_server_device_heartbeat.connection.hubserver_task_arn":                       "the ARN of the hubserver task which emitted this heartbeat to the backend",
					"value.proto_value.hub_server_device_heartbeat.connection.hubserver_management_address":             "the IP address of the hubserver management host",
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello_request_id":                  "the request ID sent up in the `DeviceReq` containing a `DeviceHello` message",
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello":                             "the device hello message sent up by a device when it connects to the backend",
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.device_id":                   metadatahelpers.DeviceIdDefaultDescription,
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.boot_count":                  "how many times this device has booted, cumulatively over all time",
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.build":                       "the build the device is running",
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.cfg_ver":                     "the config version of the device ",
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.interface":                   "what interface the device is currently using to send data (one of wifi, cellular, or ethernet)",
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.cell_operator":               "what cellular operator the device is currently using",
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.org_id":                      metadatahelpers.OrgIdDefaultDescription,
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.group_id":                    "the ID of the group to which the device that sent up the hello request belongs",
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.gateway_id":                  metadatahelpers.GatewayIdDefaultDescription,
					"value.proto_value.hub_server_device_heartbeat.connection.device_hello.supports_serialized_hub_req": "whether or not the device supports serialized hub requests",
					"value.proto_value.hub_server_device_heartbeat.connection.started_at_ms":                            "the time in miliseconds at which this heartbeat was first emitted",
					"value.proto_value.hub_server_device_heartbeat.connection.public_ip":                                "the public IP of the device",
					"value.proto_value.hub_server_device_heartbeat.connection.public_ip_hostname":                       "the public IP hostname of the device",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDImmobilizerEvent,
			BinaryMessageField: "ImmobilizerEvent",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Tracks immobilization events.",
				Frequency:   FrequencyOnChange("Every immobilization state change."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.immobilizer_event.source_objectstat_timestamp_ms": "The exact timestamp (in Unix epoch milliseconds) when the immobilization event was created in the device.",
					"value.proto_value.immobilizer_event.context":                        "Additional contextual data surrounding the immobilization event, providing further insights into the circumstances at the time of the event.",
					"value.proto_value.immobilizer_event.context.location":               "The geographical location of the device at the time of the immobilization event.",
					"value.proto_value.immobilizer_event.context.location.latitude":      "The latitude coordinate of the device at the time of the immobilization event.",
					"value.proto_value.immobilizer_event.context.location.longitude":     "The longitude coordinate of the device at the time of the immobilization event.",
					"value.proto_value.immobilizer_event.context.driver_id":              "The unique identifier of the driver who was associated with the device at the time of the immobilization event.",
					"value.proto_value.immobilizer_event.context.user_id":                "The unique identifier of the user who initiated or triggered the immobilization event.",
					"value.proto_value.immobilizer_event.relays_events":                  "Details about the relay states involved in the immobilization event.",
					"value.proto_value.immobilizer_event.relays_events.relay_id":         "The unique identifier for each relay involved in the event.",
					"value.proto_value.immobilizer_event.relays_events.operation_type":   metadatahelpers.EnumDescription("Current relay operation type on the device.", hubproto.ImmobilizerOperationType_name),
					"value.proto_value.immobilizer_event.relays_events.source":           metadatahelpers.EnumDescription("The origin or source of the immobilization event.", hubproto.ImmobilizerEventSource_name),
					"value.proto_value.immobilizer_event.relays_events.correlation_id":   "Identifier corresponding to the source that generated the immobilization event. This ID aids in tracing the event back to its origin.",
					"value.proto_value.immobilizer_event.relays_events.change_reason":    metadatahelpers.EnumDescription("A predefined reason code explaining why the immobilization state was changed.", hubproto.ImmobilizerStateChangeReason_name),
					"value.proto_value.immobilizer_event.relays_events.status":           metadatahelpers.EnumDescription("The current status of the immobilizer at the time of the event, indicating whether the command is invalid, created, sent, received, applying, done, failed, or ignored.", hubproto.ImmobilizerEventStatus_name),
					"value.proto_value.immobilizer_event.relays_events.command_uuid":     "A globally unique identifier (UUID) that represents the specific immobilization event.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDImuCalibrationReset,
			BinaryMessageField: "ImuCalibrationReset",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			MetadataInfo: &MetadataInfo{
				Description:         "IMU Calibration Reset Object Stat",
				Frequency:           FrequencyOnChange("Significant change in gateway orientation."),
				IntValueDescription: "Uploaded each time a significant change of the gateway orientation is detected. The IMU calibration is erased and the calibration algorithm restarts from scratch.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.imu_calibration_reset.reset_reason":                                                  "Reason the reset was initiated.",
					"value.proto_value.imu_calibration_reset.drive_time_since_start_secs":                                   "Drive time since calibration algorithm was initiated.",
					"value.proto_value.imu_calibration_reset.short_term_gravity_change_reset.current_short_term_gravity.x":  "current x value of short term gravity change. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SIGNIFICANT_SHORT_TERM_GRAVITY_CHANGE (2), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_term_gravity_change_reset.current_short_term_gravity.y":  "current y value of short term gravity change. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SIGNIFICANT_SHORT_TERM_GRAVITY_CHANGE (2), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_term_gravity_change_reset.current_short_term_gravity.z":  "current z value of short term gravity change. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SIGNIFICANT_SHORT_TERM_GRAVITY_CHANGE (2), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_term_gravity_change_reset.previous_short_term_gravity.x": "previous x value of short term gravity change. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SIGNIFICANT_SHORT_TERM_GRAVITY_CHANGE (2), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_term_gravity_change_reset.previous_short_term_gravity.y": "previous y value of short term gravity change. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SIGNIFICANT_SHORT_TERM_GRAVITY_CHANGE (2), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_term_gravity_change_reset.previous_short_term_gravity.z": "previous z value of short term gravity change. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SIGNIFICANT_SHORT_TERM_GRAVITY_CHANGE (2), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_term_gravity_change_reset.angle_degrees":                 "Angle between current and previous short term gravity vector. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SIGNIFICANT_SHORT_TERM_GRAVITY_CHANGE (2), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_term_gravity_change_reset.threshold_degrees":             "Threshold used to trigger the reset when angle_degrees is above the threshold. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SIGNIFICANT_SHORT_TERM_GRAVITY_CHANGE (2), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_long_term_gravity_diff_reset.short_term_gravity.x":       "Short term gravity x value. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SHORT_AND_LONG_TERM_GRAVITY_DIFF (3), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_long_term_gravity_diff_reset.short_term_gravity.y":       "Short term gravity y value. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SHORT_AND_LONG_TERM_GRAVITY_DIFF (3), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_long_term_gravity_diff_reset.short_term_gravity.z":       "Short term gravity z value. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SHORT_AND_LONG_TERM_GRAVITY_DIFF (3), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_long_term_gravity_diff_reset.long_term_gravity.x":        "Long term gravity x value. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SHORT_AND_LONG_TERM_GRAVITY_DIFF (3), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_long_term_gravity_diff_reset.long_term_gravity.y":        "Long term gravity y value. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SHORT_AND_LONG_TERM_GRAVITY_DIFF (3), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_long_term_gravity_diff_reset.long_term_gravity.z":        "Long term gravity z value. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SHORT_AND_LONG_TERM_GRAVITY_DIFF (3), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_long_term_gravity_diff_reset.angle_degrees":              "Angle between short term and long term gravity vector. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SHORT_AND_LONG_TERM_GRAVITY_DIFF (3), otherwise null.",
					"value.proto_value.imu_calibration_reset.short_long_term_gravity_diff_reset.threshold_degrees":          "Threshold used to trigger the rest when angle_degrees is above the threshold. Only populated if the reset reason is hubproto.ImuCalibrationReset_RESET_REASON_SHORT_AND_LONG_TERM_GRAVITY_DIFF (3), otherwise null.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDImuCalibrationStatus,
			BinaryMessageField: "ImuCalibrationStatus",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			MetadataInfo: &MetadataInfo{
				Description:         "Status of the IMU Calibration",
				Frequency:           FrequencyOnChange("Reported each time the status changes on a trip, at most every 5 minutes, or every 30 minutes (even with no change)"),
				IntValueDescription: "Status is uploaded each time the gateway is on a trip and the IMU calibration status has changed at most every 5 minutes or every 30 minutes (even if there are no changes.. The stat can be used to determine whether the IMU calibration has started, by checking the algoState. The calibrationStartedAtUnixtimeMs can be used to determine the start time of the most recent IMU calibration.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.imu_calibration_status.current_calibration_index":                                      "Index incremented each time the IMU is calibrated",
					"value.proto_value.imu_calibration_status.drive_time_since_start_secs":                                    "Drive time since the calibration started",
					"value.proto_value.imu_calibration_status.gyroscope_bias.algo_state":                                      "Current state of the IMU calibration. Gyroscope bias is described by the offset (on x, y and z) of the gyroscope output when there is an absence of movement, a.k.a zero-rate. Varies from one device to another and is temperature-dependent.",
					"value.proto_value.imu_calibration_status.short_term_gravity.algo_state":                                  "Current state of the IMU calibration. Short-term gravity is described by the short-term estimate of the gravity vector, updated every few minutes.",
					"value.proto_value.imu_calibration_status.short_term_gravity.sample_count":                                "Sample count for the short-term gravity estimate. Short-term gravity is described by the short-term estimate of the gravity vector, updated every few minutes.",
					"value.proto_value.imu_calibration_status.short_term_gravity.calibration_started_at_unixtime_ms":          "Time calibration has started. Short-term gravity is described by the short-term estimate of the gravity vector, updated every few minutes.",
					"value.proto_value.imu_calibration_status.gravity.algo_state":                                             "Current state of the IMU calibration. Gravity is described by the current long-term estimate of the gravity vector, if gravity has been measured.",
					"value.proto_value.imu_calibration_status.gravity.sample_count":                                           "Sample count for the gravity estimate. Gravity is described by the current long-term estimate of the gravity vector, if gravity has been measured.",
					"value.proto_value.imu_calibration_status.gravity.calibration_started_at_unixtime_ms":                     "Time calibration has started. Gravity is described by the current long-term estimate of the gravity vector, if gravity has been measured.",
					"value.proto_value.imu_calibration_status.yaw_angle.algo_state":                                           "Current state of the IMU calibration. Yaw angle is described as the angle between a line pointing in the direction the car is moving and the car's x-axis.",
					"value.proto_value.imu_calibration_status.yaw_angle.left_turn_sample_count":                               "Left turn sample count. Yaw angle is described as the angle between a line pointing in the direction the car is moving and the car's x-axis.",
					"value.proto_value.imu_calibration_status.yaw_angle.right_turn_sample_count":                              "Right turn sample count. Yaw angle is described as the angle between a line pointing in the direction the car is moving and the car's x-axis.",
					"value.proto_value.imu_calibration_status.yaw_angle.strong_accel_brake_sample_count":                      "Strong accel and brake sample count. Yaw angle is described as the angle between a line pointing in the direction the car is moving and the car's x-axis.",
					"value.proto_value.imu_calibration_status.yaw_angle.calibration_started_at_unixtime_ms":                   "Time calibration has started. Yaw angle is described as the angle between a line pointing in the direction the car is moving and the car's x-axis.",
					"value.proto_value.imu_calibration_status.config.calibration_reset.sent_at_unix_ms":                       "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.calibration_reset.reset_tag":                             "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.sample_collection.strong_turn_min_gyro_norm_dps":         "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.sample_collection.no_turn_max_gyro_norm_dps":             "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.sample_collection.save_progress_interval_secs":           "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.gyroscope_bias.gyro_at_rest_max_norm_dps":                "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.gyroscope_bias.gyro_at_rest_max_gyro_slope_filter_dps":   "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.gyroscope_bias.gyro_at_rest_max_accel_slope_filter_g":    "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.gyroscope_bias.gyro_bias_max_valid_value_dps":            "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.gyroscope_bias.gyro_bias_update_min_change_dps":          "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.short_term_gravity.accel_samples_max_offset_from_1g":     "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.short_term_gravity.lock_sample_count":                    "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.short_term_gravity.lock_max_std_dev_g":                   "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.short_term_gravity.orientation_change_threshold_degrees": "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.gravity.accel_samples_max_offset_from_1g":                "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.gravity.lock_sample_count":                               "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.yaw_angle.left_right_turn_gyro_z_axis_threshold_dps":     "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.yaw_angle.left_right_turn_min_accel_mag_g":               "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.yaw_angle.strong_accel_brake_min_accel_mag_g":            "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.yaw_angle.strong_accel_brake_max_z_axis_g":               "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.yaw_angle.lock_min_left_and_right_sample_count":          "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.yaw_angle.lock_min_strong_accel_or_brake_sample_count":   "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.yaw_angle.lock_validity_max_forward_side_dot_product":    "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.yaw_angle.lock_validity_min_left_right_angle_degrees":    "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.orientation_updates.min_gravity_change_degrees":          "No longer reported, to save on cellular usage.",
					"value.proto_value.imu_calibration_status.config.orientation_updates.min_yaw_angle_change_degrees":        "No longer reported, to save on cellular usage.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDImuGravityVector,
			BinaryMessageField: "ImuGravityVector",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "IMU Gravity Vector",
				Frequency:           FrequencyOnChange("Firmware updates the gravity estimate"),
				IntValueDescription: "The current long-term estimate of the gravity vector, if gravity has been measured.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.imu_gravity_vector.gravity_vector_g":               "The current long term gravity estimate as a vector.",
					"value.proto_value.imu_gravity_vector.sample_count":                   "Number of gravity samples received",
					"value.proto_value.imu_gravity_vector.angle_with_current_orientation": "Angle reported between current gravity vector and the currently locked gravity vector.",
					"value.proto_value.imu_gravity_vector.drive_time_since_start_secs":    "Drive time since the calibration started",
					"value.proto_value.imu_gravity_vector.calibration_started_at_unix_ms": "Time calibration has started.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDImuGyroscopeBias,
			BinaryMessageField: "ImuGyroscopeBias",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "IMU Gyroscope Bias",
				Frequency:           FrequencyOnChange("Firmware updates the gyroscope bias"),
				IntValueDescription: "The offset (on x, y and z) of the gyroscope output when there is an absence of movement, a.k.a zero-rate. Varies from one device to another and is temperature-dependent.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.imu_gyroscope_bias.bias_dps":                    "The bias that we are currently correcting measured in degrees per second.",
					"value.proto_value.imu_gyroscope_bias.has_valid_temperature":       "Whether the temperature field in the object stat is valid or not (some gyroscopes don't report temperature)",
					"value.proto_value.imu_gyroscope_bias.temperature_c":               "Current temperature as measured by the gyroscope or IMU sensor",
					"value.proto_value.imu_gyroscope_bias.drive_time_since_start_secs": "Drive time since the calibration started",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDIMUModel,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "IMU sensor model",
				Frequency:           FrequencyCustom("This stat is sent whenever we initialize the IMU sensor (power-on, reboot, service restart)."),
				IntValueDescription: metadatahelpers.EnumDescription("The model of the IMU sensor in use.", hubproto.IMUModel_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDImuOrientation,
			BinaryMessageField: "ImuOrientation",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			MetadataInfo: &MetadataInfo{
				Description:         "IMU calibration successful",
				Frequency:           FrequencyOnChange("Each time the IMU has successfully calibrated"),
				IntValueDescription: "Stat that gets uploaded each time the IMU has succesfully calibrated. Can be used to determine the last time the IMU has calibrated, how many times it has recalibrated, and whether or not we are currently calibrated.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.imu_orientation.gravity_vector.x":    "x value of the gravity vector of the vehicle.",
					"value.proto_value.imu_orientation.gravity_vector.y":    "y value of the gravity vector of the vehicle.",
					"value.proto_value.imu_orientation.gravity_vector.z":    "z value of the gravity vector of the vehicle.",
					"value.proto_value.imu_orientation.yaw_angle_degrees":   "Degrees of the yaw angle of the vehicle.",
					"value.proto_value.imu_orientation.calibration_index":   "Index incremented each time the calibration is successful.",
					"value.proto_value.imu_orientation.is_loaded_from_disk": "Indicates whether this is a new calibration or a calibration that was loaded from the device after a VG restart.",
					"value.proto_value.imu_orientation.lock_valid":          "Whether the calibration lock is valid.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDImuShortTermGravity,
			BinaryMessageField: "ImuShortTermGravity",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "IMU Short Term Gravity",
				Frequency:           FrequencyOnChange("Every few minutes"),
				IntValueDescription: "Short Term Gravity Estimate, uploaded every few minutes.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.imu_short_term_gravity.short_term_gravity_g":                          "Current short term gravity vector.",
					"value.proto_value.imu_short_term_gravity.sample_count":                                  "Number of short term gravity samples taken",
					"value.proto_value.imu_short_term_gravity.angle_with_previous_vector_degrees":            "Angle between current and previous short term gravity vector",
					"value.proto_value.imu_short_term_gravity.drive_time_since_start_secs":                   "Drive time since the calibration started",
					"value.proto_value.imu_short_term_gravity.calibration_started_at_unix_ms":                "Time calibration has started.",
					"value.proto_value.imu_short_term_gravity.standard_deviation_g":                          "Standard deviation vector (x,y,z) of the acceleration samples that were averaged to measure short-term gravity",
					"value.proto_value.imu_short_term_gravity.angle_with_current_orientation_gravity_vector": "Angle between the reported short-term gravity vector and the currently locked orientation's gravity vector",
					"value.proto_value.imu_short_term_gravity.has_valid_temperature":                         "Whether the temperature field in the object stat is valid or not (some gyroscopes don't report temperature)",
					"value.proto_value.imu_short_term_gravity.temperature_c":                                 "Current temperature as measured by the gyroscope or IMU sensor",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDImuYawAngle,
			BinaryMessageField: "ImuYawAngle",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDInCabVoiceCommand,
			BinaryMessageField: "InCabVoiceCommand",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "In cab voice command",
				Frequency:           FrequencyCustom("When in cab voice command is detected"),
				IntValueDescription: "Binary value, either 0 for no command detected or 1 for command detected",
				ColumnDescriptions: map[string]string{
					"object_id": "CM device id.",
					"value.proto_value.in_cab_voice_command.command":              metadatahelpers.EnumDescription("recognized voice command", hubproto.InCabVoiceCommandEnum_name),
					"value.proto_value.in_cab_voice_command.command_confidence":   "voice command recognition confidence",
					"value.proto_value.in_cab_voice_command.command_phrase":       "what phrase was used for the command recognition",
					"value.proto_value.in_cab_voice_command.wake_word_phrase":     "what phrase was used for the wake word detection",
					"value.proto_value.in_cab_voice_command.wake_word_confidence": "wake word detection confidence",
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDIncrementalCellularUsage,
			BinaryMessageField:       "IncrementalCellularUsage",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			Tags:                     []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Cellular data used since last reported stat",
				Frequency:   FrequencyCustom("every 1 MB of total data consumed"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.incremental_cellular_usage.bucket.bucket_type":                          metadatahelpers.EnumDescription("Data usage classification.", hubproto.ObjectStatBinaryMessage_CellularUsage_Bucket_BucketType_name),
					"value.proto_value.incremental_cellular_usage.bucket.upload_bytes":                         "Amount of data uploaded in the current bucket since the previous report.",
					"value.proto_value.incremental_cellular_usage.bucket.download_bytes":                       "Amount of data downloaded in the current bucket since the previous report.",
					"value.proto_value.incremental_cellular_usage.total_upload_bytes":                          "Total amount of data uploaded during the current device boot.",
					"value.proto_value.incremental_cellular_usage.total_download_bytes":                        "Total amount of data downloaded during the current device boot.",
					"value.proto_value.incremental_cellular_usage.attached_device_usage.object_id":             "ObjectId of the attached device. Requested from attached Samsara device. Currently supports products that do not have a cellular connection (CM3X, multicam).",
					"value.proto_value.incremental_cellular_usage.attached_device_usage.bucket.bucket_type":    metadatahelpers.EnumDescription("Classifies where usage comes from. Classification is defined in ObjectStatBinaryMessage_CellularUsage_Bucket_BucketType. Requested from attached Samsara device. Currently supports products that do not have a cellular connection (CM3X, multicam).", hubproto.ObjectStatBinaryMessage_CellularUsage_Bucket_BucketType_name),
					"value.proto_value.incremental_cellular_usage.attached_device_usage.bucket.upload_bytes":   "Amount of data uploaded since the previous report. Requested from attached Samsara device. Currently supports products that do not have a cellular connection (CM3X, multicam).",
					"value.proto_value.incremental_cellular_usage.attached_device_usage.bucket.download_bytes": "Amonut of data downloaded since the previous report. Requested from attached Samsara device. Currently supports products that do not have a cellular connection (CM3X, multicam).",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle10Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 10",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle10Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 10",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle1Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 1",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle1Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 1",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},

		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle2Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 2",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle2Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 2",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle3Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 3",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle3Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 3",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle4Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 4",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle4Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 4",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle5Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 5",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle5Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 5",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle6Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 6",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle6Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 6",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle7Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 7",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle7Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 7",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle8Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 8",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle8Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 8",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},

		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle9Left,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for left axle 9",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},

		{
			StatType:           objectstatproto.ObjectStatEnum_osDIndividualWheelEndHealthAxle9Right,
			BinaryMessageField: "IndividualWheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Individual wheel end health for right axle 9",
				Frequency:   FrequencyOnChange("Every time the wheel end health is updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.individual_wheel_end_health.temperature_milli_celsius":         "Temperature of the wheel end in milli-celsius",
					"value.proto_value.individual_wheel_end_health.temperature_warning_active":        "Whether the temperature warning is active",
					"value.proto_value.individual_wheel_end_health.temperature_sensor_failure_active": "Whether the temperature sensor failure is active",
					"value.proto_value.individual_wheel_end_health.wheel_end_failure_status":          metadatahelpers.EnumDescription("The failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_WheelEndFailureStatus_name),
					"value.proto_value.individual_wheel_end_health.sensor_battery_level_status":       metadatahelpers.EnumDescription("The battery level status of the wheel end", assethealthproto.IndividualWheelEndHealth_SensorBatteryLevelStatus_name),
					"value.proto_value.individual_wheel_end_health.vibration_sensor_failure_status":   metadatahelpers.EnumDescription("The vibration sensor failure status of the wheel end", assethealthproto.IndividualWheelEndHealth_VibrationSensorFailureStatus_name),
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDIndustrialProtocolPollingDuration,
			BinaryMessageField:       "IndustrialProtocolPollingDuration",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDIndustrialProtocolSuccessRate,
			BinaryMessageField:       "IndustrialProtocolSuccessRate",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDInferredLocation,
			BinaryMessageField: "InferredLocation",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Location of a crux peripheral inferred from the locations of the crux central observing it.",
				Frequency:   FrequencyCustom("Every time a crux peripheral is observed by a crux central."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.inferred_location.latitude_degrees":                           "Latitude of the inferred location in degrees",
					"value.proto_value.inferred_location.longitude_degrees":                          "Longitude of the inferred location in degrees",
					"value.proto_value.inferred_location.altitude_meters":                            "Altitude of the inferred location in meters",
					"value.proto_value.inferred_location.accuracy_millimeters":                       "Accuracy of the inferred location in millimeters, this is the sum of the accuracy from the GPS fix and the accuracy derived from the BLE signal strength (RSSI)",
					"value.proto_value.inferred_location.inference_processed_at_ms":                  "Time at which the cruxproxylocationprocessor had the required input data (observation + central location) to make the location inference",
					"value.proto_value.inferred_location.timestamps_of_locations_used_for_inference": "The list of timestamps of the locations that were used for inference",
					"value.proto_value.inferred_location.location_source":                            "Information about the crux central that we used the locations of to infer the location of the crux peripheral",
					"value.proto_value.inferred_location.location_source.org_id":                     "The organization ID of the crux central used as source for location inference",
					"value.proto_value.inferred_location.location_source.device_id":                  "The device ID of the crux central used as source for location inference",
					"value.proto_value.inferred_location.location_source.in_same_org":                "Boolean indicating if the crux central used as source for location inference is in the same organization as the crux peripheral",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDInputTriggerState,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "InputTriggerState",
			Tags:               []amundsentags.Tag{amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "State of the input triggers, such as trigger wires or gear state",
				Frequency:   FrequencyOnChange("Logs whenever any trigger state has changed or becomes known"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.input_trigger_state.triggers.trigger_id":             metadatahelpers.EnumDescription("The corresponding trigger's ID that this state message details", hubproto.TriggerId_name),
					"value.proto_value.input_trigger_state.triggers.state":                  metadatahelpers.EnumDescription("The state of the trigger (UNKNOWN/ON/OFF)", hubproto.InputTriggerState_Trigger_State_name),
					"value.proto_value.input_trigger_state.triggers.state_change_offset_ms": "Offset in ms between the time the state changed and the time the objectstat is reported",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDIntakeManifoldTemperatureMicroCelsius,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Intake manifold temperature (uC)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Temperature of pre-combustion air found in intake manifold of engine air supply system. Defined in J1939/J1979/ISO27145",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDInternalTestHybridEvSystemData,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Kind: StatKindObjectStat,
			Tags: []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.ElectricVehicleTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Test objectstat for EV diagnostics",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Reports vehicle commands tagged with OBD_VALUE_INTERNAL_TEST_HYBRID_EV_SYSTEM_DATA. Used for internal testing only. This is not currently enabled to report from the firmware.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDInternalTestOdometerMeters,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.DebugTag},
			MetadataInfo: &MetadataInfo{
				Description: metadatahelpers.DeprecatedDescription("To log test odometer commands, use a raw logger configuration."),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDInternalTestSeatbelt,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.DebugTag},
			MetadataInfo: &MetadataInfo{
				Description: metadatahelpers.DeprecatedDescription("To log test seatbelt commands, use a raw logger configuration."),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDInternalTestVinSpecificOdometerMeters,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.DebugTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Manufacturer specific diagnostic odometer distance (m)",
				Frequency:           FrequencyEveryXSeconds(10 * 60),
				IntValueDescription: "Current odometer reading in meters. This is applied broadly to manufacturer vehicles (eg GMC or Chevy) to check if an odometer command works broadly across a given manufacturer. If this is reported for a certain MMY, the MMY should promote an osDOdometer vehicle command if its not being reported already.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJ1699TestDetection,
			BinaryMessageField: "J1699TestDetection",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "J1699-3 Test Detection Results",
				Frequency:   FrequencyCustom("Reported when a J1699-3 test routine is detected"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.j1699_test_detection.j1699_detection_reason":        metadatahelpers.EnumDescription("The type of J1699-3 test detected", hubproto.J1699DetectionReason_name),
					"value.proto_value.j1699_test_detection.had_complete_fix":              "GPS fix status at time of detection",
					"value.proto_value.j1699_test_detection.latitude_nd":                   "GPS Latitude (nanodegrees) at time of detection",
					"value.proto_value.j1699_test_detection.longitude_nd":                  "GPS Longitude (nanodegrees) at time of detection",
					"value.proto_value.j1699_test_detection.time_to_detection_ms":          "Duration of time from first candidate frame (Service1 Pid00) to full detection of test",
					"value.proto_value.j1699_test_detection.region_check_enabled":          "Was GPS-based region boundary box checking enabled at time of detection",
					"value.proto_value.j1699_test_detection.bounding_box_min_latitude_nd":  "Minimum Latitude (nanodegrees) of the region's bounding box",
					"value.proto_value.j1699_test_detection.bounding_box_max_latitude_nd":  "Maximum Latitude (nanodegrees) of the region's bounding box",
					"value.proto_value.j1699_test_detection.bounding_box_min_longitude_nd": "Minimum Longitude (nanodegrees) of the region's bounding box",
					"value.proto_value.j1699_test_detection.bounding_box_max_longitude_nd": "Maximum Longitude (nanodegrees) of the region's bounding box",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJ1708Can3BusAutodetectResult,
			BinaryMessageField: "J1708Can3AutodetectMetadata",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "J1708 autodetection results",
				Frequency:           FrequencyCustom("Reported each time autodetect is run on tertiary CAN"),
				IntValueDescription: metadatahelpers.EnumDescription("Detected physical and data link layer on CAN3 of Modi or Thor", hubproto.J1708CanAutodetectedBus_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.j1708_can3_autodetect_metadata.can3_autodetect_duration_ms":         "Configured amount of time for CAN3 autodetect to run. Default on the firmware is 10 minutes.",
					"value.proto_value.j1708_can3_autodetect_metadata.j1708_autodetect_duration_ms":        "Configured amount of time for J1708 autodetect to run. Default on the firmware is 10 seconds. The duration is lower because of the risk associated with starting a J1708 node on a CAN network (physical layer).",
					"value.proto_value.j1708_can3_autodetect_metadata.bus_autodetect_method":               metadatahelpers.EnumDescription("Defines which autodetect methods are configured to run on the VG. Configurable via feature flags.", hubproto.J1708Can3BusAutodetectMethod_name),
					"value.proto_value.j1708_can3_autodetect_metadata.vehicle_active_source":               metadatahelpers.EnumDescription("The source used to determine if vehicle was active (routine only runs when vehicle is active)", hubproto.J1708CanBusAutodetectVehicleActiveSource_name),
					"value.proto_value.j1708_can3_autodetect_metadata.bus_not_present_count":               "Number of times we ran the bus autodetect and detected no bus consecutively before determining no bus was present",
					"value.proto_value.j1708_can3_autodetect_metadata.bus_not_present_count_before_cached": "Configured number of times we have to run bus autodetect and detect no bus consecutively before we can determine no bus is present",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939A1DEFIAftertreatment1DieselExhaustFluidTemperature2Celsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Exhaust Fluid Temperature 2 (C)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "DEF temperature measured at secondary location",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939A1SCRSI1Aftertreatment1SCRConversionEfficiencyDeciPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 SCR Conversion Efficiency (%)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Conversion efficiency of SCR system",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939ActualRetarderPercentTorque,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Actual Retarder - Percent Torque (%) - VDP stopped logging this data in August 2024",
				Frequency:           FrequencyEveryXSeconds(1 * samtime.SecondsInMinute),
				IntValueDescription: "Actual braking torque of the retarder as a percent",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AEBS1AdvancedEmergencyBrakingSystemStateState,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Current operational state of forward collision advanced emergency braking system (AEBS)",
				Frequency:           FrequencyOnChange("10ms on change of AEBS state or collision warning level"),
				IntValueDescription: metadatahelpers.EnumDescription("The current state", hubproto.AEBS1ForwardCollisionAdvancedEmergencyBrakingSystemState_name),
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AEBS1CollisionWarningLevelState,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "To implement different HMI (human machine interface) concepts, e.g. visual only, visual/audible, different warning tones etc., the AEBS provides different levels of collision warning.",
				Frequency:           FrequencyOnChange("10ms on change of AEBS state or collision warning level"),
				IntValueDescription: metadatahelpers.EnumDescription("The current warning", hubproto.AEBS1CollisionWarningLevel_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AEBS1TimeToCollisionWithRelevantObjectCentiSeconds,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "The time to collision is the duration after which the predicted travelling paths of host vehicle and relevant object lead to a distance of 0m between both.",
				Frequency:           FrequencyOnChange("10ms on change of AEBS state or collision warning level"),
				IntValueDescription: "Time in centiseconds",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDJ1939AEBS2DriverActivationDemandForAdvancedEmergencyBrakingSystemState,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Whether the driver wants the Advanced Emergency Braking System to intervene ot not.",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "0: AEBS deactivated, driver wants no warnings or interventions from AEBS, 1: activated",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939ASI1AftertreatmentThermalManagementStatus,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment Thermal Management Status",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Thermal management status of the aftertreatment system",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939ASSC1LaneKeepingAssistSystemState,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates the current state of the Lane Keep Assist feature",
				Frequency:           FrequencyOnChange("10ms on change"),
				IntValueDescription: metadatahelpers.EnumDescription("The current state", hubproto.ASSC1LaneKeepingAssistSystemState_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1FC1Aftertreatment1FuelRateCentiLPerHours,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Fuel Rate (cL/hr)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Fuel consumption rate for the aftertreatment system",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1GPAftertreatment1DieselParticulateFilterIntakePressurePascals,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Particulate Filter Intake Pressure (Pa)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Pressure measured at the DPF intake",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1GPAftertreatment1DieselParticulateFilterOutletPressurePascals,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Particulate Filter Outlet Pressure (Pa)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Pressure measured at the DPF outlet",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1HI1Aftertreatment1HistoricalInformation1,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Historical Information 1",
				Frequency:           FrequencyEveryXSeconds(60 * 60),
				IntValueDescription: "Historical information about the aftertreatment 1. This information is combined into a single raw command to avoid overloading the logging paths on the VG. This will need to be interpreted in our data pipelines to parse out the individual flags from these messages.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1IG1Aftertreatment1IntakePercentO2MicroPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Intake Percent Oxygen 1 (PGN 61454, SPN 3217, %)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Measures the oxygen concentration in the intake gas aftertreatment system to monitor efficiency and emissions control.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1IG1Aftertreatment1SelectiveCatalyticReductionIntakeNOxCentiPPM,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 SCR Intake NOx (cPPM)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "NOx levels measured before the SCR system",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1IG2Aftertreatment1ExhaustTemperature1MicroCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Exhaust Temperature 1 (PGN 64948, SPN 3241, C)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Measures the temperature of exhaust gases before entering the aftertreatment system.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1IGC2EngineExhaust1CorrectedNOxCentiPPM,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Exhaust 1 Corrected NOx (PGN 64784, SPN 7353, cPPM)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Measures the corrected NOx concentration in the exhaust gases using a NOx sensor correction factor.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1IMGAftertreatment1DieselParticulateFilterDifferentialPressurePascals,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Particulate Filter (DPF) Differential Pressure (PGN 64946, SPN 3251, Pa)",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "Monitors the pressure difference across the diesel particulate filter (DPF) to detect clogging or excessive restriction.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1IMGAftertreatment1DieselParticulateFilterIntermediateTemperatureMicroCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Intermediate Gas (PGN 64964, SPN 3250)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Monitors the temperature of the diesel particulate filter (DPF) during regeneration events and normal operation.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1OG1Aftertreatment1OutletNOxCentiPPM,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Outlet NOx (cPPM)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "NOx levels measured after the SCR system",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1OG1Aftertreatment1OutletPercentO2MicroPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Outlet Percent Oxygen 1 (PGN 61455, SPN 3227, %)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Measures the oxygen percentage in the outlet of the aftertreatment system to monitor catalyst efficiency.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1OG2Aftertreatment1ExhaustTemperature3MicroCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Exhaust Temperature 3 (C)",
				Frequency:           FrequencyEveryXSeconds(60 * 60),
				IntValueDescription: "Temperature of exhaust gases after treatment 1",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1S1Aftertreatment1DieselParticulateFilterTimeSinceLastActiveRegenerationSeconds,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Particulate Filter Time Since Last Active Regeneration (s)",
				Frequency:           FrequencyEveryXSeconds(60 * 60),
				IntValueDescription: "Total number of seconds since the last active regeneration event of diesel particulate filter 1",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1S2Aftertreatment1DieselParticulateFilterTimeToNextActiveRegenerationSeconds,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Particulate Filter Time to Next Active Regeneration (s)",
				Frequency:           FrequencyEveryXSeconds(60 * 60),
				IntValueDescription: "Total number of seconds until the next active regeneration event of diesel particulate filter 1",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1T1IAftertreatment1DieselExhaustFluidTankHeaterDeciPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Exhaust Fluid (DEF) Tank Heater Level (PGN 65110, SPN 3363, 0.1%)",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Indicates the current heating level of the DEF tank heater to prevent DEF crystallization in cold conditions.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1T1IAftertreatment1DieselExhaustFluidTankLevelDeciPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Exhaust Fluid (DEF) Tank Level (PGN 65110, SPN 1761)",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Reports the remaining DEF level in the tank, which is crucial for emissions compliance.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1T1IAftertreatment1DieselExhaustFluidTankTemperatureCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Exhaust Fluid (DEF) Tank Temperature (PGN 65110, SPN 4365)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Measures the temperature of the DEF tank to ensure proper fluid operation and prevent freezing.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT1T1IAftertreatmentDieselExhaustFluidTankLowLevel,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Exhaust Fluid (DEF) Tank Low Level Indicator (PGN 65110, SPN 5245)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Indicates whether the DEF tank level is critically low, requiring refill to maintain emissions compliance.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT2IG1Aftertreatment2IntakePercentO2MicroPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 2 Intake Percent Oxygen 1 (PGN 61456, SPN 3256, %)",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Measures the oxygen concentration in the intake gas of the secondary aftertreatment system.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AT2IG1Aftertreatment2SelectiveCatalyticReductionIntakeNOxCentiPPM,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 2 Intake NOx 1 (PGN 61456, SPN 3255, cPPM)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Measures NOx concentration at the intake of the selective catalytic reduction (SCR) aftertreatment system.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AutoDetectExpired,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.IndustrialTag, amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "J1939 autodetection results expired",
				Frequency:           FrequencyCustom("on j1939 autodetection results expiring"),
				IntValueDescription: "This is only reported with a value of 1 when the results expire. This is also only relevant on non-fleet products, as this is reported by our older autodetection method. The default is to expire the results after a number of trips have been made, with the number of trips being configurable.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJ1939AutoDetectInvalidResults,
			BinaryMessageField: "J1939ProbeResults",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.IndustrialTag, amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "J1939 autodetection failed",
				Frequency:           FrequencyCustom("on j1939 autodetection failure"),
				IntValueDescription: metadatahelpers.EnumDescription("Note this is an older autodetection method that is no longer used on fleet products.", hubproto.J1939AutoDetectAlgorithm_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AutoDetectPinnedCanBusType,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.IndustrialTag, amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "J1939 autodetection success results",
				Frequency:           FrequencyCustom("on j1939 autodetection sucessfully detected the bus type"),
				IntValueDescription: metadatahelpers.EnumDescription("Note this is an older autodetection method that is no longer used on fleet products.", logeventproto.LogEvent_ObdEvent_CanBusType_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939AutoDetectUniquePgnResult,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.IndustrialTag, amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "J1939 autodetection unique PGNs seen result",
				Frequency:           FrequencyCustom("on j1939 autodetection sucessfully via unique PGNs seen"),
				IntValueDescription: "Number of unqiue PGNs seen when autodetecting J1939 bus settings. Note this is an older autodetection method that is no longer used on fleet products",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJ1939BusStats,
			BinaryMessageField: "J1939BusStats",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "J1939 Bus Stats",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.j1939_bus_stats.multi_frame_infos":                                "BAM or CM J1939 multi frames seen and/or dropped",
					"value.proto_value.j1939_bus_stats.multi_frame_infos.pgn":                            "PGN information of frame",
					"value.proto_value.j1939_bus_stats.multi_frame_infos.source_address":                 "Address of source ECU on bus",
					"value.proto_value.j1939_bus_stats.multi_frame_infos.total_number_of_bytes_expected": "Since last logged, total bytes expected from incoming BAM or Request to Send frames",
					"value.proto_value.j1939_bus_stats.multi_frame_infos.max_number_of_bytes_expected":   "Of all multi frame messages since last logged, max number of bytes in multi frame message",
					"value.proto_value.j1939_bus_stats.multi_frame_infos.min_number_of_bytes_expected":   "Of all multi frame messages since last logged, min number of bytes in multi frame message",
					"value.proto_value.j1939_bus_stats.multi_frame_infos.request_to_send_count":          "Number of Request to Send frames seen by VG since last log",
					"value.proto_value.j1939_bus_stats.multi_frame_infos.bam_count":                      "Number of BAM frames seen by VG since last log",
					"value.proto_value.j1939_bus_stats.multi_frame_infos.received_dropped_count":         "Count of dropped multi frames by our VG since last log",
					"value.proto_value.j1939_bus_stats.multi_frame_infos.received_success_count":         "Count of successfully received multi frames by our VG since last log",
					"value.proto_value.j1939_bus_stats.number_of_multi_frame_infos_not_logged":           "Number of multi frame infos not logged, capped by J1939 Bus stats config",
					"value.proto_value.j1939_bus_stats.log_period_ms":                                    "actual time elapsed since data last logged",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDJ1939CCVS1CruiseControlSetSpeedKilometersPerHours,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Speed set by the driver for the Cruise Control System",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "Set speed in km/h",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJ1939ClaimedAddress,
			BinaryMessageField: "J1939ClaimedAddressInfo",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			MetadataInfo: &MetadataInfo{
				Description: "Contains J1939 Address Claim Information",
				Frequency:   FrequencyCustom("reported once per diagnostic session per CAN bus"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.j1939_claimed_address_info.source_address_claimed": "The address we have claimed on the CAN bus",
					"value.proto_value.j1939_claimed_address_info.bus":                    metadatahelpers.EnumDescription("Diagnostic bus location", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.j1939_claimed_address_info.no_open_address_found":  "If true, we were not able to identify an available address nor claim one",
				},
			},
			Tags: []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJ1939ComponentId,
			BinaryMessageField: "J1939ComponentId",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Contains J1939 PGN 65259 Component Id Info",
				Frequency:   FrequencyCustom("reported once per engine on cycle"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.j1939_component_id.tx_id":         "Vehicle ECU address sending faults",
					"value.proto_value.j1939_component_id.make":          "Power Unit Make",
					"value.proto_value.j1939_component_id.model":         "Power Unit Model",
					"value.proto_value.j1939_component_id.serial_number": "Power Unit Serial Number",
					"value.proto_value.j1939_component_id.unit_number":   "Power Unit Number",
				},
			},
			Tags: []amundsentags.Tag{amundsentags.AssetsTag},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDJ1939CVWGrossCombinationVehicleWeightKilograms,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.IndustrialTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Combined Vehicle Weight (kg)",
				Frequency:           FrequencyEveryXSeconds(10 * 60),
				IntValueDescription: "The total weight of the truck and all attached trailers.. J1939-DA PGN 65136 Combined Vehicle Weight (CVW), SPN 1760",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJ1939D1Status,
			DataModelStat:      true,
			BinaryMessageField: "J1939D1Statuses",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Previously Active Diagnostic Trouble Codes (DM1)",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.j1939_d1_statuses.tx_id":               "Vehicle ECU address sending faults",
					"value.proto_value.j1939_d1_statuses.mil_status":          "Malfunction Indicator Lamp (MIL). A lamp used to relay only emissions-related trouble code information. This lamp is only illuminated when there is an emission-related trouble code active. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.j1939_d1_statuses.red_lamp_status":     "Flash Red Stop Lamp (RSL). This lamp is used to relay trouble code information that is of a severe enough condition that it warrants stopping the vehicle. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.j1939_d1_statuses.amber_lamp_status":   "Flash Amber Warning Lamp (AWL) This parameter provides the capability to flash the AWL. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.j1939_d1_statuses.protect_lamp_status": "Flash Protect Lamp (FPL). This parameter provides the capability to flash the protect lamp. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.j1939_d1_statuses.spn":                 "Suspect Parameter Number. This 19-bit number is used to identify the item for which diagnostics are being reported. The SPN is used for multiple purposes, some of those that are specific to diagnostics are: 1. to identify a least repairable subsystem that has failed; 2. to identify subsystems and or assemblies that may not have hard failures but may be exhibiting abnormal operating performance; 3. identifying a particular event or condition that will be reported; and 4. to report a component and non-standard failure mode. SPNs are assigned to each individual parameter in a Parameter Group and to items that are relevant to diagnostics but are not a parameter in a Parameter Group. SPNs are independent of the source address for the message. However, the source address may be necessary to determine which controller on the network performed the diagnosis. J1939-73",
					"value.proto_value.j1939_d1_statuses.fmi":                 "Failure Mode Identifier The FMI defines the type of failure detected in the subsystem identified by an SPN. Note that the failure may not be an electrical failure but may instead be a subsystem failure or condition needing to be reported to the service technician and maybe also to the operator. Conditions can include system events or status that need to be reported. The FMI, SPN, SPN Conversion Method and Occurrence Count fields combine to form a given diagnostic trouble code. The currently defined FMIs are listed in APPENDIX A. J1939-73",
					"value.proto_value.j1939_d1_statuses.occurance_count":     "Times this fault was seen",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJ1939D2Status,
			BinaryMessageField: "VehicleFaultEvent",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Previously Active Diagnostic Trouble Codes (DM2)",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.vehicle_fault_event.j1939_faults.tx_id":               "Vehicle ECU address sending faults",
					"value.proto_value.vehicle_fault_event.j1939_faults.mil_status":          "Malfunction Indicator Lamp (MIL). A lamp used to relay only emissions-related trouble code information. This lamp is only illuminated when there is an emission-related trouble code active. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.red_lamp_status":     "Flash Red Stop Lamp (RSL). This lamp is used to relay trouble code information that is of a severe enough condition that it warrants stopping the vehicle. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.amber_lamp_status":   "Flash Amber Warning Lamp (AWL) This parameter provides the capability to flash the AWL. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.protect_lamp_status": "Flash Protect Lamp (FPL). This parameter provides the capability to flash the protect lamp. Also see Table 5: Lamp Command and Lamp flash dependency definition for the specified operation of the applicable lamp and flash SPNs. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.spn":                 "Suspect Parameter Number. This 19-bit number is used to identify the item for which diagnostics are being reported. The SPN is used for multiple purposes, some of those that are specific to diagnostics are: 1. to identify a least repairable subsystem that has failed; 2. to identify subsystems and or assemblies that may not have hard failures but may be exhibiting abnormal operating performance; 3. identifying a particular event or condition that will be reported; and 4. to report a component and non-standard failure mode. SPNs are assigned to each individual parameter in a Parameter Group and to items that are relevant to diagnostics but are not a parameter in a Parameter Group. SPNs are independent of the source address for the message. However, the source address may be necessary to determine which controller on the network performed the diagnosis. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.fmi":                 "Failure Mode Identifier The FMI defines the type of failure detected in the subsystem identified by an SPN. Note that the failure may not be an electrical failure but may instead be a subsystem failure or condition needing to be reported to the service technician and maybe also to the operator. Conditions can include system events or status that need to be reported. The FMI, SPN, SPN Conversion Method and Occurrence Count fields combine to form a given diagnostic trouble code. The currently defined FMIs are listed in APPENDIX A. J1939-73",
					"value.proto_value.vehicle_fault_event.j1939_faults.occurance_count":     "Times this fault was seen",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DD1DieselParticulateFilterRegenControl1,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Particulate Filter Regeneration Control 1",
				Frequency:           FrequencyEveryXSeconds(60 * 60),
				IntValueDescription: "Regeneration control for diesel particulate filter 1. This information is combined into a single raw command to avoid overloading the logging paths on the VG. This will need to be interpreted in our data pipelines to parse out the individual flags from these messages.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DD2EngineOilLevelHighLowDeciLiter,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Oil Level High/Low (dL)",
				Frequency:           FrequencyEveryXSeconds(120),
				IntValueDescription: "High/low oil level measurement in deciliters",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DDEngineOilFilterDifferentialPressureExtendedRangeKiloPascal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Oil Filter Differential Pressure (Extended Range) (kPa)",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "Extended range measurement of the pressure drop across the oil filter",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DDEngineOilFilterDifferentialPressurePascals,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Oil Filter Differential Pressure (Pa)",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "Pressure drop across the oil filter",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DDFuelLevel2DeciPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Secondary Fuel Level (PGN 65276, SPN 38)",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Ratio of volume of fuel to the total volume of fuel in the second or right-side storage container, measured in decipercent",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DLCC1EngineOilPressureLowLampCommandState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Oil Pressure Low Lamp Command State",
				Frequency:           FrequencyEveryXSeconds(120),
				IntValueDescription: "Indicates if the low oil pressure lamp is commanded on",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DLCD1EngineOilPressureLowLampDataState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Oil Pressure Low Lamp Data State",
				Frequency:           FrequencyEveryXSeconds(120),
				IntValueDescription: "Actual status of the low oil pressure lamp",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DLCD1EngineOilTemperatureHighLampCommandState,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Tags: []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Oil Temperature High Lamp Command State",
				Frequency:           FrequencyEveryXSeconds(120),
				IntValueDescription: "Indicates if the high oil temperature lamp is commanded on",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DPF1S2Aftertreatment1DieselParticulateFilterSootSignalStandardDeviationMicroPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Diesel Particulate Filter (DPF) Soot Signal Standard Deviation (PGN 64761, SPN 5266, %)",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Measures the variation in diesel particulate filter soot levels to monitor system efficiency and potential regeneration needs.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DPFC1ExhaustSystemHighTemperatureLampCommandState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Exhaust System High Temperature Lamp Command State",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Status of high-temperature warning lamp",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDJ1939DpfRegenActiveStatus,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates the state of diesel particulate filter active regeneration on heavy duty vehicles (J1939) only",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: metadatahelpers.EnumDescription("The current DPF regen status", hubproto.J1939DpfRegenActiveStatus_name),
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDJ1939DpfRegenForcedStatus,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates the forced execution status of diesel particulate filter regeneration on heavy duty vehicles (J1939) only",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: metadatahelpers.EnumDescription("The current DPF regen forced Status", hubproto.J1939DpfRegenForcedStatus_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DpfRegenNeededStatus,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates the state of the diesel particulate filter regeneration need and urgency on heavy duty vehicles (J1939) only",
				Frequency:           FrequencyCustom("Every 5 minutes and on change of state"),
				IntValueDescription: metadatahelpers.EnumDescription("The current DPF regen needed status", hubproto.J1939DpfRegenNeededStatus_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939DpfRegenPassiveStatus,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates the state of diesel particulate filter passive regeneration on heavy duty vehicles (J1939) only",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: metadatahelpers.EnumDescription("The current DPF regen passive status", hubproto.J1939DpfRegenPassiveStatus_name),
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDJ1939EBC5EmergencyBrakingActiveState,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Active State of the Emergency Braking System (XBR).",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "0: emergency brake inactive, 1: emergency brake active",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDJ1939EBC5XBRActiveControlModeState,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Active Control Mode of the Emergency Braking System (XBR).",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "0: No brake demand being executed (default mode), 1: Driver's brake demand being executed, no external brake demand, 2: Addition mode of XBR acceleration control being executed, 3: Maximum mode of XBR acceleration control being executed, 4: XBR Brake Hold is being executed to hold the vehicle still based on XBR Brake Hold Request",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDJ1939EBC5XBRSystemStateState,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "State of the Emergency Braking System (XBR).",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "0: operational, 1: high-priority only, 2: not operational",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EEC5EngineExhaustGasRecirculation1Valve1Control1MicroPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Exhaust Gas Recirculation 1 Valve 1 Control (%)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Control percentage of EGR valve 1",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EEC7EngineCrankcaseBreatherOilSeparatorSpeedRPM,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Crankcase Breather Oil Separator Speed (RPM)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Speed of the crankcase breather oil separator",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EEC8EngineExhaustGasRecirculation1CoolerEfficiencyDeciPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Exhaust Gas Recirculation 1 Cooler Efficiency (%)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Efficiency rating of the EGR cooler",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EEC8EngineExhaustGasRecirculation1Valve2ControlMicroPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Exhaust Gas Recirculation 1 Valve 2 Control (%)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Control percentage of the second EGR valve",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EFLP10EngineCoolantPressure2Kilopascals,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Coolant Pressure 2",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Gage pressure of liquid found in the engine coolant system - second instance.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EFLP1EngineCoolantLevel1DeciPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Coolant Level 1",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Ratio of volume of liquid found in engine cooling system to total cooling system volume. Typical monitoring location is in the coolant expansion tank.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EFLP1EngineCoolantPressureKilopascals,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Coolant Pressure 1",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Gage pressure of liquid found in engine cooling system.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EFLP2EngineCrankcasePressure1MicroPascal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Crankcase Pressure 1 (Pa)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "MicroPascal reading of crankcase pressure",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EGF1EngineExhaustGasRecirculation1MassFlowRateGramsPerHours,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Exhaust Gas Recirculation (EGR) 1 Mass Flow Rate (PGN 61450, SPN 2659, g/h)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Monitors the mass flow rate of exhaust gas recirculation (EGR) to ensure proper operation and emissions compliance.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EOMEngineOilDensityNanoGramsPerCubicCentimeters,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Oil Density (ng/cm)",
				Frequency:           FrequencyEveryXSeconds(60),
				IntValueDescription: "Density of engine oil in nanograms per cubic centimeter",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939EPSIAftertreatment1ParticulateSensorNanoGramsPerMeterCubed,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Aftertreatment 1 Particulate Sensor (ng/m)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Measurement of particulate matter from the sensor",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939ET1EngineFuelTemperature1Celsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Fuel Temperature 1 (C)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Temperature of engine fuel measured at primary location",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939ET1EngineOilTemperature1MicroCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Oil Temperature 1 (C)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Temperature of engine oil at primary measurement location",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939ET4EngineCoolantPumpOutletTemperatureCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Coolant Pump Outlet Temperature (PGN 64870, SPN 4193)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Measures the temperature of coolant at the outlet of the coolant pump to monitor cooling system performance.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939FLI1DriverAlertnessWarning,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates when a distracted driving condition is detected. This signal can be used independent of the technology and ECU used to estimate the distracted driver condition.",
				Frequency:           FrequencyOnChange("50ms when active"),
				IntValueDescription: metadatahelpers.EnumDescription("The warning level", hubproto.FLI1DriverAlertnessWarning_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939FLI1LaneDepartureImminentLeftSideState,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates departure imminent on left side of lane",
				Frequency:           FrequencyOnChange("50ms when active"),
				IntValueDescription: metadatahelpers.EnumDescription("The imminent departure status", hubproto.FLI1LaneDepartureImminent_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939FLI1LaneDepartureImminentRightSideState,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates departure imminent on right side of lane",
				Frequency:           FrequencyOnChange("50ms when active"),
				IntValueDescription: metadatahelpers.EnumDescription("The imminent departure status", hubproto.FLI1LaneDepartureImminent_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939FLI1LaneDepartureLeftState,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates that the middle of vehicle has departed the lane on the left side",
				Frequency:           FrequencyOnChange("50ms when active"),
				IntValueDescription: metadatahelpers.EnumDescription("The departure status", hubproto.FLI1LaneDeparture_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939FLI1LaneDepartureRightState,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicates that the middle of vehicle has departed the lane on the right side",
				Frequency:           FrequencyOnChange("50ms when active"),
				IntValueDescription: metadatahelpers.EnumDescription("The departure status", hubproto.FLI1LaneDeparture_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939FLI2LaneDepartureIndicationEnableStatusState,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "State of the truck's embeddedLane Departure Indication system",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "0: disabled, 1: enabled",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939IC1EngineAirFilter1DifferentialPressurePascals,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Air Filter 1 Differential Pressure (Pa)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Pressure differential across the engine air filter",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939IC1EngineExhaustTemperatureMicroCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Exhaust Temperature (PGN 65270, SPN 173, C)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Measures the exhaust gas temperature from the engine, which is critical for monitoring combustion efficiency and detecting overheating conditions.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939OELHazardLightSwitchState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reports the status of the hazard signal",
				Frequency:           FrequencyOnChange("No more than every Second, once every hour otherwise"),
				IntValueDescription: "0 OFF, 1 ON",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939OELTurnSignalSwitchState,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Reports the status of the turn signal indicator",
				Frequency:           FrequencyOnChange("No more than every 100ms, once every 60s otherwise"),
				IntValueDescription: metadatahelpers.EnumDescription("The status of the turn signal", hubproto.OELTurnSignalSwitch_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939PropAnalogInputCurrent1MicroAmps,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939PropAnalogInputCurrent2MicroAmps,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939PropAnalogInputCurrent3MicroAmps,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939PropAnalogInputVoltage1MilliVolts,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939PropAnalogInputVoltage2MilliVolts,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939PropAnalogInputVoltage3MilliVolts,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939SHUTDNEngineWaitToStartLampState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Wait to Start Lamp State",
				Frequency:           FrequencyEveryXSeconds(10),
				IntValueDescription: "Indicates the state of the wait-to-start lamp",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939TCEngineTurbochargerLubeOilPressure1Kilopascals,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Turbocharger Lube Oil Pressure 1 (kPa)",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Lubrication oil pressure for turbocharger",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939TCI6EngineTurbocharger1CompressorOutletTemperatureMicroCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Engine Turbocharger 1 Compressor Outlet Temperature (C)",
				Frequency:           FrequencyEveryXSeconds(30),
				IntValueDescription: "Temperature of compressed air from the turbocharger",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939TRF1TransmissionOilPressureKilopascals,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Transmission 1 Oil Pressure",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Gage pressure of lubrication fluid in transmission 1, measured after pump.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939TRF1TransmissionOilTemperature1MicroCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Transmission 1 Oil Temperature 1",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "First instance of transmission 1 lubricant temperature.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939TRF2Transmission1MainOilPressureStatus,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Transmission 1 Main Oil Pressure Status",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Indicates whether or not current transmission main pressure is sufficient for transmission operation. In some applications, transmission main pressure is colloquially referred to as transmission boost pressure or transmission line pressure.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939TRF2TransmissionOilTemperature2MicroCelsius,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Transmission Oil Temperature 2",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Second instance of transmission lubricant temperature. This parameter may reflect the temperature of a second sump or oil supply. If only one instance of transmission lubricant temperature measurement exists, SPN 177 Transmission Oil Temperature 1 should be used.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDJ1939VHTotalVehicleHoursCentiHr,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total vehicle hours from J1939 data (centi-hours)",
				Frequency:           FrequencyOnChange("reported after every 3 minutes of vehicle time accumulated"),
				IntValueDescription: "Total vehicle hours in centihours (1/100th of an hour). J1939 PGN 65255, SPN 246",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osdJammingDetection,
			BinaryMessageField: "JammingDetection",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Logs aggregated jamming detection state for multiple radios",
				Frequency:   FrequencyOnChange("every hour or jamming detection state change for any radio"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.jamming_detection.source_states":                        "List of all radio sources with jamming detection enabled and their jamming detection states",
					"value.proto_value.jamming_detection.source_states.source":                 metadatahelpers.EnumDescription("The radio source", hubproto.JammingDetection_SourceState_JammingDetectionSource_name),
					"value.proto_value.jamming_detection.source_states.state":                  metadatahelpers.EnumDescription("The jamming detection state for this radio source", hubproto.JammingDetection_SourceState_JammingDetectionState_name),
					"value.proto_value.jamming_detection.source_states.last_change_at_ms":      "Absolute timestamp (Unix time) that this radio source's jamming detection state changed last",
					"value.proto_value.jamming_detection.last_location":                        "The most recent complete location from GPS",
					"value.proto_value.jamming_detection.last_location.location_time_unix_ms":  "Absolute timestamp (Unix time) of the last location",
					"value.proto_value.jamming_detection.last_location.latitude_nano_degrees":  "Latitude (nanodegrees) of the last location",
					"value.proto_value.jamming_detection.last_location.longitude_nano_degrees": "Longitude (nanodegrees) of the last location",
					"value.proto_value.jamming_detection.last_location.accuracy_mm":            "Accuracy (millimeters) of the last location",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJetsonMetrics,
			BinaryMessageField: "JetsonMetrics",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.MulticamTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:            "Logs metrics when the TX2 board startsup. This is done when the system starts up, and reads several files which contain information about system reset, parses them, and reports their contents as this objectstat. Only used on perseus and vision devices.",
				Frequency:              FrequencyOnChange("TX2 startup"),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.jetson_metrics.reset_reason.pmc_reset_level":  "PMIC reset level value populated by the PMIC driver as part of their probe() function.",
					"value.proto_value.jetson_metrics.reset_reason.pmic_register":    "PMIC register value populated by the PMIC driver as part of their probe() function.",
					"value.proto_value.jetson_metrics.reset_reason.pmc_reset_source": "PMC reset source value populated by the PMC driver as part of their probe() function.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJetsonPowerStats,
			BinaryMessageField: "JetsonPowerStats",
			Kind:               StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDJetsonThermalStats,
			BinaryMessageField: "JetsonThermalStats",
			Kind:               StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDLaneCenteringSystemStatus,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Lane Centering System Status",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "Status of the automated lane centering system, if fitted on the vehicle.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDLaneDepartureWarningSystemState,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "State of the truck's embedded Lane Departure Warning System",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "0: System is not ready (initialization not finished), 1: System is temporarily not available (not all activation conditions fulfilled), 2: System is deactivated by driver, 3: System is ready (no warnings active), 4: Active warning suppressed by operator behavior (e.g. turn signal), 5: System is warning lane departure, 6-13: Reserved, 14: Error",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDLifetimeFuelConsumed,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total lifetime fuel consumed (ml) on heavy duty vehicles",
				Frequency:           FrequencyEveryXSeconds(2 * samtime.SecondsInMinute),
				IntValueDescription: "Total lifetime fuel consumed (ml). J1939-DA PGN 65257 Fuel Consumption (Liquid) 1, SPN 250",
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDLivestreamWebRTCTelemetry,
			BinaryMessageField:       "LivestreamWebrtcTelemetry",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLmRadarAdcData,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "LmRadarAdcData",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.BifrostTag},
			MetadataInfo: &MetadataInfo{
				Description: "Raw ADC data from radar sensors on land management devices",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.lm_radar_adc_data.adc_data":        "Raw ADC data bytes",
					"value.proto_value.lm_radar_adc_data.data_offset_idx": "Offset index for the data",
					"value.proto_value.lm_radar_adc_data.sequence_id":     "Sequence ID to correlate with LmRadarData",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLmRadarData,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "LmRadarData",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.BifrostTag},
			MetadataInfo: &MetadataInfo{
				Description: "Radar sensor data from land management devices",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.lm_radar_data.distance_mm": "Distance measurement in millimeters",
					"value.proto_value.lm_radar_data.snr":         "Signal-to-noise ratio",
					"value.proto_value.lm_radar_data.noise":       "Noise level measurement",
					"value.proto_value.lm_radar_data.sequence_id": "Sequence ID for data correlation",
					"value.proto_value.lm_radar_data.accel_data":  "Accelerometer data if available",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLmRadarPointCloudData,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "LmRadarPointCloudData",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.BifrostTag},
			MetadataInfo: &MetadataInfo{
				Description: "Point cloud data from radar sensors on land management devices",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.lm_radar_point_cloud_data.points":      "Array of LmRadarData points representing the point cloud",
					"value.proto_value.lm_radar_point_cloud_data.sequence_id": "Sequence ID to correlate with LmRadarData",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLocation,
			BinaryMessageField: "AssetLocation",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "[NOT PERSISTED - DO NOT USE] The osDLocation object stat isn't persisted. Use kinesisstats.location instead.",
				Frequency:           FrequencyEveryXSeconds(5),
				IntValueDescription: "Unused",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLocationWithRoadContext,
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Production:         true,
			BinaryMessageField: "LocationWithRoadContext",
			MetadataInfo: &MetadataInfo{
				Description: "Location with road context",
				Frequency:   FrequencyEveryXSeconds(60 * 5),
				ColumnDescriptions: map[string]string{
					"value.proto_value.location_with_road_context.latitude":                      "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.longitude":                     "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.has_fix":                       "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.has_revgeo":                    "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.revgeo_city":                   "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.revgeo_state":                  "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.revgeo_country":                "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.has_toll":                      "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.toll":                          "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.gps_speed_meters_per_second":   "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.heading_degrees":               "Passed as is from location stats. Check kinesisstats.location for more details.",
					"value.proto_value.location_with_road_context.hdop":                          "Horizontal Dilution of Precision - values >3 indicate poor satellite geometry",
					"value.proto_value.location_with_road_context.accuracy_millimeters":          "GPS horizontal accuracy in millimeters. Values >30000 (30m) indicate poor accuracy",
					"value.proto_value.location_with_road_context.accuracy_invalid":              "True if accuracy_millimeters is not available or invalid",
					"value.proto_value.location_with_road_context.has_way_id":                    "If there is valid way id",
					"value.proto_value.location_with_road_context.way_id":                        "Way id for current latitude and longitude points",
					"value.proto_value.location_with_road_context.has_road_class":                "If there is valid road class",
					"value.proto_value.location_with_road_context.road_class":                    "Road class for current latitude and longitude points",
					"value.proto_value.location_with_road_context.has_speed_limit":               "If there is valid speed limit",
					"value.proto_value.location_with_road_context.speed_limit_meters_per_second": "Speed limit for current latitude and longitude in meters per second",
					"value.proto_value.location_with_road_context.has_ifta_geofence_exemption":   "Indicates if the location is inside an IFTA-exempt geofence",
					"value.proto_value.location_with_road_context.ifta_geofence_exemption_types": "Array of IFTA exemption type codes: 0=UNSPECIFIED, 1=PRIVATE_ROAD, 2=OFF_HIGHWAY",
					"value.proto_value.location_with_road_context.ifta_exempt_place_id":          "Place ID of the IFTA-exempt geofence",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				UseTieredSchedule:   true,
				DisableDeletionTask: true,
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						PartitionChunkSize: pointer.IntPtr(50),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLogEventsDeleted,
			BinaryMessageField: "LogDeletionInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Gateway SQLite database table deletion information",
				Frequency:   FrequencyEveryXSeconds(10 * samtime.SecondsInMinute),
				ColumnDescriptions: map[string]string{
					"value.proto_value.log_deletion_info.number_of_deleted_events": "Log events deleted due to max log limit reached",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLogNetworkInterfaceStats,
			BinaryMessageField: "NetworkInterfaceStats",
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Kind: StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Network stats per interface (eth0, eth1, etc.) for a gateway.",
				Frequency:   FrequencyEveryXSeconds(60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.network_interface_stats":                  "A struct detailing the network stats per interface.",
					"value.proto_value.network_interface_stats.interface":        metadatahelpers.EnumDescription("The network interface reported", hubproto.NetworkInterfaceType_name),
					"value.proto_value.network_interface_stats.rx_bytes_per_sec": "Received bytes per second for this interface",
					"value.proto_value.network_interface_stats.tx_bytes_per_sec": "Transmitted bytes per second for this interface",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDLogTableOldestLogTimeMs,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Oldest log entry currently on a device",
				Frequency:           FrequencyOnChange("number of rows in the sqlite database increases"),
				IntValueDescription: "Oldest log entry currently on a device. Reported as the time between the current device boot and the time the oldest event was logged.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDLogTableSizeNumRows,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Count of rows on a devices log table in a sqlite database.",
				Frequency:           FrequencyOnChange("number of rows in the sqlite database increases"),
				IntValueDescription: "Count of rows on a devices log table in a sqlite database.",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLookbackBrakeScore,
			BinaryMessageField: "BrakeScore",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Brake score using lookback to find lowest window of time with qualified score",
				Frequency:   FrequencyCustom("Once every six hours."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.brake_score.braking_effort_percent_score":                             "Braking effort estimated at 6.5 bar pressure",
					"value.proto_value.brake_score.metadata.measured_pressure_bar":                           "The pressure at which it was measured",
					"value.proto_value.brake_score.metadata.version":                                         "The version of the brake score algorithm",
					"value.proto_value.brake_score.metadata.margin_of_error":                                 "The margin of error",
					"value.proto_value.brake_score.metadata.confidence_interval":                             "Confidence interval at 95% confidence",
					"value.proto_value.brake_score.metadata.regression_slope":                                "Slope of regression line of brake demand pressure vs. performance",
					"value.proto_value.brake_score.metadata.regression_brake_performance_intercept":          "Braking performance intercept of regression line of brake demand pressure vs. performance",
					"value.proto_value.brake_score.start_time_ms":                                            "Start timestamp of the range, end timestamp would be the time of the object stat",
					"value.proto_value.brake_score.event_count":                                              "Number of brake events used",
					"value.proto_value.brake_score.event_below_threshold_count":                              "Number of brake events below the brake performance threshold",
					"value.proto_value.brake_score.weighted_braking_effort_percent_score":                    "Weighted braking effort estimated at 6.5 bar pressure (emphasizes points converging to the line)",
					"value.proto_value.brake_score.weighted_metadata.measured_pressure_bar":                  "The pressure at which the weighted score was measured",
					"value.proto_value.brake_score.weighted_metadata.version":                                "The version of the brake score algorithm for the weighted score",
					"value.proto_value.brake_score.weighted_metadata.margin_of_error":                        "The margin of error for the weighted score",
					"value.proto_value.brake_score.weighted_metadata.confidence_interval":                    "Confidence interval at 95% confidence for the weighted score",
					"value.proto_value.brake_score.weighted_metadata.regression_slope":                       "Slope of regression line for the weighted brake score",
					"value.proto_value.brake_score.weighted_metadata.regression_brake_performance_intercept": "Braking performance intercept for the weighted brake score",
					"value.proto_value.brake_score.check_ebs_metadata":                                       "Metadata used to track the state of the Check EBS label surfaced to customers. Populated only when the label is applicable for the score window.",
					"value.proto_value.brake_score.check_ebs_metadata.active":                                "Whether the Check EBS label should be shown for this score's window.",
					"value.proto_value.brake_score.check_ebs_metadata.last_triggered_at_ms":                  "Last time we saw a qualifying event exceeding the configured pressure threshold within the score window.",
					"value.proto_value.brake_score.check_ebs_metadata.trigger_count":                         "Number of qualifying events exceeding the configured pressure threshold within the score window.",
					"value.proto_value.brake_score.check_ebs_metadata.threshold_pressure_bar":                "Pressure bar threshold for indicating a potential issue with the EBS system.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLowBridgeStrikeWarningEvent,
			BinaryMessageField: "LowBridgeStrikeWarningEvent",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Low bridge strike warning event",
				Frequency:   FrequencyCustom("Reported when an upcoming bridge satisfies the necessary distance/ways away trigger conditions and the vehicle height exceeds the height of the bridge"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.low_bridge_strike_warning_event.event_id":                                        "Unique identifier for the event",
					"value.proto_value.low_bridge_strike_warning_event.config":                                          "LowBridgeStrikeConfig running on device at the time",
					"value.proto_value.low_bridge_strike_warning_event.ways_away_threshold_triggered":                   "Was vehicle within ways away threshold of bridge way",
					"value.proto_value.low_bridge_strike_warning_event.distance_threshold_triggered":                    "Was vehicle within distance threshold of bridge node",
					"value.proto_value.low_bridge_strike_warning_event.height_threshold_triggered":                      "Was bridge height < vehicle height + height buffer",
					"value.proto_value.low_bridge_strike_warning_event.hidden_to_customer":                              "Should the event be hidden from the customer due to shadow mode / data collection mode",
					"value.proto_value.low_bridge_strike_warning_event.bridge_way_id":                                   "Way intersected by bridge overpass",
					"value.proto_value.low_bridge_strike_warning_event.bridge_height_meters":                            "Height of bridge overpass intersecting bridge_way_id",
					"value.proto_value.low_bridge_strike_warning_event.parent_node":                                     "Node of current way that a vehicle must go through to reach the bridge node",
					"value.proto_value.low_bridge_strike_warning_event.bridge_node":                                     "Node of bridge_way_id closest to current way",
					"value.proto_value.low_bridge_strike_warning_event.ways_away_from_bridge_way":                       "Number of ways between current way (inclusive) and bridge_way_id (exclusive)",
					"value.proto_value.low_bridge_strike_warning_event.distance_to_bridge_node_meters":                  "Distance between current location and bridge node (distance_to_parent_node_meters + parent_node_to_bridge_node_distance_meters)",
					"value.proto_value.low_bridge_strike_warning_event.distance_to_parent_node_meters":                  "Distance between current location and parent node",
					"value.proto_value.low_bridge_strike_warning_event.parent_node_to_bridge_node_distance_meters":      "Sum of the lengths of the ways in between parent node and bridge node",
					"value.proto_value.low_bridge_strike_warning_event.current_location_to_parent_node_heading_degrees": "Direction of parent node from current map matched location",
					"value.proto_value.low_bridge_strike_warning_event.current_osrm_match":                              "Current OSRM map matched location data used",
					"value.proto_value.low_bridge_strike_warning_event.current_gps":                                     "Current GPS location data used",
					"value.proto_value.low_bridge_strike_warning_event.current_tile_info":                               "Current map tile data loaded",
					"value.proto_value.low_bridge_strike_warning_event.bridge_group_id":                                 "Bridge group that the bridge way belongs to",
				},
			},
			ksFieldsToExclude: []string{
				// Exclude layers because of a bug in LayeredTileManager causing empty layers to have garbage data in the server_last_modified field, preventing replication.
				"value.proto_value.low_bridge_strike_warning_event.current_tile_info.layers",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDLuftConnected,
			BinaryMessageField: "LuftConnected",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Luft cable connection event",
				Frequency:   FrequencyOnChange("on connection"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.luft_connected.serial_number":                    "Luft serial number",
					"value.proto_value.luft_connected.firmware_version_reefer_port":     "Firmware verison for reefer port",
					"value.proto_value.luft_connected.firmware_version_display_port":    "Firmware version for display port",
					"value.proto_value.luft_connected.firmware_version_tachograph_port": "Firmware version for tachograph port.",
					"value.proto_value.luft_connected.mcu_revision":                     metadatahelpers.EnumDescription("Surfaces the MCU in use for luft. The chipset was changed due to COVID shortages.", hubproto.ObjectStatBinaryMessage_LuftConnected_McuRevision_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMarathonEvent,
			BinaryMessageField: "MarathonEvent",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "An anomaly (error) OR normal event (trace) that has occurred",
				Frequency:   FrequencyCustom("Determined by the Firmware as needed"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.marathon_event.event_type":       metadatahelpers.EnumDescription("The event type", nrfzephyrproto.MarathonEvent_EventType_name),
					"value.proto_value.marathon_event.event_verbosity":  metadatahelpers.EnumDescription("The event verbosity level", nrfzephyrproto.MarathonEvent_EventVerbosity_name),
					"value.proto_value.marathon_event.event_id":         "The type of event being recorded, controlled in firmware-nrf-zephyr repo, workspace/samsara/common/inc/events.h",
					"value.proto_value.marathon_event.code_version":     "Build number of current running firmware, see marathonevent.proto for scheme",
					"value.proto_value.marathon_event.function_name":    "Name of function where event log was invoked",
					"value.proto_value.marathon_event.file_line_number": "Line number in file where event log was invoked",
					"value.proto_value.marathon_event.generic_int64":    "Generic storage for an array of int64, contents are event specific",
					"value.proto_value.marathon_event.generic_string":   "Generic storage for a string, contents are event specific",
					"value.proto_value.marathon_event.generic_bytes":    "Generic storage for an array of arbitrary bytes, contents are event specific",
					"value.proto_value.marathon_event.soc":              "Which SoC created the event",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMarathonFirmwareVersions,
			BinaryMessageField: "MarathonFirmwareVersions",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Versions of the multiple firmware images installed on the device",
				Frequency:   FrequencyCustom("Determined by the Firmware as needed, normally once at boot"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.marathon_firmware_versions.image_type":     metadatahelpers.EnumDescription("The image type", nrfzephyrproto.MarathonFirmwareVersion_ImageType_name),
					"value.proto_value.marathon_firmware_versions.build_number":   "Current build number installed when the metrics were reported",
					"value.proto_value.marathon_firmware_versions.version_string": "Current version string installed when the metrics were reported",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMarathonGnssDebug,
			BinaryMessageField: "MarathonGnssDebug",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
				amundsentags.AG53Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Stream-oriented GNSS debug stat. Streams are grouped by search_cui, indiciating what GNSS search a debug stat belongs.",
				Frequency:   FrequencyCustom("Enabled by config, per Position-Velocity-Time (PVT) event from the GNSS receiver, approx. 1 Hz while searching."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.marathon_gnss_debug.search_cui":                                "The contextually-unique ID of the GNSS location search to which this stat belongs",
					"value.proto_value.marathon_gnss_debug.satellite_infos":                           "Satellites visisible to the GNSS receiver this PVT",
					"value.proto_value.marathon_gnss_debug.satellite_infos.constellation":             "Constellation to which this satellite belongs",
					"value.proto_value.marathon_gnss_debug.satellite_infos.sv_id":                     "ID of the satellite",
					"value.proto_value.marathon_gnss_debug.satellite_infos.cn0_tenths_db_per_hz":      "CN/0 in tenths DB/Hz",
					"value.proto_value.marathon_gnss_debug.satellite_infos.elevation_angle_deg":       "Elevation of satellite in degrees",
					"value.proto_value.marathon_gnss_debug.satellite_infos.azimuth_angle_deg":         "Azimuth of the satellite in degrees",
					"value.proto_value.marathon_gnss_debug.satellite_infos.used_in_gps_fix":           "1 if the satellite was used to achieve a fix, 0 if not",
					"value.proto_value.marathon_gnss_debug.satellites_seen":                           "Number of satellites seen this event",
					"value.proto_value.marathon_gnss_debug.satellites_used":                           "Number of satellites used by the GNSS receiver this event",
					"value.proto_value.marathon_gnss_debug.gnss_fix":                                  "The fix achieved this event, if available (null if no fix was available)",
					"value.proto_value.marathon_gnss_debug.gnss_fix.latitude_nd":                      "Latitude of the fix in nanodegrees",
					"value.proto_value.marathon_gnss_debug.gnss_fix.longitude_nd":                     "Longitude of the fix in nanodegrees",
					"value.proto_value.marathon_gnss_debug.gnss_fix.altitude_mm":                      "Altitude in millimeters",
					"value.proto_value.marathon_gnss_debug.gnss_fix.accuracy_mm":                      "Estimated accuracy of the fix provided by the GNSS receiver",
					"value.proto_value.marathon_gnss_debug.gnss_fix.speed_mm_per_s":                   "Ground speed provided by the GNSS receiver in millimeters per second",
					"value.proto_value.marathon_gnss_debug.gnss_fix.heading_md":                       "Heading in millidegrees",
					"value.proto_value.marathon_gnss_debug.gnss_fix.pdop_thousandths":                 "Position Dilution of Precision of the fix",
					"value.proto_value.marathon_gnss_debug.gnss_fix.hdop_thousandths":                 "Horizontal Dilution of Precision of the fix",
					"value.proto_value.marathon_gnss_debug.gnss_fix.vdop_thousandths":                 "Vertical Dilution of Precision of the fix",
					"value.proto_value.marathon_gnss_debug.gnss_fix.tdop_thousandths":                 "Time Dilution of Precision of the fix",
					"value.proto_value.marathon_gnss_debug.gnss_fix.speed_accuracy_mm_per_s":          "Estimated accuracy of speed in millimeters per second",
					"value.proto_value.marathon_gnss_debug.gnss_fix.vertical_speed_mm_per_s":          "Vertical speed in millimeters per second",
					"value.proto_value.marathon_gnss_debug.gnss_fix.vertical_speed_accuracy_mm_per_s": "Estimated accuracy of vertical speed in millimeters per second",
					"value.proto_value.marathon_gnss_debug.gnss_fix.heading_accuracy_md":              "Estimated heading accuracy in millidegrees",
					"value.proto_value.marathon_gnss_debug.gnss_fix.altitude_accuracy_mm":             "Estimated altitude accuracy in millimeters",
					"value.proto_value.marathon_gnss_debug.time_since_search_start_ms":                "Time (in milliseconds) since the start of the search in which the event was received from the GNSS receiver",
					"value.proto_value.marathon_gnss_debug.fix_type":                                  metadatahelpers.EnumDescription("The fix type", nrfzephyrproto.GnssDebug_FixType_name),
					"value.proto_value.marathon_gnss_debug.receiver_specific_flags":                   "Flags for the event, specific to the GNSS receiver in use",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMarathonJotterStats,
			BinaryMessageField: "MarathonJotterStats",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Marathon runtime health information related to jotter cache and flash usage",
				Frequency:   FrequencyCustom("Log period is configurable.  Defaults to once every 7 days or whenever a configurable threshold is crossed."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.marathon_jotter_stats":                                                                "A struct containing jotter runtime health stats for a list of marathon socs.",
					"value.proto_value.marathon_jotter_stats.soc_list":                                                       "A list of each soc, in the marathon system that runs a jotter.",
					"value.proto_value.marathon_jotter_stats.soc_list.soc":                                                   metadatahelpers.EnumDescription("A named SOC representing a specific hardware chip that runs code in a marathon system.", nrfzephyrproto.NordicSoc_name),
					"value.proto_value.marathon_jotter_stats.soc_list.firmware_build":                                        "A simple representation of the firmware build running on the device that sent the stat.  This will make it easier to associate stats with releases.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats":                                          "A struct containing information about jotter health on a particular Marathon application processor.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.category":                                 metadatahelpers.EnumDescription("A list of Jotter categories supported by the marathon system.", nrfzephyrproto.JotterStats_JotterCategory_name),
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.ram_cache_usage":                          "A struct containing information about how full this jotter cache has gotten since boot.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.ram_cache_usage.current_bytes_allocated":  "Current number of bytes allocated by this jotter cache.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.ram_cache_usage.current_blocks_allocated": "Current number of blocks allocated by this jotter cache.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.ram_cache_usage.max_bytes_allocated":      "Max number of bytes allocated by this jotter cache.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.ram_cache_usage.max_blocks_allocated":     "Max number of blocks allocated by this jotter cache.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.ram_cache_usage.capacity_bytes":           "Total capacity of this jotter cache.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.flash_usage":                              "Struct containing useful information about the flash usage of this jotter category",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.flash_usage.current_bytes_used":           "Number of bytes currently in use in flash for this jotter category.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.flash_usage.max_bytes_used":               "Max number of bytes used in flash for this jotter category since boot.",
					"value.proto_value.marathon_jotter_stats.soc_list.jotter_stats.flash_usage.capacity_bytes":               "Total flash capacity in bytes for this jotter category.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMarathonMovement,
			BinaryMessageField: "MarathonMovement",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Device movement detection events",
				Frequency:   FrequencyCustom("Logged when device is in movement or a movement change is detected"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.marathon_movement.motion_event":       metadatahelpers.EnumDescription("Detected movement event type", nrfzephyrproto.MotionEvent_Type_name),
					"value.proto_value.marathon_movement.debug.variance_g":   "Population variance of accelerometer maginute (G squared)",
					"value.proto_value.marathon_movement.debug.mean_g":       "Mean of accelerometer magnitude (G)",
					"value.proto_value.marathon_movement.debug.max_g":        "Max of accelerometer magnitude (G)",
					"value.proto_value.marathon_movement.debug.min_g":        "Min of accelerometer magnitude (G)",
					"value.proto_value.marathon_movement.debug.timestamp_ms": "Time of data sample (UTC)",
					"value.proto_value.marathon_movement.debug.data":         "Other debug data - for future use.",
					"value.proto_value.marathon_movement.start_ms":           "Start of event (UTC)",
					"value.proto_value.marathon_movement.duration_ms":        "Duration of the event (milliseconds)",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMarathonOrientation,
			BinaryMessageField: "MarathonOrientation",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Device orientation reading from the accelerometer",
				Frequency:   FrequencyCustom("Logged when device orientation changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.marathon_orientation.orientation": metadatahelpers.EnumDescription("Which of the six device sides is currently pointing down towards the center of the Earth", nrfzephyrproto.MarathonOrientation_Orientation_name),
					"value.proto_value.marathon_orientation.x_ug":        "Acceleration reading on X-axis in ug",
					"value.proto_value.marathon_orientation.y_ug":        "Acceleration reading on Y-axis in ug",
					"value.proto_value.marathon_orientation.z_ug":        "Acceleration reading on Z-axis in ug",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMarathonRawCanDebug,
			BinaryMessageField: "MarathonRawCanDebug",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag, amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Message to log raw CAN data. Used for debugging and investigations.",
				Frequency:   FrequencyCustom("As needed. Determined by the app or user"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.marathon_raw_can_debug.total_log_event_duration_ms":           "Duration of the logging event",
					"value.proto_value.marathon_raw_can_debug.log_reason":                            metadatahelpers.EnumDescription("The reason the entry was logged", nrfzephyrproto.MarathonRawCanDebug_LogReason_name),
					"value.proto_value.marathon_raw_can_debug.baud_rate":                             metadatahelpers.EnumDescription("Baud rate of the channel at time of collection", nrfzephyrproto.BaudRate_name),
					"value.proto_value.marathon_raw_can_debug.can_log":                               "A list of messages recorded during the logging session",
					"value.proto_value.marathon_raw_can_debug.can_log.protocol_type":                 metadatahelpers.EnumDescription("The protocol the message was fed from", nrfzephyrproto.ProtocolType_name),
					"value.proto_value.marathon_raw_can_debug.can_log.log_start_to_message_delta_ms": "Delta time between messages",
					"value.proto_value.marathon_raw_can_debug.can_log.is_tx":                         "If the message was sent by us",
					"value.proto_value.marathon_raw_can_debug.can_log.msg_id":                        "The message ID of the message",
					"value.proto_value.marathon_raw_can_debug.can_log.data_bytes":                    "Raw data bytes seen on the network",
					"value.proto_value.marathon_raw_can_debug.can_log.num_times_message_observed":    "Number of times this message ID was seen in the duration of the event",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMarathonRuntimeHealthStats,
			BinaryMessageField: "MarathonRuntimeHealthStats",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Marathon runtime health information related to heap, stacks and threads",
				Frequency:   FrequencyCustom("Log period is configurable.  Defaults to once every 7 days or whenever a configurable threshold is crossed."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.marathon_runtime_health_stats":                                                 "A struct containing runtime health stats for a list of devices in marathon system.",
					"value.proto_value.marathon_runtime_health_stats.soc_list":                                        "A list of each soc, in the marathon system, with thread and heap info for each Soc",
					"value.proto_value.marathon_runtime_health_stats.soc_list.soc":                                    metadatahelpers.EnumDescription("A named SOC representing a specific hardware chip that runs code in a marathon system", nrfzephyrproto.NordicSoc_name),
					"value.proto_value.marathon_runtime_health_stats.soc_list.firmware_build":                         "A simple representation of the firmware build running on the device that sent the stat.  This will make it easier to associate stats with releases.",
					"value.proto_value.marathon_runtime_health_stats.soc_list.heap_stats":                             "A list of useful stats related to our application heap usage",
					"value.proto_value.marathon_runtime_health_stats.soc_list.heap_stats.current_bytes_allocated":     "Current number of bytes allocated by Marathon application heap",
					"value.proto_value.marathon_runtime_health_stats.soc_list.heap_stats.current_blocks_allocated":    "Current number of blocks allocated by Marathon application heap",
					"value.proto_value.marathon_runtime_health_stats.soc_list.heap_stats.max_bytes_allocated":         "Max number of bytes allocated by Marathon application heap since boot",
					"value.proto_value.marathon_runtime_health_stats.soc_list.heap_stats.max_blocks_allocated":        "Max number of blocks allocated by Marathon application heap since boot",
					"value.proto_value.marathon_runtime_health_stats.soc_list.heap_stats.capacity_bytes":              "Total capacity of Marathon application heap",
					"value.proto_value.marathon_runtime_health_stats.soc_list.sys_heap_stats":                         "A list of useful stats related to our system heap usage; only current bytes and capacity are filled at this time",
					"value.proto_value.marathon_runtime_health_stats.soc_list.sys_heap_stats.current_bytes_allocated": "Current number of bytes allocated by Marathon system heap",
					"value.proto_value.marathon_runtime_health_stats.soc_list.sys_heap_stats.capacity_bytes":          "Total capacity of Marathon system heap",
					"value.proto_value.marathon_runtime_health_stats.soc_list.thread_stats":                           "A structure of stats on a specific thread running in the system",
					"value.proto_value.marathon_runtime_health_stats.soc_list.total_thread_execution_cycles":          "A count of total tics since the device has bootd.  Useful for determining thread usage on a per thread basis.",
					"value.proto_value.marathon_runtime_health_stats.soc_list.thread_stats.id":                        "Thread ID of the Zephyr thread.  In Zephyr this is just pointer to the thread so it can change from firmware to firmware for the same thread.",
					"value.proto_value.marathon_runtime_health_stats.soc_list.thread_stats.name":                      "The name of the Zephyr thread. This should be consistent from build to build.",
					"value.proto_value.marathon_runtime_health_stats.soc_list.thread_stats.runtime_percent":           "The percent of time this thread has run since boot.",
					"value.proto_value.marathon_runtime_health_stats.soc_list.thread_stats.stack_size":                "The size in bytes of this threads stack.",
					"value.proto_value.marathon_runtime_health_stats.soc_list.thread_stats.max_stack_used":            "The maximum number of stack bytes used by this thread since boot.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMarathonTemperature,
			BinaryMessageField: "MarathonTemperature",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Temperature readings from variety of on-board sources",
				Frequency:   FrequencyCustom("Logged on 1C change or min/max of 5/60 minutes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.marathon_temperature.temperature_reading.source":         metadatahelpers.EnumDescription("Source of temperature reading", nrfzephyrproto.TemperatureReading_TemperatureSource_name),
					"value.proto_value.marathon_temperature.temperature_reading.temperature_mc": "Temperature in degrees milli-celsius",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDMaxVoltageJumpCountReached,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDMcuAppEvent,
			BinaryMessageField:       "McuAppEvent",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDMcuFaultInfo,
			BinaryMessageField:       "VulcanMcuFaultInfo",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDMcuPowerGlitch,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "MCU power glitch metric, is being emit when power glitch event occuers on VG",
				Frequency:           FrequencyOnChange("On power glitch event"),
				IntValueDescription: "Set to 1 on power glitch event ",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMdm9607GpsJammingMetrics,
			BinaryMessageField: "Mdm9607GpsJammingMetrics",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "GPS Jamming detection metrics for MDM9607 (VG54). Note: these are hi-fidelity logs for debug and are only sent by a device when a config override is applied",
				Frequency:   FrequencyEveryXSeconds(1),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mdm9607_gps_jamming_metrics.pga_gain":                               "Programmable gain amplifier",
					"value.proto_value.mdm9607_gps_jamming_metrics.adc_amplitude_i":                        "ADC amplitude I component",
					"value.proto_value.mdm9607_gps_jamming_metrics.adc_amplitude_q":                        "ADC Amplitude Q component",
					"value.proto_value.mdm9607_gps_jamming_metrics.jammer_metric_gps_db":                   "GPS (US) constellation jammer metric (dB)",
					"value.proto_value.mdm9607_gps_jamming_metrics.jammer_metric_glo_db":                   "GLONAS (RU) constellation jammer metric (dB)",
					"value.proto_value.mdm9607_gps_jamming_metrics.jammer_metric_bds_db":                   "BEIDOU (CN) constellation jammer metric (dB)",
					"value.proto_value.mdm9607_gps_jamming_metrics.jammer_metric_gal_db":                   "GALILEO (EU) constellation jammer metric (dB)",
					"value.proto_value.mdm9607_gps_jamming_metrics.agc_metric_gps_millidb":                 "GPS (US) constallation automatic gain control",
					"value.proto_value.mdm9607_gps_jamming_metrics.agc_metric_glo_millidb":                 "GLONAS (RU) constallation automatic gain control",
					"value.proto_value.mdm9607_gps_jamming_metrics.agc_metric_bds_millidb":                 "BEIDOU (CN) constallation automatic gain control",
					"value.proto_value.mdm9607_gps_jamming_metrics.agc_metric_gal_millidb":                 "GALILEO (EU) constallation automatic gain control",
					"value.proto_value.mdm9607_gps_jamming_metrics.gps_baseband_processor_amplitude_i":     "GPS (US) constellation baseband processor amplitude I component",
					"value.proto_value.mdm9607_gps_jamming_metrics.gps_baseband_processor_amplitude_q":     "GPS (US) constellation baseband processor amplitude Q component",
					"value.proto_value.mdm9607_gps_jamming_metrics.avg_glo_baseband_processor_amplitude_i": "GLONAS (RU) constellation baseband processor amplitude I component",
					"value.proto_value.mdm9607_gps_jamming_metrics.avg_glo_baseband_processor_amplitude_q": "GLONAS (RU) constellation baseband processor amplitude Q component",
					"value.proto_value.mdm9607_gps_jamming_metrics.bds_baseband_processor_amplitude_i":     "BEIDOU (CN) constellation baseband processor amplitude I component",
					"value.proto_value.mdm9607_gps_jamming_metrics.bds_baseband_processor_amplitude_q":     "BEIDOU (CN) constellation baseband processor amplitude Q component",
					"value.proto_value.mdm9607_gps_jamming_metrics.gal_baseband_processor_amplitude_i":     "GALILEO (EU) constellation baseband processor amplitude I component",
					"value.proto_value.mdm9607_gps_jamming_metrics.gal_baseband_processor_amplitude_q":     "GALILEO (EU) constellation baseband processor amplitude Q component",
					"value.proto_value.mdm9607_gps_jamming_metrics.is_reference":                           "Whether the metrics are considered to be collected under \"good\" conditions",
					"value.proto_value.mdm9607_gps_jamming_metrics.gps_week_number":                        "GPS week number",
					"value.proto_value.mdm9607_gps_jamming_metrics.gps_time_of_week_milliseconds":          "GPS time of week (ms)",
					"value.proto_value.mdm9607_gps_jamming_metrics.time_valid":                             "Is GPS time considered valid",
					"value.proto_value.mdm9607_gps_jamming_metrics.time_source":                            "The internal source from where GPS time was derived. See qmiLocTimeSourceEnumT_v02 in MDM9607LE213 BSP code for enum values",
					"value.proto_value.mdm9607_gps_jamming_metrics.time_uncertainty_microseconds":          "Uncertainty rande of the GPS time (microseconds)",
					"value.proto_value.mdm9607_gps_jamming_metrics.clock_freq_bias_ppb":                    "Clock frequency bias per billion",
					"value.proto_value.mdm9607_gps_jamming_metrics.clock_freq_bias_uncertainty_ppb":        "Uncertainty range of the clock frequency bias",
					"value.proto_value.mdm9607_gps_jamming_metrics.oscillator_state":                       metadatahelpers.EnumDescription("State of GPS oscillator callibration", hubproto.Mdm9607GpsJammingMetrics_OscillatorCalibrationState_name),
					"value.proto_value.mdm9607_gps_jamming_metrics.leap_seconds":                           "Number of leap seconds to add to GPS time to get UTC time",
					"value.proto_value.mdm9607_gps_jamming_metrics.leap_second_uncertainty_seconds":        "Uncertainty range of the number of leabe seconds",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMdm9607GpsJammingStatus,
			BinaryMessageField: "Mdm9607GpsJammingStatus",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Jamming detection status for MDM9607 (VG54)",
				Frequency:   FrequencyOnChange("GPS jamming detection status change or periodically based on config (default every 5 hours)"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mdm9607_gps_jamming_status.jamming_status": metadatahelpers.EnumDescription("The jamming detection status", hubproto.Mdm9607GpsJammingStatus_JammingStatus_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMdm9607ThermalStats,
			BinaryMessageField: "Mdm9607Tsens",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag, amundsentags.FleetTag},
			MetadataInfo: &MetadataInfo{
				Description: "Thermal sensor reading for MDM9607 (VG34, VG54, VG55)",
				Frequency:   FrequencyEveryXSeconds(60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mdm9607_tsens.tsens_tz_sensor0_milli_degree_c": "Current temperature reading from thermal zone 0. Qualcomm document 80-P2200-19 for more information",
					"value.proto_value.mdm9607_tsens.tsens_tz_sensor1_milli_degree_c": "Current temperature reading from thermal zone 1. Qualcomm document 80-P2200-19 for more information",
					"value.proto_value.mdm9607_tsens.tsens_tz_sensor2_milli_degree_c": "Current temperature reading from thermal zone 2. Qualcomm document 80-P2200-19 for more information",
					"value.proto_value.mdm9607_tsens.tsens_tz_sensor3_milli_degree_c": "Current temperature reading from thermal zone 3. Qualcomm document 80-P2200-19 for more information",
					"value.proto_value.mdm9607_tsens.tsens_tz_sensor4_milli_degree_c": "Current temperature reading from thermal zone 4. Qualcomm document 80-P2200-19 for more information",
					"value.proto_value.mdm9607_tsens.pa_therm0_milli_degree_c":        "Current temperature reading from thermal zone 5. Qualcomm document 80-P2200-19 for more information",
					"value.proto_value.mdm9607_tsens.vg_mcu_sensor0_milli_degree_c":   "Curront SoC temperature read over SPI. Only report on Thor (VG-54).",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMediaStorageInfo,
			BinaryMessageField: "MediaStorageInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports current media-related disk storage details for Site Gateways, once per hour.",
				Frequency:   FrequencyEveryXSeconds(60 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.media_storage_info":                            "A struct representing a sample of the current media-related disk storage details for the gateway.",
					"value.proto_value.media_storage_info.video_storage_used_bytes":   "The number of formatted bytes used for video storage.",
					"value.proto_value.media_storage_info.stills_storage_used_bytes":  "The number of formatted bytes used for stills storage.",
					"value.proto_value.media_storage_info.total_used_bytes":           "The total number of bytes used overall (including non-media storage).",
					"value.proto_value.media_storage_info.available_disk_space_bytes": "The number of bytes available for all storage.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMinPgnAndErrorFrameAutodetectResultMismatch,
			BinaryMessageField: "MinPgnAndErrorFrameAutodetectResults",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "CAN bus bitrate autodetection results",
				Frequency:   FrequencyCustom("Reported each time autodetection is run and a difference in detected bitrate is seen, only on assets"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.min_pgn_and_error_frame_autodetect_results.min_pgn_bitrate_result":     "Bitrate derived from min PGN counting.",
					"value.proto_value.min_pgn_and_error_frame_autodetect_results.error_frame_bitrate_result": "Bitrate derived from CAN bus error counting.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEvent,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs when MLApps are started or stopped with the state/config of the app.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventDrowsiness,
			BinaryMessageField: "MlappRunEvent",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for drowsiness is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventDrowsinessServiceB,
			BinaryMessageField: "MlappRunEvent",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for drowsiness service b is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventFollowingDistance,
			BinaryMessageField: "MlappRunEvent",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs when the ml app for following distance is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventForwardCollisionWarning,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			ksFieldsToExclude:  []string{},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Informs when the ml app for forward collision warning is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventForwardCollisionWarningServiceB,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs when the ml app for forward collision warning service b is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventInwardObstruction,
			BinaryMessageField: "MlappRunEvent",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for inward obstruction is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventInwardSafety,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for inward safety is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventInwardSafetyServiceB,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for inward safety service B is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventOutwardSafety,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for outward safety is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventOutwardSafetyServiceB,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for outward safety service B is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventSignDetection,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for sign detection is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventSignDetectionServiceB,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for sign detection service b is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventVanishingPoint,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for vanishing point is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventVulnerableRoadUserCollisionWarning,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for vulnerable road user collision warning is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMLAppRunEventVulnerableRoadUserCollisionWarningServiceB,
			BinaryMessageField: "MlappRunEvent",
			Kind:               StatKindObjectStat,
			ksFieldsToExclude:  []string{},
			MetadataInfo: &MetadataInfo{
				Description: "Informs the ml app for vulnerable road user collision warning service b is started or stopped with the state/config.",
				Frequency:   FrequencyOnChange("Uploads when ML Apps are started, stopped due to a change with a new config or on initial boot."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.mlapp_run_event.run_tag.run_id": "The unique identifier of the ML run ID instance for the device.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDModbusV2CastingErrorCount,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDModiCommErrors,
			BinaryMessageField: "ModiCommErrorInfo",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag, amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: metadatahelpers.DeprecatedDefaultDescription,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDModiCommState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.CoreFirmwareTag, amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current connection state between VG and Modi hardware",
				Frequency:           FrequencyCustom("Reported each time the connection state to Modi changes."),
				IntValueDescription: "0 when disconnected, 1 when connected. Values are not defined in an enum. Only reports on VG34X devices with an attached port expander (Modi).",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDModiDeviceInfo,
			BinaryMessageField:       "ModiDeviceInfo",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			ksFieldsToExclude: []string{
				"value.proto_value.modi_device_info.manufacturing_data.serial_number",
			},
			Tags: []amundsentags.Tag{amundsentags.CoreFirmwareTag, amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Connected Modi device information.",
				Frequency:   FrequencyCustom("Reported each time Modi connects to its VG34x"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.modi_device_info.manufacturing_data":                 "Data requested from Modi about manufacturing details.",
					"value.proto_value.modi_device_info.manufacturing_data.product_id":      "Product ID",
					"value.proto_value.modi_device_info.manufacturing_data.board_revision":  "Board revision identifier",
					"value.proto_value.modi_device_info.manufacturing_data.mfg_date_ms":     "Manufacturing date (since epoch ms)",
					"value.proto_value.modi_device_info.manufacturing_data.mfg_location":    "Manufacturing location",
					"value.proto_value.modi_device_info.manufacturing_data.build_phase":     "Identifies the build phase of the product. This tracks numerically with the phase of the build and will shift from Numeric to Alphabetic upon MP release. After Mass Production, this can be used to track significant changes to the manufacturing process. All builds will start with 0 as Proto, and will iterate up 1 for each subsequent build. NPI/EPM is responsible for mapping the Development Phase (EVT, DVT, etc.) with the Build Phase (0, 1, 2, etc) Ax = Mass Production. See https://samsaradev.atlassian.net/l/c/VBb75518 for more information",
					"value.proto_value.modi_device_info.manufacturing_data.product_version": "A product change requiring multiple versions of the same SKU being manufactured in parallel. Example: Building with two different MCUs for a given SKU, you can track using HW-SKU-NA A0-000 and HW-SKU-NA A1-000. NOTE: these changes must not require visibility at the sales/customer/logistics level. See https://samsaradev.atlassian.net/l/c/VBb75518 for more information.",
					"value.proto_value.modi_device_info.manufacturing_data.bom_version":     "Any change to the Bill of Materials (BOM) will result in rolling to the next BOM Version. This will capture all PCB changes, EE changes, ME changes. It can also be used to track the point at which a second source becomes qualified. See https://samsaradev.atlassian.net/l/c/VBb75518 for more information.",
					"value.proto_value.modi_device_info.firmware_versions":                  "List of firmware versions installed. This includes the bootloader and application level firmware versions for Modi.",
					"value.proto_value.modi_device_info.firmware_versions.type":             metadatahelpers.EnumDescription("Type of firmware represented in this record.", hubproto.ObjectStatBinaryMessage_ModiDeviceInfo_FirmwareVersion_FirmwareType_name),
					"value.proto_value.modi_device_info.firmware_versions.major_version":    "Major version.",
					"value.proto_value.modi_device_info.firmware_versions.minor_version":    "Minor version.",
					"value.proto_value.modi_device_info.firmware_versions.patch":            "Patch version.",
					"value.proto_value.modi_device_info.firmware_versions.commit_hash":      "Commit hash of version.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDModiUsbThermalShutoff,
			BinaryMessageField: "ModiUsbThermalShutoffInfo",
			Kind:               StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMotionDStillness,
			BinaryMessageField: "MotionDStillness",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MotionDTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Reports when device is still based on inertial sensors.",
				Frequency:   FrequencyCustom("Once every five minutes."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.motion_d_stillness.is_still":                      "True if the device is currently still.",
					"value.proto_value.motion_d_stillness.stillness_high_watermark_anmv": "High watermark during stillness of accel-norm moving variance.",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMotionDVibration,
			BinaryMessageField: "MotionDVibration",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MotionDTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Reports when device is experiencing persistent vibration.",
				Frequency:   FrequencyCustom("Once every five minutes."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.motion_d_vibration.is_vibrating":                           "True if the device is currently vibrating.",
					"value.proto_value.motion_d_vibration.frequency_hz":                           "Vibrational frequency with the highest power.",
					"value.proto_value.motion_d_vibration.fft_window_length":                      "Number of samples used for FFT spectrogram.",
					"value.proto_value.motion_d_vibration.gravity_vector_concentration_parameter": "Von Mises Fisher concentration parameter for gravity vector to indicate steadiness of orientation.",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMotionEvent,
			BinaryMessageField: "MotionEvent",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Information regarding motion start / stop / continue events.  Currently used for the Nordic platform",
				Frequency:   FrequencyCustom("Reported when motion starts, stops continues"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.motion_event.type": metadatahelpers.EnumDescription("The type of motion event", nrfzephyrproto.MotionEvent_Type_name),
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDMovement,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Indicator of movement on the firmware.",
				Frequency:           FrequencyOnChange("On movement detected"),
				IntValueDescription: "1 if movement has been detected, 0 otherwise",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMulticamConnected,
			BinaryMessageField: "MulticamConnectionState",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Multicam/Octo Camera connection state",
				Frequency:           FrequencyCustom("a multicam or octo connection event occurs"),
				IntValueDescription: "Binary value, either 0 for a disconnect or 1 for a connect. Note that this is generated on the VG.",
				ColumnDescriptions: map[string]string{
					"object_id": "VG device id.",
					"value.proto_value.multicam_connection_state.multicam_serial": "Multicam serial may be uppercase or lowercase, and may or may not have hyphens. This field should be normalized prior to using it.",
					"value.proto_value.multicam_connection_state.multicam_type":   metadatahelpers.EnumDescription("Multicam Type Connected", hubproto.ObjectStatBinaryMessage_MulticamConnectionState_MulticamType_name),
					"value.proto_value.multicam_connection_state.multicam_id":     "Multicam device id, if available",
					"value.proto_value.multicam_connection_state.connected":       "True if int_value is 1, and false otherwise.",
				},
			},
			Production: true,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDMulticamMetrics,
			BinaryMessageField: "MulticamMetrics",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.MulticamTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:            "This stat was used to emit metrics for the multicam system. A lot of fields are unused, and we are deprecating the multicam system so I would be hesitant to rely on this table a lot.",
				Frequency:              FrequencyOnChange("NVR events of interest"),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.multicam_metrics.still_capture_failure.error_message": "The error message that is logged when we fail to upload a still from the NVR.",
					"value.proto_value.multicam_metrics.storage_cleanup.cleanup_duration_ms": "The time (ms) it took for the NVR to cleanup storage on disk when the NVR is running out of disk space.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicButton,
			BinaryMessageField: "NordicButton",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Button stat for the Nordic platform",
				Frequency:   FrequencyCustom("Reported when a button event happens"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_button.press_type":    metadatahelpers.EnumDescription("Button Press Type", hubproto.ObjectStatBinaryMessage_NordicButton_Type_name),
					"value.proto_value.nordic_button.outcome":       metadatahelpers.EnumDescription("Outcome of Button Press", hubproto.ObjectStatBinaryMessage_NordicButton_Outcome_name),
					"value.proto_value.nordic_button.num_presses":   "Number of times the press type happened",
					"value.proto_value.nordic_button.press_time_ms": "Button press time in milliseconds",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicEdrx,
			BinaryMessageField: "NordicEdrx",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "eDRX (extended discontinuous reception) information from the Nordic LTE modem",
				Frequency:   FrequencyCustom("Reported each time eDRX parameters are updated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_edrx.requested.edrx_interval_ms":      "Requested eDRX interval in ms",
					"value.proto_value.nordic_edrx.requested.paging_time_window_ms": "Requested paging time window in ms",
					"value.proto_value.nordic_edrx.received.edrx_interval_ms":       "Network received eDRX interval in ms",
					"value.proto_value.nordic_edrx.received.paging_time_window_ms":  "Network received pagingg time window in ms",
					"value.proto_value.nordic_edrx.network_rejected":                "eDRX request was rejected by network",
					"value.proto_value.nordic_edrx.mcc":                             "Mobile Country Code",
					"value.proto_value.nordic_edrx.mnc":                             "Mobile Network Code",
					"value.proto_value.nordic_edrx.cell_id":                         "E-UTRAN cell ID",
					"value.proto_value.nordic_edrx.tac":                             "Tracking area code",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicFactoryConfigDebug,
			BinaryMessageField: "NordicFactoryConfigDebug",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Describes factory (non-cloud) config settings Nordic platform",
				Frequency:   FrequencyCustom("Reported on boot and every 24 hours"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_factory_config_debug.hw_rev":         "Hardware revision of the device",
					"value.proto_value.nordic_factory_config_debug.accel_x_ofs_ug": "Accel X offset calibration in ug",
					"value.proto_value.nordic_factory_config_debug.accel_y_ofs_ug": "Accel Y offset calibration in ug",
					"value.proto_value.nordic_factory_config_debug.accel_z_ofs_ug": "Accel Z offset calibration in ug",
					"value.proto_value.nordic_factory_config_debug.dfu_enabled":    "True if DFU is enabled on device",
					"value.proto_value.nordic_factory_config_debug.uart_enabled":   "True if debug console UART enabled on device",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicGpsDebug,
			BinaryMessageField: "NordicGpsDebug",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Debug GPS data coming from our Nordic GPS modem platform",
				Frequency:   FrequencyCustom("Reported per fix while debugging GPS data"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_gps_debug.gps_fix_info.latitude_nd":                      "Latitude of fix in nanodegrees",
					"value.proto_value.nordic_gps_debug.gps_fix_info.longitude_nd":                     "Longitude of fix in nanodegrees",
					"value.proto_value.nordic_gps_debug.gps_fix_info.altitude_mm":                      "Altitude above WGS-84 ellipsoid in millimeters",
					"value.proto_value.nordic_gps_debug.gps_fix_info.accuracy_mm":                      "Position accuracy (2D 1-sigma) in millimeters",
					"value.proto_value.nordic_gps_debug.gps_fix_info.speed_mm_per_s":                   "Horizontal speed in millimeters/second",
					"value.proto_value.nordic_gps_debug.gps_fix_info.heading_md":                       "Heading of user movement in millidegrees",
					"value.proto_value.nordic_gps_debug.gps_fix_info.pdop_thousandths":                 "Position dilution of precision of fix in thousandths",
					"value.proto_value.nordic_gps_debug.gps_fix_info.hdop_thousandths":                 "Horizontal dilution of precision of fix in thousandths",
					"value.proto_value.nordic_gps_debug.gps_fix_info.vdop_thousandths":                 "Vertical dilution of precision of fix in thousandths",
					"value.proto_value.nordic_gps_debug.gps_fix_info.tdop_thousandths":                 "Time dilution of precision of fix in thousandths",
					"value.proto_value.nordic_gps_debug.gps_fix_info.time_to_fix_ms":                   "Time taken to get fix in ms",
					"value.proto_value.nordic_gps_debug.gps_fix_info.speed_accuracy_mm_per_s":          "Speed accuracy (1-sigma) in mm/sec",
					"value.proto_value.nordic_gps_debug.gps_fix_info.vertical_speed_mm_per_s":          "Vertical speed in mm/sec. Positive is up",
					"value.proto_value.nordic_gps_debug.gps_fix_info.vertical_speed_accuracy_mm_per_s": "Vertical speed accuracy (1-sigma) in mm/sec",
					"value.proto_value.nordic_gps_debug.gps_fix_info.heading_accuracy_md":              "Heading accuracy (1-sigma) in millidegrees",
					"value.proto_value.nordic_gps_debug.gps_fix_info.altitude_accuracy_mm":             "Altitude accuracy (1-sigma) in millimeters",
					"value.proto_value.nordic_gps_debug.gps_fix_info.flags":                            "Bitmask values in the PVT notification received from Nordic modem",
					"value.proto_value.nordic_gps_debug.gps_fix_info.execution_time_ms":                "Cumulative GNSS execution time since last start in milliseconds (from modem)",
					"value.proto_value.nordic_gps_debug.gps_fix_info.fix_index":                        metadatahelpers.EnumDescription("Which (consecutive) fix", hubproto.ObjectStatBinaryMessage_NordicGpsDebug_GpsFixInfo_FixIndex_name),
					"value.proto_value.nordic_gps_debug.no_fix":                                        "True when we failed to get a fix",
					"value.proto_value.nordic_gps_debug.satellite_infos.sv_id":                         "Satellite ID (GPS should be 1-32)",
					"value.proto_value.nordic_gps_debug.satellite_infos.cn0_tenths_db_per_hz":          "Carrier to noise density ratio of SV in .1db/Hz",
					"value.proto_value.nordic_gps_debug.satellite_infos.elevation_angle_deg":           "Elevation angle of SV in degrees",
					"value.proto_value.nordic_gps_debug.satellite_infos.azimuth_angle_deg":             "Azimuth angle of SV in degrees",
					"value.proto_value.nordic_gps_debug.satellite_infos.used_in_gps_fix":               "SV is used in the GPS fix",
					"value.proto_value.nordic_gps_debug.gps_scan_duration_ms":                          "GPS scan time for this interval in ms",
					"value.proto_value.nordic_gps_debug.reported_to_backend":                           "True if we reported this fix to the backend",
					"value.proto_value.nordic_gps_debug.system_state":                                  metadatahelpers.EnumDescription("State Type", hubproto.ObjectStatBinaryMessage_NordicLteDebug_SystemState_name),
					"value.proto_value.nordic_gps_debug.filter.num_filtered_fixes":                     "Number of times the modem had a fix ready, but we filtered it out",
					"value.proto_value.nordic_gps_debug.filter.time_to_first_filtered_fix_ms":          "Time we received the first fix that was filtered in ms (0 if the first fix was not filtered OR no fixes)",
					"value.proto_value.nordic_gps_debug.filter.reason":                                 metadatahelpers.EnumDescription("Reason(s) fix(es) were filtered", hubproto.ObjectStatBinaryMessage_NordicGpsDebug_Filter_FilteredReason_name),
					"value.proto_value.nordic_gps_debug.location_snap.cui":                             "Contextual unique identifier (unique per device). Updated when the lat/long of the snapped location changes",
					"value.proto_value.nordic_gps_debug.location_snap.haversine_distance_mm":           "Haversine distance in mm between the fix and the snapped location reported to backend",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicLowTempCrashDebug,
			BinaryMessageField: "NordicLowTempCrashDebug",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Provides debug information related to the low temperature nRF5340 errata crash issue",
				Frequency:   FrequencyCustom("Reported between 2-100 times per day, depending on team needs"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_low_temp_crash_debug.boot_count":                        "Number of times the device has booted (all time)",
					"value.proto_value.nordic_low_temp_crash_debug.high_freq_patch.vote_mask":         "Bitwise mask of current module voters",
					"value.proto_value.nordic_low_temp_crash_debug.high_freq_patch.has_voted_mask":    "Bitwise mask of modules who have ever voted (this boot)",
					"value.proto_value.nordic_low_temp_crash_debug.high_freq_patch.num_work_q_votes":  "Number of times any workqueues has voted (this boot)",
					"value.proto_value.nordic_low_temp_crash_debug.high_freq_patch.num_zero_votes":    "Number of times vote_mask went from non-zero to zero (this boot)",
					"value.proto_value.nordic_low_temp_crash_debug.high_freq_patch.last_zero_vote_ms": "Number of milliseconds since vote_mask=0 (this boot) in ms (0 if never)",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicLteDebug,
			BinaryMessageField: "NordicLteDebug",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Debug LTE data coming from our Nordic LTE modem platform",
				Frequency:   FrequencyCustom("Reported per ping while debugging LTE data"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_lte_debug.lte_cell_info.mcc":                      "Mobile Country Code",
					"value.proto_value.nordic_lte_debug.lte_cell_info.mnc":                      "Mobile Network Code",
					"value.proto_value.nordic_lte_debug.lte_cell_info.cell_id":                  "E-UTRAN cell ID",
					"value.proto_value.nordic_lte_debug.lte_cell_info.earfcn":                   "EARFCN for given cell where EARFCN is per 3GPP TS 36.101 (LTE band identifier)",
					"value.proto_value.nordic_lte_debug.lte_cell_info.tac":                      "Tracking area code",
					"value.proto_value.nordic_lte_debug.lte_cell_info.physical_cell_id":         "Physical cell ID",
					"value.proto_value.nordic_lte_debug.lte_cell_info.rsrp_dbm":                 "Received signal received power in dBm",
					"value.proto_value.nordic_lte_debug.lte_cell_info.rsrq_db":                  "Received signal received quality in dB",
					"value.proto_value.nordic_lte_debug.lte_cell_info.plmn_mccmnc":              "PLMN operator in the form 'mccmnc'",
					"value.proto_value.nordic_lte_debug.lte_cell_info.operator_short":           "Short name for the operator",
					"value.proto_value.nordic_lte_debug.lte_cell_info.periodic_tau_s":           "Periodic TAU (tracking area update) interval in s",
					"value.proto_value.nordic_lte_debug.lte_cell_info.access_technology":        metadatahelpers.EnumDescription("CAT-M, NB-IoT, etc", hubproto.ObjectStatBinaryMessage_NordicLteDebug_LTECellInfo_AccessTechnology_name),
					"value.proto_value.nordic_lte_debug.lte_cell_info.snr_db":                   "incorrect field that should be deprecated", // TODO d
					"value.proto_value.nordic_lte_debug.lte_cell_info.energy_estimate":          "Relative estimated energy consumption for data transmission compared to nominal consumption - lte_lc_energy_estimate(5=bad, 6=poor, 7=normal, 8=good, 9=excellent)",
					"value.proto_value.nordic_lte_debug.system_state":                           metadatahelpers.EnumDescription("State Type", hubproto.ObjectStatBinaryMessage_NordicLteDebug_SystemState_name),
					"value.proto_value.nordic_lte_debug.modem_fw_version":                       metadatahelpers.EnumDescription("Modem FW Version", hubproto.ObjectStatBinaryMessage_NordicLteDebug_ModemFWVersion_name),
					"value.proto_value.nordic_lte_debug.lte_cell_info.signal_to_noise_ratio_db": "Current signal-to-noise ratio at time of report in db",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicLteDebugConnectionStatus,
			BinaryMessageField: "NordicLteDebugConnectionStatus",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Debug LTE connection information from our Nordic LTE modem platform",
				Frequency:   FrequencyCustom("Reported when modem moves from Connected state to Idle state"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_lte_debug_connection_status.connection_type":           metadatahelpers.EnumDescription("Connection Type", hubproto.ObjectStatBinaryMessage_NordicLteDebugConnectionStatus_Type_name),
					"value.proto_value.nordic_lte_debug_connection_status.rrc_connected_duration_ms": "Duration of RRC Connected State in ms",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicModemSleep,
			BinaryMessageField: "NordicModemSleep",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Indicates each time the modem sleeps and wakes up. In the case of sleeps reports for how long",
				Frequency:   FrequencyCustom("Reported each time the modem goes to sleep or wakes up"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_modem_sleep.type":              metadatahelpers.EnumDescription("The type of sleep/wake", hubproto.ObjectStatBinaryMessage_NordicModemSleep_Type_name),
					"value.proto_value.nordic_modem_sleep.sleep_duration_ms": "Time modem will sleep for (will be 0 if waking up)",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicReeferDebug,
			BinaryMessageField: "NordicReeferDebug",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Communications debug information between an AG52 and a Thermoking Reefer",
				Frequency:   FrequencyCustom("2-10 times per minute while debugging is enabled"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_reefer_debug.thermoking.status":         "The status code (as evaluated by the AG52) of the communication (i.e., success, failure)",
					"value.proto_value.nordic_reefer_debug.thermoking.request_bytes":  "The request bytes to the Thermoking reefer",
					"value.proto_value.nordic_reefer_debug.thermoking.response_bytes": "The response bytes from the Thermoking reefer (optional)",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicResetInfo,
			BinaryMessageField: "NordicResetInfo",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Information surrounding reset event on Nordic platform",
				Frequency:   FrequencyCustom("Reported when reset event occurs"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_reset_info.soc":                          metadatahelpers.EnumDescription("Which SOC", nrfzephyrproto.NordicSoc_name),
					"value.proto_value.nordic_reset_info.software_reason":              metadatahelpers.EnumDescription("Intrepreted Reset Reason", nrfzephyrproto.ResetReasonSw_name),
					"value.proto_value.nordic_reset_info.hardware_reason":              "Reset reason from NRF_RESET->RESETREAS register",
					"value.proto_value.nordic_reset_info.context.thread_id":            "ID of thread that prompted reset",
					"value.proto_value.nordic_reset_info.context.thread_name":          "Name of thread that prompted reset",
					"value.proto_value.nordic_reset_info.context.file":                 "Name of file that prompted reset",
					"value.proto_value.nordic_reset_info.context.line":                 "Line in file that prompted reset",
					"value.proto_value.nordic_reset_info.context.task_mask":            "bitwise mask of active tasks during reset",
					"value.proto_value.nordic_reset_info.context.regs.r0":              "R0 register",
					"value.proto_value.nordic_reset_info.context.regs.r1":              "R1 register",
					"value.proto_value.nordic_reset_info.context.regs.r2":              "R2 register",
					"value.proto_value.nordic_reset_info.context.regs.r3":              "R3 register",
					"value.proto_value.nordic_reset_info.context.regs.r4":              "R4 register",
					"value.proto_value.nordic_reset_info.context.regs.r5":              "R5 register",
					"value.proto_value.nordic_reset_info.context.regs.r6":              "R6 register",
					"value.proto_value.nordic_reset_info.context.regs.r7":              "R7 register",
					"value.proto_value.nordic_reset_info.context.regs.r8":              "R8 register",
					"value.proto_value.nordic_reset_info.context.regs.r9":              "R9 register",
					"value.proto_value.nordic_reset_info.context.regs.r10":             "R10 register",
					"value.proto_value.nordic_reset_info.context.regs.r11":             "R11 register",
					"value.proto_value.nordic_reset_info.context.regs.r12_ip":          "Intra-procedure call scratch register",
					"value.proto_value.nordic_reset_info.context.regs.r14_lr":          "Link register",
					"value.proto_value.nordic_reset_info.context.regs.r15_pc":          "Program counter",
					"value.proto_value.nordic_reset_info.context.regs.psp":             "Program stack pointer",
					"value.proto_value.nordic_reset_info.context.regs.exc_return":      "exception return value",
					"value.proto_value.nordic_reset_info.context.regs.xpsr":            "Program status register",
					"value.proto_value.nordic_reset_info.context.regs.hfsr":            "Hard fault status register",
					"value.proto_value.nordic_reset_info.context.regs.mmfsr":           "Mem manage fault status register",
					"value.proto_value.nordic_reset_info.context.regs.bfsr":            "Bus fault status register",
					"value.proto_value.nordic_reset_info.context.regs.ufsr":            "Usage fault status register",
					"value.proto_value.nordic_reset_info.context.regs.cfsr":            "Configurable fault status register",
					"value.proto_value.nordic_reset_info.context.regs.fpscr":           "Floating point status and control register",
					"value.proto_value.nordic_reset_info.context.regs.mmfar":           "Mem manage fault address",
					"value.proto_value.nordic_reset_info.context.regs.icsr":            "Interrupt control and state register",
					"value.proto_value.nordic_reset_info.context.regs.bfar":            "Bus fault address",
					"value.proto_value.nordic_reset_info.context.reset_from_isr":       "True if reset from an ISR, False if reset from a thread",
					"value.proto_value.nordic_reset_info.context.threads_running":      "Mask representing zephyr threads running at time of reset",
					"value.proto_value.nordic_reset_info.context.arm_exception_number": "ARM exception number (3 means hard fault for example)",
					"value.proto_value.nordic_reset_info.zephyr_reason":                metadatahelpers.EnumDescription("Zephyr k_fatal_error_reason", nrfzephyrproto.ZephyrFatalErrorReason_name),
					"value.proto_value.nordic_reset_info.reset_was_fatal":              "True if reset was fatal, False if it was an expected and controlled reset",
					"value.proto_value.nordic_reset_info.initiator_code_version":       "Buildkite job number of the Soc's Appcore Version that caused the reset to happen",
					"value.proto_value.nordic_reset_info.recorder_code_version":        "Buildkite job number of the Soc's AppCore Version that jotted the reset data",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicShellOutput,
			BinaryMessageField: "NordicShellOutput",
			Kind:               StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Debug output from the Marathon shell and logger.",
				Frequency:   FrequencyCustom("Shell data only sent when config based shell commands are sent.  Log data must be manually enabled via config"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_shell_output.shell_messages.source":            metadatahelpers.EnumDescription("String source from shell reply or log", nrfzephyrproto.NordicShellOutput_NordicShellSource_name),
					"value.proto_value.nordic_shell_output.shell_messages.contents":          "Ascii or UTF-8 shell or log output from the Marathon/Zephyr shell system.  Contents and binary_contents are mutually exclusive.",
					"value.proto_value.nordic_shell_output.shell_messages.binary_contents":   "Binary message (such as binary logs output) from Zephyr logging system.  Contents and binary_contents are mutually exclusive.",
					"value.proto_value.nordic_shell_output.shell_messages.cli_command_apply": "Config value, cli_command_apply sent that triggered shell command (or 0 if not a shell response.)",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNordicTaskDuration,
			BinaryMessageField: "NordicTaskDuration",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "How long a task took to finish",
				Frequency:   FrequencyCustom("Reported after task has run"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.nordic_task_duration.task_type":         metadatahelpers.EnumDescription("The task type", nrfzephyrproto.NordicTaskDuration_TaskType_name),
					"value.proto_value.nordic_task_duration.started_time_ms":   "Time task started",
					"value.proto_value.nordic_task_duration.duration_ms":       "Time task took to complete",
					"value.proto_value.nordic_task_duration.status":            "Status of task (ending errors, etc)",
					"value.proto_value.nordic_task_duration.extra_metric_type": metadatahelpers.EnumDescription("The extra data type", nrfzephyrproto.NordicTaskDuration_ExtraMetricType_name),
					"value.proto_value.nordic_task_duration.extra_metric_u32":  "Extra data uint32, context noted in 'extra_metric_type'",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNVR10CameraInfo,
			BinaryMessageField: "Nvr10CameraInfo",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNVRActivation,
			BinaryMessageField: "NvrActivation",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.MulticamTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:            metadatahelpers.DeprecatedDescription("This was used to track the install state of the multicam system."),
				Frequency:              FrequencyOnChange("install state change"),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.nvr_activation.setup_state": metadatahelpers.DeprecatedDescription("The install state that the multicam system updated to."),
				},
			},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNVRConnected,
			BinaryMessageField: "NvrConnected",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.MulticamTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:            metadatahelpers.DeprecatedDescription("This was used by the medusa multicam system to track the connected state of the NVR. This is deprecated in favor of NVRConnectionState."),
				Frequency:              FrequencyOnChange("NVR connects to VG"),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.nvr_connected.nvr_connectivity_state": metadatahelpers.DeprecatedDescription("Whether the NVR is connected to the VG. True if so, false otherwise."),
					"value.proto_value.nvr_connected.unix_time_ms":           metadatahelpers.DeprecatedDescription("Timestamp (ms) of the stat uploaded"),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNVRConnectionState,
			BinaryMessageField: "NvrConnectionState",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.MulticamTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:            "A stat that is uploaded when the NVR comes online and offline.",
				Frequency:              FrequencyOnChange("connects to VG"),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.nvr_connection_state.nvr_id":                      "The device ID of the NVR. This should be map to the device ID in the devices table.",
					"value.proto_value.nvr_connection_state.nvr_serial":                  "The serial number of the NVR.",
					"value.proto_value.nvr_connection_state.slot_info.slot_id":           "",
					"value.proto_value.nvr_connection_state.slot_info.connected_state":   "Whether the NVR is connected to the VG. True if so, false otherwise.",
					"value.proto_value.nvr_connection_state.slot_info.camera_name":       "The name of the camera. Typically a pre-set value of HW-CM25 or HW-CM25-RJ45",
					"value.proto_value.nvr_connection_state.slot_info.camera_serial":     "The serial number of the camera. Typically hardcoded starting from 5000, increasing by 1 for each camera connected to the NVR. Could also be the default serial number of the camera. Not standardized to any case, and may or may not include hyphens.",
					"value.proto_value.nvr_connection_state.slot_info.camera_resolution": "Unused.",
					"value.proto_value.nvr_connection_state.slot_info.recording_state":   metadatahelpers.EnumDescription("Current recording state", hubproto.NVRConnectionState_NVRCameraSlotInfo_RecordingState_name),
					"value.proto_value.nvr_connection_state.slot_info.camera_id":         "Similar to camera_serial.",
					"value.proto_value.nvr_connection_state.slot_info.track_id":          "Maps to the NVR ID.",
					"value.proto_value.nvr_connection_state.unix_time_ms":                "The timestamp (ms) in which the connection state was uploaded.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDNVRLogEvent,
			BinaryMessageField: "NvrLogEvent",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.MulticamTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:            metadatahelpers.DeprecatedDescription("This was used to log anomalies / events of interest that occurred on the NVR."),
				Frequency:              FrequencyOnChange("event of interest"),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.nvr_log_event.event_time_ms": metadatahelpers.DeprecatedDescription("Time (ms) of the event of interest."),
					"value.proto_value.nvr_log_event.event_type":    metadatahelpers.DeprecatedDescription("The event type of the event of interest."),
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDObdCableId,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Identifier read from on-board diagnostics (OBD)",
				Frequency:           FrequencyCustom("Reported each time the firmware OBD Manager is started"),
				IntValueDescription: "Cable ID read from attached gateway cable. Cable IDs are defined on the firmware in platform/cable_id.go",
			},
			Production: true,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDObdCableMfgIdentity,
			BinaryMessageField: "ObdCableMfgIdentity",
			Kind:               StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Tags: []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Cable manufacturing info",
				Frequency:   FrequencyCustom("Reported each time the OBD manager starts reefer processes and on change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.obd_cable_mfg_identity.cable_type":     "Cable type of smart cable with MCU",
					"value.proto_value.obd_cable_mfg_identity.mfg_date.day":   "Day cable was manufactured",
					"value.proto_value.obd_cable_mfg_identity.mfg_date.month": "Month cable was manufactured",
					"value.proto_value.obd_cable_mfg_identity.mfg_date.year":  "Year cable was manufactured",
					"value.proto_value.obd_cable_mfg_identity.hardware_id":    "ID that differentiates between suppliers",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdComplianceStandard,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "OBD compliance standard for passenger vehicles",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "A request for this PID returns a single byte of data which describes which OBD standards this ECU was designed to comply with. There is no enum of values, but you can look up passenger PID 010C to get the mapping. This identifier is defined in J1979 and supported in ISO27145.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData01,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 01",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData02,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 02",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData03,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 03",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData04,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 04",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData05,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 05",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData06,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 06",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData07,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 07",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData08,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 08",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData09,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 09",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData10,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 10",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData100,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 100",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData101,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 101",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData102,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 102",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData103,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 103",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData104,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 104",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData105,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 105",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData106,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 106",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData107,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 107",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData108,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 108",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData109,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 109",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData11,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 11",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData110,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 110",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData111,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 111",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData112,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 112",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData113,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 113",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData114,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 114",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData115,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 115",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData116,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 116",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData117,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 117",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData118,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 118",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData119,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 119",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData12,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 12",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData120,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 120",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData13,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 13",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData14,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 14",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData15,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 15",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData150,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 150",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData151,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 151",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData152,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 152",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData153,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 153",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData154,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 154",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData155,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 155",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData156,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 156",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData157,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 157",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData158,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 158",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData159,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 159",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData16,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 16",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData160,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 160",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData161,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 161",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData162,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 162",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData163,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 163",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData164,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 164",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData165,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 165",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData166,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 166",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData167,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 167",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData168,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 168",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData169,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 169",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData17,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 17",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData170,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 170",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData18,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 18",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData19,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 19",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData20,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 20",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData200,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 200",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData201,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 201",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData202,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 202",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData203,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 203",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData204,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 204",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData205,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 205",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData206,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 206",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData207,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 207",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData208,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 208",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData209,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 209",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData210,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 210",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData211,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 211",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData212,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 212",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData213,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 213",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData214,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 214",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData215,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 215",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData216,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 216",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData217,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 217",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData218,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 218",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData219,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 219",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData220,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 220",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData50,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 50",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData51,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 51",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData52,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 52",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData53,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 53",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData54,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 54",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData55,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 55",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData56,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 56",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData57,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 57",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData58,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 58",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData59,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 59",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData60,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 60",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData61,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 61",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData62,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 62",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData63,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 63",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData64,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 64",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData65,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 65",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData66,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 66",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData67,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 67",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData68,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 68",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData69,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 69",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalData70,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 70",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalEnd,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 1023(Internal End)",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDObdInternalStart,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Signal Promotion Service Internal Test Data 00 (Internal Start)",
				Frequency:           FrequencyEveryXSeconds(1 * 60),
				IntValueDescription: "Internal test data in SPS alpha stage.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDObdValueLockAdded,
			BinaryMessageField: "ObdValueLockAdded",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:            "Information about an obd lock addition for a particular obd value",
				Frequency:              FrequencyCustom("Reported when we have a new lock for an obd value"),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.obd_value_lock_added.obd_value":                                                   metadatahelpers.EnumDescription("The locked obd value", hubproto.ObdValue_name),
					"value.proto_value.obd_value_lock_added.reason":                                                      metadatahelpers.EnumDescription("Reason for lock", fwenumproto.ObdValueLockAddedReason_name),
					"value.proto_value.obd_value_lock_added.obd_value_source_lock.vehicle_diagnostic_bus":                metadatahelpers.EnumDescription("Diagnostic bus location", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.obd_value_lock_added.obd_value_source_lock.msg_id":                                "Message Id that we locked to",
					"value.proto_value.obd_value_lock_added.obd_value_source_lock.tx_id":                                 "Transmission ID that we locked to",
					"value.proto_value.obd_value_lock_added.obd_value_source_lock.obd_emitter_origin":                    metadatahelpers.EnumDescription("Emitter definition origin", fwenumproto.ObdEmitterOrigin_name),
					"value.proto_value.obd_value_lock_added.obd_value_source_lock.last_value_read":                       "Last value read from the locked source",
					"value.proto_value.obd_value_lock_added.obd_value_source_lock.last_read_ago_ms":                      "How long ago the last value was read",
					"value.proto_value.obd_value_lock_added.metadata.delay_ms":                                           "Delay used before locking to a source",
					"value.proto_value.obd_value_lock_added.metadata.firmware_lock_version_number":                       "Firmware lock version number",
					"value.proto_value.obd_value_lock_added.metadata.preferred_source.vehicle_diagnostic_bus":            metadatahelpers.EnumDescription("Preferred Diagnostic bus location", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.obd_value_lock_added.metadata.preferred_source.msg_id":                            "Preferred Message Id",
					"value.proto_value.obd_value_lock_added.metadata.preferred_source.tx_id":                             "Preferred Tx Id",
					"value.proto_value.obd_value_lock_added.metadata.all_sources_seen_before_add.vehicle_diagnostic_bus": metadatahelpers.EnumDescription("Diagnostic bus location", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.obd_value_lock_added.metadata.all_sources_seen_before_add.msg_id":                 "Message Id",
					"value.proto_value.obd_value_lock_added.metadata.all_sources_seen_before_add.tx_id":                  "Tx Id",
					"value.proto_value.obd_value_lock_added.metadata.all_sources_seen_before_add.obd_emitter_origin":     metadatahelpers.EnumDescription("Emitter definition origin", fwenumproto.ObdEmitterOrigin_name),
					"value.proto_value.obd_value_lock_added.metadata.all_sources_seen_before_add.last_value_read":        "Last value read",
					"value.proto_value.obd_value_lock_added.metadata.log_only_mode":                                      "Indicates if the stat is log-only and was not used for actual locking",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDObdValueLockCleared,
			BinaryMessageField: "ObdValueLockCleared",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:            "Information about a cleared obd lock for a particular obd value",
				Frequency:              FrequencyCustom("Reported when lock clears for an obd value"),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.obd_value_lock_cleared.obd_value":                                                     metadatahelpers.EnumDescription("The obd value that had its locked cleared", hubproto.ObdValue_name),
					"value.proto_value.obd_value_lock_cleared.reason":                                                        metadatahelpers.EnumDescription("Reason for lock clear", fwenumproto.ObdValueLockClearedReason_name),
					"value.proto_value.obd_value_lock_cleared.cleared_obd_value_source_lock.vehicle_diagnostic_bus":          metadatahelpers.EnumDescription("Diagnostic bus location", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.obd_value_lock_cleared.cleared_obd_value_source_lock.msg_id":                          "Message Id that we were locked to",
					"value.proto_value.obd_value_lock_cleared.cleared_obd_value_source_lock.tx_id":                           "Transmission ID that we were locked to",
					"value.proto_value.obd_value_lock_cleared.cleared_obd_value_source_lock.obd_emitter_origin":              metadatahelpers.EnumDescription("Emitter definition origin", fwenumproto.ObdEmitterOrigin_name),
					"value.proto_value.obd_value_lock_cleared.cleared_obd_value_source_lock.last_value_read":                 "Last value read from the previously locked source",
					"value.proto_value.obd_value_lock_cleared.metadata.expire_after_ms":                                      "Delay used before expiring the obd value lock",
					"value.proto_value.obd_value_lock_cleared.metadata.firmware_lock_version_number":                         "Firmware lock version number",
					"value.proto_value.obd_value_lock_cleared.metadata.preferred_source.vehicle_diagnostic_bus":              metadatahelpers.EnumDescription("Preferred Diagnostic bus location", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.obd_value_lock_cleared.metadata.preferred_source.msg_id":                              "Preferred Message Id",
					"value.proto_value.obd_value_lock_cleared.metadata.preferred_source.tx_id":                               "Preferred Tx Id",
					"value.proto_value.obd_value_lock_cleared.metadata.all_sources_seen_before_clear.vehicle_diagnostic_bus": metadatahelpers.EnumDescription("Diagnostic bus location", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.obd_value_lock_cleared.metadata.all_sources_seen_before_clear.msg_id":                 "Message Id",
					"value.proto_value.obd_value_lock_cleared.metadata.all_sources_seen_before_clear.tx_id":                  "Tx Id",
					"value.proto_value.obd_value_lock_cleared.metadata.all_sources_seen_before_clear.obd_emitter_origin":     metadatahelpers.EnumDescription("Emitter definition origin", fwenumproto.ObdEmitterOrigin_name),
					"value.proto_value.obd_value_lock_cleared.metadata.all_sources_seen_before_clear.last_value_read":        "Last value read",
					"value.proto_value.obd_value_lock_cleared.metadata.log_only_mode":                                        "Indicates if the stat is log-only and was not used for actual locking",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDOctoCameraConnected,
			BinaryMessageField: "OctoConnectedCameraVideoInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Tracks Octo camera connection state",
				Frequency:           FrequencyOnChange("When Octo camera connection state changes"),
				IntValueDescription: "1 if camera connected, 0 if camera disconnected",
				ColumnDescriptions: map[string]string{
					"value.proto_value.octo_connected_camera_video_info.bitrate":              "The bitrate (bps) of the raw recorded stream.",
					"value.proto_value.octo_connected_camera_video_info.bitrate_control":      metadatahelpers.EnumDescription("Bitrate control dictates how the encoder allocates the encoded audio and video data within the file.", hubproto.BitrateControlType_name),
					"value.proto_value.octo_connected_camera_video_info.codec":                metadatahelpers.EnumDescription("The codec for the raw recorded stream.", hubproto.VideoInfo_Codec_name),
					"value.proto_value.octo_connected_camera_video_info.framerate":            "The framerate (fps) of the raw recorded stream.",
					"value.proto_value.octo_connected_camera_video_info.idr_interval_seconds": metadatahelpers.EnumDescription("Specifies the keyframe rate in seconds between each i-frame in the recorded stream.", hubproto.VideoInfo_IdrIntervalSeconds_name),
					"value.proto_value.octo_connected_camera_video_info.resolution":           metadatahelpers.EnumDescription("Resolution of the raw recorded stream.", hubproto.VideoResolutionEnum_name),
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDOctoDisplayConnected,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Tracks Octo display connection state",
				Frequency:           FrequencyOnChange("When Octo display connection state changes"),
				IntValueDescription: "1 if display connected, 0 if display disconnected",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDOctoThermalSensors,
			BinaryMessageField: "OctoTsens",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:            "Octo thermal information",
				Frequency:              FrequencyEveryXSeconds(10 * samtime.SecondsInMinute),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.octo_tsens.cpuss_0_usr": "CPU temperature in milliC",
					"value.proto_value.octo_tsens.ddr":         "DDR temperature in milliC",
					"value.proto_value.octo_tsens.emmc":        "eMMC temperature in milliC",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDOdometer,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current vehicle odometer distance (km)",
				Frequency:           FrequencyCustom("Reported for every 1km in change"),
				IntValueDescription: "Odometer value, in meters, currently being read from the vehicle",
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(48),
					},
				},
				HourlyCronSchedule: true,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDOdometerLatestExpired,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Firmware odometer stored reading removed",
				Frequency:           FrequencyCustom("Reported on odometer value being cleared"),
				IntValueDescription: "The value, in meters, of the odometer stored on device that has been cleared. Odometer is stored on device to understand what was reported in a previous diagnostic session to avoid reporting jumps in value.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDOdometerLockExpired,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Firmware odometer lock expiration",
				Frequency:           FrequencyCustom("Reported on odometer lock being cleared"),
				IntValueDescription: "Response address of the expiring lock. Odometer requests can have multiple responses from different ECUs. The odometer lock is meant to filter down to a single source. When the lock clears, the locked odometer ECU has stopped responding.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDOemEvChargingEnergyMicroWh,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.TelematicsTag, amundsentags.OemTag, amundsentags.ElectricVehicleTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Energy charged in micro watt hours as reported by the OEM provider.",
				Frequency:           FrequencyCustom("Reported by OEM provider whenever data pull occurs. Varies per OEM."),
				IntValueDescription: "Energy charged in micro watt hours.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDOemEvDistanceDrivenOnElectricPowerMeters,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Tags: []amundsentags.Tag{amundsentags.TelematicsTag, amundsentags.OemTag, amundsentags.ElectricVehicleTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Distance driven on electric power in meters as reported by the OEM provider.",
				Frequency:           FrequencyCustom("Reported by OEM provider whenever data pull occurs. Varies per OEM."),
				IntValueDescription: "Distance driven on electric power in meters.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDOemEvEnergyConsumedMicroWh,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.TelematicsTag, amundsentags.OemTag, amundsentags.ElectricVehicleTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Energy consumed in micro watt hours as reported by the OEM provider.",
				Frequency:           FrequencyCustom("Reported by OEM provider whenever data pull occurs. Varies per OEM."),
				IntValueDescription: "Energy consumed in micro watt hours.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDOemFuelConsumed,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.TelematicsTag, amundsentags.OemTag, amundsentags.FuelTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total fuel consumed in milliliters as reported by the OEM provider",
				Frequency:           FrequencyCustom("Reported by OEM provider whenever data pull occurs. Varies per OEM."),
				IntValueDescription: "Total fuel consumed in milliliters.",
			},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDOemIngestionRawData,
			BinaryMessageField:   "OemIngestionRawData",
			S3BinaryMessageField: "OemIngestionRawDataHumanReadable",
			Kind:                 StatKindObjectStat,
			Tags:                 []amundsentags.Tag{amundsentags.TelematicsTag, amundsentags.OemTag},
			MetadataInfo: &MetadataInfo{
				Description: "Raw OEM API payload for unified ingestion architecture. Writes BOTH BinaryValue (routing metadata + raw bytes for fast Merrily access) and S3BinaryValue (optional human-readable text for debugging).",
				Frequency:   FrequencyCustom("Reported by OEM provider whenever data pull occurs. Varies per OEM."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.oem_ingestion_raw_data.oem_type":                 "OEM type identifier - maps to oemproto.OemType values",
					"value.proto_value.oem_ingestion_raw_data.schema_version":           "OEM API schema version when this payload was received",
					"value.proto_value.oem_ingestion_raw_data.source_id":                "OEM-provided source identifier (e.g., VIN)",
					"value.proto_value.oem_ingestion_raw_data.payload_raw":              "Raw OEM API response payload (exact bytes received) in BinaryValue for efficient Merrily processing.",
					"s3_proto_value.oem_ingestion_raw_data_human_readable.payload_text": "Best-effort human-readable version (e.g., pretty JSON) in S3BinaryValue for debugging; optional. Requires fetchS3DataIfPresent: true in GraphQL.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDOldestRecordingInfo,
			BinaryMessageField: "OldestRecordingInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "An hourly report of the oldest video clip on a Site Gateway.",
				Frequency:   FrequencyCustom("Reported on boot (or reboot), or when video is removed."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.oldest_recording_info":                  "A struct detailing the oldest video clip currently saved on the gateway.",
					"value.proto_value.oldest_recording_info.camera_device_id": "The ID of the cameraDevice the clip belongs to.",
					"value.proto_value.oldest_recording_info.channel":          metadatahelpers.EnumDescription("The channel of the oldest recorded clip.", workforcehubproto.CameraStreamChannel_name),
					"value.proto_value.oldest_recording_info.stream_id":        "The ID of the stream the clip belongs to.",
					"value.proto_value.oldest_recording_info.start_ms":         "The startMs of the video clip (ingested timestamp).",
					"value.proto_value.oldest_recording_info.duration_ms":      "The duration of the video clip.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDOrientedAccelerometer,
			BinaryMessageField: "OrientedHarshEventMetadata",
			Kind:               StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDParkingModeState,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "A stat that is uploaded when parking mode is enabled or disabled",
				IntValueDescription: "Binary value, either 0 for disabled or 1 for enabled. Note that this is sent from the CM.",
				Frequency:           FrequencyOnChange("parking mode changes to enabled/disabled"),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPassengerDtcs,
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			BinaryMessageField: "PassengerDtcs",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Light duty vehicle diagnostic trouble code set",
				Frequency:   FrequencyOnChange("set of DTCs change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.passenger_dtcs.tx_id":      "ECU ID transmitting the DTC information. This is the source of the DTCs. Source addresses are defined as part of ISO 15765-4 (Diagnostics on Controller Area Networks).",
					"value.proto_value.passenger_dtcs.mil_status": "Malfunctioning indicator lamp status",
					"value.proto_value.passenger_dtcs.dtcs":       "List of DTC values. Each DTC value is mapped to a meaning as part of SAE J2012",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPassengerSupportedCommands,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "PassengerCommandsSupported",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: metadatahelpers.DeprecatedDescription("Set of passenger messages seen from a vehicle, replaced by osDDiagnosticMessagesSeen"),
				Frequency:   FrequencyCustom("Once per diagnositic session"),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPgnsSeen,
			BinaryMessageField: "PgnsSeen",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: metadatahelpers.DeprecatedDescription("Set of heavy duty messages seen from a vehicle, replaced by osDDiagnosticMessagesSeen"),
				Frequency:   FrequencyCustom("Once per diagnositic session"),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseAACFreqMicroHertz,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "AC frequency measured at the generator phase A output (uHz)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "AC frequency measured at the generator phase A output (uHz). J1939-DA PGN 65027 Generator Phase A Basic AC Quantities (GPAAC), SPN 2437",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseAAmpsRms,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "RMS current measured at the generator phase A output (mA)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "RMS current measured at the generator phase A output (mA). J1939-DA PGN 65027 Generator Phase A Basic AC Quantities (GPAAC), SPN 2449",
			},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseALLVolts,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Line to Line RMS voltage measured at the generator phase AB output (V)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Line to Line RMS voltage measured at the generator phase AB output (V). J1939-DA PGN 65027 Generator Phase A Basic AC Quantities (GPAAC), SPN 2441",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseALNVolts,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Line to Neutral RMS voltage measured at the generator phase A output (V)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Line to Neutral RMS voltage measured at the generator phase A output (V). J1939-DA PGN 65027 Generator Phase A Basic AC Quantities (GPAAC), SPN 2445",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseBAmpsRms,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "RMS current measured at the generator phase B output (mA)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "RMS current measured at the generator phase B output (mA). J1939-DA PGN 65024 Generator Phase B Basic AC Quantities (GPBAC), SPN 2450",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseBLLVolts,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Line to Line RMS voltage measured at the generator phase BC output (V)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Line to Line RMS voltage measured at the generator phase BC output (V). J1939-DA PGN 65024 Generator Phase A Basic AC Quantities (GPBAC), SPN 2442.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseBLNVolts,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Line to Neutral RMS voltage measured at the generator phase B output (V)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Line to Neutral RMS voltage measured at the generator phase B output (V). J1939-DA PGN 65024 Generator Phase B Basic AC Quantities (GPBAC), SPN 2446",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseCAmpsRms,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "RMS current measured at the generator phase C output (mA)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "RMS current measured at the generator phase C output (mA). J1939-DA PGN 65021 Generator Phase C Basic AC Quantities (GPCAC), SPN 2451",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseCLLVolts,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Line to Line RMS voltage measured at the generator phase CA output (V)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Line to Line RMS voltage measured at the generator phase CA output (V). J1939-DA PGN 65021 Generator Phase C Basic CA Quantities (GPCAC), SPN 2443",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPhaseCLNVolts,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Line to Neutral RMS voltage measured at the generator phase A output (V)",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Line to Neutral RMS voltage measured at the generator phase A output (V). J1939-DA PGN 65021 Generator Phase C Basic AC Quantities (GPCAC), SPN 2447",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPowerFactorRatio,
			Kind:     StatKindObjectStat,
		},

		{
			StatType: objectstatproto.ObjectStatEnum_osDPingCount,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPlc4TrucksAbsCtrlStatus,
			BinaryMessageField: "Plc4TrucksAbsCtrlStatus",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag},
			MetadataInfo: &MetadataInfo{
				Description: "Control status on if the ABS is actively controlling a braking event ",
				Frequency:   FrequencyOnChange("ABS status changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.plc4trucks_abs_ctrl_status.abs_ctrl_status": metadatahelpers.EnumDescription("Status Type", plc4trucksproto.AbsStatus_name),
					"value.proto_value.plc4trucks_abs_ctrl_status.ecu_id":          "Raw network Id of sending node",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPlc4TrucksCableFirmwareDebug,
			BinaryMessageField: "Plc4TrucksCableFirmwareDebug",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag},
			MetadataInfo: &MetadataInfo{
				Description: "Firmware reported by the PLC4Trucks Smart Cable ",
				Frequency:   FrequencyOnChange("PLC4Trucks cable FW changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.plc4trucks_cable_firmware_debug.firmware_version": "Firmware reported by smart cable [bytes]",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPlc4TrucksCableStateDebug,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag},
			MetadataInfo: &MetadataInfo{
				Description:         "State of the UART interface between the AG and Peripheral",
				Frequency:           FrequencyOnChange("Uart State"),
				IntValueDescription: "Current UART-Peripheral state ",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPlc4TrucksConnectedTrailers,
			BinaryMessageField: "Plc4TrucksConnectedTrailers",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag},
			MetadataInfo: &MetadataInfo{
				Description: "Network based Trailers seen on the PLC4Trucks network",
				Frequency:   FrequencyOnChange("On Change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.plc4trucks_connected_trailers.make":          "Make of ABS unit on the network",
					"value.proto_value.plc4trucks_connected_trailers.model":         "Model of ABS unit on the network",
					"value.proto_value.plc4trucks_connected_trailers.serial_number": "SN of ABS unit on the network",
					"value.proto_value.plc4trucks_connected_trailers.ecu_id":        "raw network id of sending node",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPlc4TrucksDataPairsDebug,
			BinaryMessageField: "Plc4TrucksDataPairsDebug",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag},
			MetadataInfo: &MetadataInfo{
				Description: "Unique MID/PID pairs seen on network",
				Frequency:   FrequencyOnChange("MID/PID Pairs per power cycle"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.plc4trucks_data_pairs_debug.mid": "mid of unique data pair",
					"value.proto_value.plc4trucks_data_pairs_debug.pid": "pid of unique data pair",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPlc4TrucksNetworkStateDebug,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag},
			MetadataInfo: &MetadataInfo{
				Description:         "State of the PLC4Trucks Network",
				Frequency:           FrequencyOnChange("PLC4Trucks State"),
				IntValueDescription: "Current Network state",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPlc4TrucksResearchData,
			BinaryMessageField: "Plc4TrucksResearchData",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag},
			MetadataInfo: &MetadataInfo{
				Description:            "Research message used to log investigative data for different PLC signals for PLC4Trucks",
				Frequency:              FrequencyOnChange("Encoded stat"),
				IntValueDescription:    "Value of encoded signal defined in proto signal_id field",
				DoubleValueDescription: "Value of encoded signal defined in proto signal_id field",
				ColumnDescriptions: map[string]string{
					"value.proto_value.plc4trucks_research_data.tx_id":               "TX id of the node that sent the data",
					"value.proto_value.plc4trucks_research_data.signal_id":           metadatahelpers.EnumDescription("Signal Type encoded", plc4trucksproto.Plc4TrucksResearchData_SignalId_name),
					"value.proto_value.plc4trucks_research_data.has_vehicle_message": "If bytes field is populated",
					"value.proto_value.plc4trucks_research_data.vehicle_message":     "Raw message payload [Bytes]",
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDPlcHealth,
			Kind:                     StatKindObjectStat,
			BinaryMessageField:       "PlcHealth",
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPlcStatus,
			BinaryMessageField: "PlcStatus",
			Kind:               StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPneumaticSupplyPressurePa,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.AG52Tag, amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag, amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "The pneumatic supply pressure in Pascals.",
				Frequency:           FrequencyCustom("On change of presure or every 5 mins"),
				IntValueDescription: "The pneumatic supply pressure in Pascals",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPowerMonitor,
			BinaryMessageField: "PowerMonitor",
			Kind:               StatKindObjectStat,
			Production:         false,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Measurements from the on board power monitor. Typically measures properties of the primary power source.",
				Frequency:   FrequencyEveryXSeconds(1 * samtime.SecondsInMinute),
				ColumnDescriptions: map[string]string{
					"value.proto_value.power_monitor.accumulation_duration_ms":                    "Amount of time that has passed since the last attempt at resetting the accumulated energy and charge values. If this does not match with value.proto_value.power_monitor.time_since_successful_accumulation_reset_ms, then there was an error resetting the accumulation and either this or value.proto_value.power_monitor.time_since_successful_accumulation_reset_ms may hold the true duration over which the energy and charge were accumulated, so the truth needs to be extrapolated.",
					"value.proto_value.power_monitor.accumulated_input_energy_micro_joules":       "Total energy accumulated from the primary input power source over the accumulation duration, measured in micro joules. (1 Joule = 1 Watt-second)",
					"value.proto_value.power_monitor.accumulated_input_charge_micro_coulombs":     "Total charge accumulated from the primary input power source over the accumulation duration, measured in micro coulombs. (1 Coulomb = 1 Amp-second)",
					"value.proto_value.power_monitor.time_since_successful_accumulation_reset_ms": "Amount of time that has passed since the last verified successful reset of the accumulated energy and charge values. If this does not match with value.proto_value.power_monitor.accumulation_duration_ms, then there was an error resetting the accumulation and either this or value.proto_value.power_monitor.accumulation_duration_ms may hold the true duration over which the energy and charge were accumulated, so the truth needs to be extrapolated.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDPowerSources,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPowerState,
			BinaryMessageField: "PowerStateInfo",
			Kind:               StatKindObjectStat,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current power state and context",
				Frequency:           FrequencyOnChange("power state of the device changes"),
				IntValueDescription: metadatahelpers.EnumDescription("Current power state", logeventproto.LogEvent_DevicePowerState_StateEnum_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.power_state_info.last_power_state":               metadatahelpers.EnumDescription("Last power state the device is transitioning from.", logeventproto.LogEvent_DevicePowerState_StateEnum_name),
					"value.proto_value.power_state_info.current_power_state":            metadatahelpers.EnumDescription("Current power state.", logeventproto.LogEvent_DevicePowerState_StateEnum_name),
					"value.proto_value.power_state_info.change_reason":                  metadatahelpers.EnumDescription("Reason for the power state transition represented by this stat.", hubproto.ObjectStatBinaryMessage_PowerStateInfo_PowerStateChangeReason_name),
					"value.proto_value.power_state_info.duration_reason":                "Reason why the duration of the last power state changed. Reasons are defined in ObjectStatBinaryMessage_PowerStateInfo_PowerDurationReason",
					"value.proto_value.power_state_info.override_power_duration_active": "Set to true when configured to override the default power state change logic.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPowerTakeoff,
			BinaryMessageField: "ActiveLoggerMetadata",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Production:         true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current driver power take off (PTO) enabled status",
				Frequency:           FrequencyOnChange("PTO status changes"),
				IntValueDescription: "Reports the current state of PTO on a vehicle, with 0 as inactive, 1 as active, and 2 as disconnect. The possible values for this stat are stored on the firmware. There are multiple sources for determining PTO status, and if a single source is active, PTO is considered active. Inactive means that there are no currently active PTO signals. Disconnected means there are no sources to derive PTO status from. Reported by both heavy-duty and passenger vehicles. PTO status in passenger vehicles is non-standard.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.active_logger_metadata.version": "Version of the ActiveLogger that generated this object stat.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPressureVesselHealth,
			BinaryMessageField: "PressureVesselHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Contains information about the pressure vessel health",
				Frequency:   FrequencyCustom("When we read a valid value from third party sensor"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.pressure_vessel_health.temperature_milli_celsius":                   "Temperature of the pressure vessel in degrees milli-Celsius",
					"value.proto_value.pressure_vessel_health.pressure_psi":                                "Pressure of the pressure vessel in pounds per square inch",
					"value.proto_value.pressure_vessel_health.sensor_diagnostics.battery_level_percentage": "Percentage of battery life remaining on the pressure vessel sensor",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPrivacyGeofenceStatus,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "PrivacyGeofenceStatus",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "Contains information about the device's privacy geofence status",
				Frequency:   FrequencyCustom("When a device enters or exits a privacy geofence"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.privacy_geofence_status.geofence_action": "whether the device entered or exited a geofence",
					"value.proto_value.privacy_geofence_status.geofence_id":     "ID of the geofence that the device entered or exited",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDPrivacyMode,
			BinaryMessageField: "PrivacyModeInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Contains information about privacy mode or personal trip.",
				Frequency:           FrequencyCustom("On firmware configuration change or button press"),
				IntValueDescription: metadatahelpers.EnumDescription("State", hubproto.PrivacyModeState_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.privacy_mode_info.state":   metadatahelpers.EnumDescription("State", hubproto.PrivacyModeState_name),
					"value.proto_value.privacy_mode_info.trigger": metadatahelpers.EnumDescription("Source for state", hubproto.PrivacyModeInfo_PrivacyModeTrigger_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDQcs603EmergencyDownloaderModeRecoveryInfo,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "Qcs603EmergencyDownloaderModeRecoveryInfo",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "CM emergency downloader mode recovery info.",
				Frequency:   FrequencyCustom("When CM emergency downloader mode recovery succeeds or fails"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.qcs603_emergency_downloader_mode_recovery_info.duration_ms":                             "time duration milliseconds from recovery start to recovery success or failure",
					"value.proto_value.qcs603_emergency_downloader_mode_recovery_info.method":                                  metadatahelpers.EnumDescription("Recovery method attempted", hubproto.Qcs603EmergencyDownloaderModeRecoveryInfo_Method_name),
					"value.proto_value.qcs603_emergency_downloader_mode_recovery_info.successful":                              "bool indicating if the recovery was successful",
					"value.proto_value.qcs603_emergency_downloader_mode_recovery_info.used_golang_sahara_reset_implementation": "bool indicating if the golang Sahara implementation was used instead of the Qualcomm precompiled binary",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDQcs603UsbCurrentLimitMilliAmps,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "The PMIC setting on the qcs603 platform for the maximum allowed current draw over USB in milliamps",
				Frequency:           FrequencyCustom("on startup and on change"),
				IntValueDescription: "Current value in milliamps",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDQRCodeScan,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "QRCode",
			Tags:               []amundsentags.Tag{amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "QR Code driver assignment scans",
				Frequency:   FrequencyCustom("Reported when a driver scans an QR Code (via an inward-facing CM) in a vehicle"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.q_r_code.magic":                        "Magic value to verify that this is a Samsara-generated QR code",
					"value.proto_value.q_r_code.version_id":                   "Version of the QR code that was read by the CM",
					"value.proto_value.q_r_code.driver_assignment_lookup_key": "UUID used to identify the driver that this QR code belongs to",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDQRCodeScanDebug,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "QRCodeScanDebug",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "QR Code scan debug information. Logging of this object stat is controlled via QRCodeReaderConfig.ScanDebugLoggingConfig. Enabled by default in firmware.",
				Frequency:   FrequencyCustom("When a QR code is detected by the QR code scanner"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.q_r_code_scan_debug.scan_status":                       metadatahelpers.EnumDescription("Scan status", qrcodeproto.QRCodeScanStatus_name),
					"value.proto_value.q_r_code_scan_debug.points":                            "List of points detected on the QR code",
					"value.proto_value.q_r_code_scan_debug.points.x_frac":                     "X coordinate of point reported as fraction",
					"value.proto_value.q_r_code_scan_debug.points.y_frac":                     "Y coordinate of point reported as fraction",
					"value.proto_value.q_r_code_scan_debug.data":                              "Raw bytes of the decoded QR code. Should be at most 3KB as per QR code spec, but samsara QR codes are ~45 bytes",
					"value.proto_value.q_r_code_scan_debug.code":                              "Result of unmarshalling raw data bytes into QRCode object",
					"value.proto_value.q_r_code_scan_debug.code.magic":                        "Magic value to verify that this is a Samsara-generated QR code",
					"value.proto_value.q_r_code_scan_debug.code.version_id":                   "Version of the QR code that was read by the CM",
					"value.proto_value.q_r_code_scan_debug.code.driver_assignment_lookup_key": "UUID used to identify the driver that this QR code belongs to",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDQRCodeScanningState,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "QRCodeScanningState",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "QR code scanning state",
				Frequency:   FrequencyCustom("On service start/stop and on scanning state change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.q_r_code_scanning_state.state": metadatahelpers.EnumDescription("scanning state", qrcodeproto.QRCodeScanningState_State_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDRawVins,
			BinaryMessageField: "RawVins",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Unfiltered and unmodified VINs reported from a vehicle",
				Frequency:   FrequencyOnChange("when VIN response received"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.raw_vins.raw_vins":                             "Raw vin responses from connected vehicle. The firmware does processing on these VINs, and may block these VINs from being uploaded based on vehicle location and vin validation rules.",
					"value.proto_value.raw_vins.raw_vin_infos":                        "Raw vin responses from connected vehicle with the ECU sending the VIN information. The firmware does processing on these VINs, and may block these VINs from being uploaded based on vehicle location and vin validation rules.",
					"value.proto_value.raw_vins.raw_vin_infos.raw_vin":                "The VIN reported by an ECU on a vehicle",
					"value.proto_value.raw_vins.raw_vin_infos.vehicle_diagnostic_bus": "Vehicle network containing the VIN.",
					"value.proto_value.raw_vins.raw_vin_infos.tx_id":                  "ECU reporting the data",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDRearCameraConnected,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Logs each rear camera connect event to the VG.",
				Frequency:           FrequencyOnChange("Rear camera connects or disconnects from the VG"),
				IntValueDescription: "Binary value, either 0 for a disconnect or 1 for a connect. Note that this is generated on the VG, and the VG communicates with the CM over GRPC to get the relevant connection state.",
				ColumnDescriptions: map[string]string{
					"object_id": "VG device id",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDRearCameraFrameState,
			Production:    true,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reports whether the CM3X is receiving frames from rear camera",
				Frequency:           FrequencyOnChange("Rear camera recording state changes"),
				IntValueDescription: metadatahelpers.EnumDescription("Rear camera recording state. Receiving frames with signal lock indicates we are receiving real frames. Without signal lock means we are getting black/blue frames.", hubproto.RearCameraFrameState_name),
				ColumnDescriptions: map[string]string{
					"object_id": "CM3X device id.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReboot,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDRebootToReadOnlyEvent,
			BinaryMessageField: "RebootToReadOnlyEvent",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Timing and general info about events that happen as part of the reboot to read only sequence triggered by switch to battery power on VGs",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferActiveZones,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) number of zones available",
				Frequency:           FrequencyOnChange("when we see another available zone"),
				IntValueDescription: "Number of available zones seen on reefer",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferAlarms,
			BinaryMessageField: "ReeferAlarmState",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferAmbientAirTempMilliC,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "The temperature of the atmosphere around the reefer.",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Ambient Temperature in mC",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferAttachedController,
			BinaryMessageField: "ReeferAttachedController",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Value representing what type of Thermoking Ibox is connected",
				IntValueDescription: "Type of controller connected. Requested over CAN with DID 1F15F6.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferBattVoltageMilliV,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferCommandMetadata,
			BinaryMessageField: "ReeferCommandMetadata",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Refridgeration unit (reefer) metadata from sending a command to a reefer over CAN.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_command_metadata.command":             "Raw command sent to the reefer over CAN, represented as a string.",
					"value.proto_value.reefer_command_metadata.reefer_command_type": metadatahelpers.EnumDescription("Translation of command sent.", hubproto.ObjectStatBinaryMessage_ReeferCommandMetadata_ReeferCommandType_name),
					"value.proto_value.reefer_command_metadata.error":               "Error raised while sending the command.",
					"value.proto_value.reefer_command_metadata.duration_ms":         "Amount of time (milliseconds) the command took to send",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferDispRetAirTempMilliC,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) display air temperature (mC)",
				Frequency:           FrequencyOnChange("when a the temperature changes at least 500mC"),
				IntValueDescription: "Current temperature on the reefer display (mC)",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferDoorOpen,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "ReeferDoorSwitchControl",
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) door open/closed status",
				Frequency:           FrequencyOnChange("door switch becomes enabled/disabled or changes state - open or closed"),
				IntValueDescription: "Door open/closed - 0 closed 1 open",
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_door_switch_control.enabled": "Door switch enabled or disabled",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferDoorOpenZone1,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "ReeferDoorSwitchControl",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) zone 1 door open/closed status",
				Frequency:           FrequencyOnChange("Zone 1 door switch becomes enabled/disabled or changes state - open or closed"),
				IntValueDescription: "Zone 1 door open/closed - 0 closed 1 open",
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_door_switch_control.enabled": "Zone 1 door switch enabled or disabled",
				},
			},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferDoorOpenZone2,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "ReeferDoorSwitchControl",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) zone 2 door open/closed status",
				Frequency:           FrequencyOnChange("Zone 2 door switch becomes enabled/disabled or changes state - open or closed"),
				IntValueDescription: "Zone 2 door open/closed - 0 closed 1 open",
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_door_switch_control.enabled": "Zone 2 door switch enabled or disabled",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferDoorOpenZone3,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "ReeferDoorSwitchControl",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) zone 3 door open/closed status",
				Frequency:           FrequencyOnChange("Zone 3 door switch becomes enabled/disabled or changes state - open or closed"),
				IntValueDescription: "Zone 3 door open/closed - 0 closed 1 open",
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_door_switch_control.enabled": "Zone 3 door switch enabled or disabled",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferEngineHours,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) current engine runtime (hours)",
				Frequency:           FrequencyOnChange("engine hours"),
				IntValueDescription: "Current refridgeration unit runtime (hours)",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferEngineHoursZone2,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) current engine runtime (hours) of zone2",
				Frequency:           FrequencyOnChange("engine hours zone 2"),
				IntValueDescription: "Current refridgeration unit zone 2 runtime (hours)",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferFuelLevelPercent,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) fuel level (%)",
				Frequency:           FrequencyOnChange("fuel remaining percent changes"),
				IntValueDescription: "Amount of fuel in the reefer fuel tank (%).",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferHeartbeat,
			BinaryMessageField: "ReeferHeartbeat",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Refridgeration unit (reefer) heartbeat",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_heartbeat.heartbeat_period_sec":        "Seconds between heartbeats (default is 5 minutes, not configurable)",
					"value.proto_value.reefer_heartbeat.heartbeat_status":            metadatahelpers.EnumDescription("Status of heartbeat", hubproto.ObjectStatBinaryMessage_ReeferHeartbeat_ReeferHBStatus_name),
					"value.proto_value.reefer_heartbeat.heartbeat_error_description": "Description of error if heartbeat_status was ON_FAILURE",
					"value.proto_value.reefer_heartbeat.reefer_type":                 metadatahelpers.EnumDescription("Type of reefer sending a heartbeat", hubproto.ObjectStatBinaryMessage_ReeferHeartbeat_ReeferType_name),
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferOnHours,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) amount of time on (hr)",
				Frequency:           FrequencyOnChange("amount of reefer on time change"),
				IntValueDescription: "Amount of time (hours) the reefer has been on",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferPowerSource,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "The source of power for the reefer",
				Frequency:           FrequencyOnChange("reefer power source changes"),
				IntValueDescription: "Current reefer power source, can be 1(diesel), 2(electric), 3(cryo) or null. Firmware may also pass 0 for an intentional 'no data' or 'unknown' value.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferPowerStatus,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) power status (enum)",
				Frequency:           FrequencyOnChange("reefer power status changes"),
				IntValueDescription: metadatahelpers.EnumDescription("Current reefer power status, firmware derived.", hubproto.ReeferPowerStatus_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferPretripStatus,
			BinaryMessageField: "ReeferPretripStatus",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Refridgeration unit (reefer) pretrip mode status",
				Frequency:   FrequencyOnChange("reefer pretrip status changes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_pretrip_status.carrier.overall_status":               metadatahelpers.EnumDescription("Status of Carrier pretrip", hubproto.ObjectStatBinaryMessage_ReeferPretripStatus_Carrier_OverallStatus_name),
					"value.proto_value.reefer_pretrip_status.carrier.current_test_number":          "Current Carrier pretrip test number",
					"value.proto_value.reefer_pretrip_status.carrier.current_test_time_elapsed_ms": "Current time (ms) spent in Carrier test",
					"value.proto_value.reefer_pretrip_status.carrier.tests.test_number":            "Carrier pretrip trip number",
					"value.proto_value.reefer_pretrip_status.carrier.tests.status":                 metadatahelpers.EnumDescription("Carrier pretrip test status", hubproto.ObjectStatBinaryMessage_ReeferPretripStatus_Carrier_Test_Status_name),
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferReturnAirTempMilliCZone2,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) Zone 2 display air temperature (mC)",
				Frequency:           FrequencyOnChange("when a the temperature changes at least 100mC"),
				IntValueDescription: "Current temperature on the reefer display Zone 2 (mC)",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferReturnAirTempMilliCZone3,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) Zone 3 display air temperature (mC)",
				Frequency:           FrequencyOnChange("when a the temperature changes at least 100mC"),
				IntValueDescription: "Current temperature on the reefer display Zone 3 (mC)",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferRoadHoursZone1,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) zone 1 road hours",
				Frequency:           FrequencyOnChange("reefer zone 1 road hours changes"),
				IntValueDescription: "Road hours (in hrs) of zone 1",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferRoadHoursZone2,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) zone 2 road hours",
				Frequency:           FrequencyOnChange("rreefer zone 1 road hours changes"),
				IntValueDescription: "Road hours (in hrs) of zone 1",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferRunMode,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) run mode (enum)",
				Frequency:           FrequencyOnChange("reefer run mode changes"),
				IntValueDescription: metadatahelpers.EnumDescription("Current reefer operating mode", hubproto.ReeferRunModeEnum_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferState,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "ReeferStatus",
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) state (enum)",
				Frequency:           FrequencyOnChange("reefer state changes"),
				IntValueDescription: metadatahelpers.EnumDescription("Current reefer state, firmware derived.", hubproto.ReeferStatusEnum_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_status.substate": metadatahelpers.EnumDescription("Substate of reefer", hubproto.ObjectStatBinaryMessage_ReeferStatus_Substate_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferStateZone1,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "ReeferStatus",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) zone 1 state (enum)",
				Frequency:           FrequencyOnChange("reefer state changes zone 1"),
				IntValueDescription: metadatahelpers.EnumDescription("Current reefer zone 1 state, firmware derived.", hubproto.ReeferStatusEnum_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_status.substate": metadatahelpers.EnumDescription("Substate zone 1 reefer", hubproto.ObjectStatBinaryMessage_ReeferStatus_Substate_name),
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferStateZone2,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			BinaryMessageField: "ReeferStatus",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) zone 2 state (enum)",
				Frequency:           FrequencyOnChange("reefer state changes zone 2"),
				IntValueDescription: metadatahelpers.EnumDescription("Current reefer zone 2 state, firmware derived.", hubproto.ReeferStatusEnum_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_status.substate": metadatahelpers.EnumDescription("Substate zone 2 reefer", hubproto.ObjectStatBinaryMessage_ReeferStatus_Substate_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDReeferStateZone3,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "ReeferStatus",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Refridgeration unit (reefer) zone 3 state (enum)",
				Frequency:           FrequencyOnChange("reefer state changes zone 3"),
				IntValueDescription: metadatahelpers.EnumDescription("Current reefer zone 3 state, firmware derived.", hubproto.ReeferStatusEnum_name),
				ColumnDescriptions: map[string]string{
					"value.proto_value.reefer_status.substate": metadatahelpers.EnumDescription("Substate zone 3 reefer", hubproto.ObjectStatBinaryMessage_ReeferStatus_Substate_name),
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferSupplyAirTempMilliC,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reefer's discharge air temperature for Zone 1",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Discharge Temperature in mC",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferSupplyAirTempMilliCZone2,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reefer's discharge air temperature for Zone 2",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Discharge Temperature in mC",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferSupplyAirTempMilliCZone3,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reefer's discharge air temperature for Zone 3",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Discharge Temperature in mC",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferTemperatureRecorderTempMilliCZone1,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reefer's temperature recorder temp read for Zone 1",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Sensor Temperature in mC",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferTemperatureRecorderTempMilliCZone2,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reefer's temperature recorder temp read for Zone 2",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Sensor Temperature in mC",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferTemperatureRecorderTempMilliCZone3,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reefer's temperature recorder temp read for Zone 3",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Sensor Temperature in mC",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferTemperatureRecorderTempMilliCZone4,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reefer's temperature recorder temp read for Zone 4",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Sensor Temperature in mC",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferTemperatureRecorderTempMilliCZone5,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reefer's temperature recorder temp read for Zone 5",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Sensor Temperature in mC",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDReeferTemperatureRecorderTempMilliCZone6,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.ReeferTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Reefer's temperature recorder temp read for Zone 6",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Sensor Temperature in mC",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDRegenBrakingMs,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			Production:    true,
			MetadataInfo: &MetadataInfo{
				Description:         "Regen braking time in milliseconds",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Regen braking time in milliseconds",
			},
			InternalOverrides: &DataplatformOverrides{
				HourlyCronSchedule: true,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDRemoteSensingMeasurement,
			BinaryMessageField: "RemoteSensingMeasurement",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Measurement taken by a remote sensing device",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.remote_sensing_measurement.distance_mm":            "Distance in millimeters",
					"value.proto_value.remote_sensing_measurement.signal_to_noise_ratio":  "Signal to noise ratio",
					"value.proto_value.remote_sensing_measurement.status":                 metadatahelpers.EnumDescription("Status of the remote sensing measurement", bleproxyproto.LevelSensingMeasurementStatus_name),
					"value.proto_value.remote_sensing_measurement.bifrost_app_error_code": "Bifrost app error code",
					"value.proto_value.remote_sensing_measurement.fw_version":             "Firmware version of the remote sensing device",
				},
			},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDReportedDeviceConfig,
			DataModelStat:        true,
			Kind:                 StatKindObjectStat,
			S3BinaryMessageField: "ReportedDeviceConfig",
			s3BigStatFieldsToExclude: []string{
				"s3_proto_value.reported_device_config.device_config.tile_manager_config.tile_overrides_debug",
			},
			Tags: []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Current config proto in use on a device",
				Frequency:   FrequencyOnChange("when a config changes or on boot"),
			},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDReportUploadAccelDebug,
			Kind:                 StatKindObjectStat,
			S3BinaryMessageField: "AccelEventData",
			Tags:                 []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Sensor data (IMU, GPS, ECU, ...) uploaded along with a video retrieval when the CAMERA_LOGEVENT stream is requested.",
				Frequency:   FrequencyCustom("When a video + metadata retrieval is performed."),
				ColumnDescriptions: map[string]string{
					"s3_proto_value.accel_event_data.recent_accel":                      "Raw acceleration samples from the IMU's accelerometer sensor, 104Hz, +/-4g, 3 axes (x, y, z)",
					"s3_proto_value.accel_event_data.recent_accel.offset_from_event_ms": "Offset in ms of the sample with respect to the timestamp of the object stat (changedAtMs). This field has the same definition for other sensor data reported in this object stat (recent_gps, ecu_speed, etc).",
					"s3_proto_value.accel_event_data.recent_gyro":                       "Raw angular velocity samples from the IMU's gyroscope sensor, 104Hz, +/-250dps, 3 axes (x, y, z)",
					"s3_proto_value.accel_event_data.recent_gps":                        "GPS data, 1Hz. There will be gaps whenever there's no GPS reception (indoors, ...).",
					"s3_proto_value.accel_event_data.recent_gps.ts":                     "Unixtime in milliseconds",
					"s3_proto_value.accel_event_data.recent_gps.speed":                  "Speed in milliknots",
					"s3_proto_value.accel_event_data.recent_gps.heading":                "Heading in millidegrees",
					"s3_proto_value.accel_event_data.ecu_speed":                         "The speed of the vehicle in milliknots as reported by the ECU over CAN bus. Sampling frequency depends on vehicle.",
					"s3_proto_value.accel_event_data.accel_pedal":                       "Acceleration pedal position. Value between 0-1000 where 0 is completely disengaged and 1000 is completely engaged.",
					"s3_proto_value.accel_event_data.brake":                             "Brake pedal position. brake_on is true if the brake pedal is engaged, false if not.",
					"s3_proto_value.accel_event_data.cruise_control":                    "Cruise control values (true/false).",
				},
			},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDReversingEvent,
			Kind:                 StatKindObjectStat,
			BinaryMessageField:   "ReversingEvent",
			S3BinaryMessageField: "ReversingEventMetadata",
			Tags:                 []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Events corresponding to the vehicle reversing. Not supported for all vehicles.",
				Frequency:   FrequencyOnChange("when a reversing event is detected"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.reversing_event.duration_ms":                            "Duration of the event in milliseconds. Can include multiple subsequent reversing actions separated by short forward-driving sections.",
					"value.proto_value.reversing_event.distance_traveled_m":                    "Approximate distance traveled with the reverse gear engaged, in meters.",
					"value.proto_value.reversing_event.max_speed_kmph":                         "Maximum speed in km/h reached during the event, with the reverse gear engaged.",
					"value.proto_value.reversing_event.time_since_last_forward_move_secs":      "Time in seconds since the last time the vehicle moved forward for a certain amount of time/distance/speed. Set to zero if the vehicle never moved forward, or if we don't know when was the last time it did.",
					"value.proto_value.reversing_event.time_since_last_forward_move_valid":     "False if we don't know when was the last time the vehicle moved forward, in which case time_since_last_forward_move_secs will also be zero.",
					"value.proto_value.reversing_event.time_since_state_is_known_secs":         "Time in seconds since we know the state of the vehicle. Only populated if time_since_last_forward_move_valid is false, to make business-logic decisions.",
					"value.proto_value.reversing_event.event_end_reason":                       "Enum describing the reason the reversing event ended.",
					"value.proto_value.reversing_event.location_start":                         "Start location of the event: this is the location corresponding to the object stat timestamp.",
					"value.proto_value.reversing_event.location_end":                           "End location of the event: this is the location corresponding to the object stat timestamp + duration_ms.",
					"s3_proto_value.reversing_event_metadata.ecu_speed":                        "Raw ECU speed values around event time. Availability and sampling frequency depend on the vehicle.",
					"s3_proto_value.reversing_event_metadata.ecu_speed.offset_from_event_ms":   "The time delta in milliseconds between the first sample and the event time (object stat time). Negative if the first sample is before the event time.",
					"s3_proto_value.reversing_event_metadata.ecu_speed.delta_from_previous_ms": "The time delta in milliseconds between the sample and the previous sample. Zero for the first sample.",
					"s3_proto_value.reversing_event_metadata.ecu_speed.speed_kmph":             "Speed value for the sample.",
					"s3_proto_value.reversing_event_metadata.gear":                             "Raw gear values around event time. Availability and sampling frequency depend on the vehicle.",
					"s3_proto_value.reversing_event_metadata.location":                         "Raw location values around event time. Sampling is generally 1Hz, and availability subject to indoor/tunnel/etc limitations.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDRFIDReaderScan,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "RfidScanEvent",
			Tags:               []amundsentags.Tag{amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "ID Card Reader (aka RFID Card) driver assignment scans",
				Frequency:   FrequencyCustom("Reported when a driver scans an ID Card (aka RFID Card) in a vehicle"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.rfid_scan_event.card_number": "ID Card number used to identify the driver via rfid_card_holder_assignments table in statsdb",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDriverAppHeartbeat,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Indicates when a driver had a Driver App session connected to the backend",
				Frequency:   FrequencyOnChange("Emitted when a driver app connects to the backend and updated every 50 seconds until the app disconnects"),
				ColumnDescriptions: map[string]string{
					"object_id":  "Driver ID",
					"value.time": "Last known time the driver was connected to the backend via the Driver App",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDriverCardBatteryInfo,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "DriverCardBatteryInfo",
			MetadataInfo: &MetadataInfo{
				Description: "The object ID for this stat is the driver card ID. The proto value will contain the gateway that saw the driver card as well as the seen battery voltage",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDriverCardToDevice,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Driver card ID detected by a nearby device",
				Frequency:   FrequencyEveryXSeconds(60),
				ColumnDescriptions: map[string]string{
					"object_id":          "Driver Card ID number",
					"value.time":         "Timestamp of the objectstat",
					"value.int_value":    "device_id of the device which is receiving the signal from the driver card identified by object_id",
					"value.double_value": "RSSI (signal strength in dBm) for the driver card identified by the object_id as received by the device (RSSI is used to prioritise card number by signal strength when there are multiple)",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDRoadDepartureAEBSState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Road Departure Automated Emergency Braking System State",
				Frequency:           FrequencyCustom("On change, at least every minute, at most every second"),
				IntValueDescription: "Current state of the Road Departure Automated Emergency Braking System, if fitted on the vehicle.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDRochester6318Debug,
			BinaryMessageField: "Rochester_6318Debug",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Decoded data from the Rochester 6318 Advertisement Packet",
				Frequency:   FrequencyEveryXSeconds(4),
				ColumnDescriptions: map[string]string{
					"value.proto_value.rochester_6318_debug.status":                     metadatahelpers.EnumDescription("Status based on the fill level detected by the sensor to indicate over filling, under filling, normal range and sensor errors.", hubproto.Rochester6318Debug_Status_name),
					"value.proto_value.rochester_6318_debug.fill_millipercent":          "Fill level detected by the sensor as a percentage",
					"value.proto_value.rochester_6318_debug.battery_level_millipercent": "Battery level detected by the sensor as a percentage",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDRollingStopAlgorithmFilterReason,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "RollingStopAlgorithmFilterReason",
			MetadataInfo: &MetadataInfo{
				Description: "Reason that a rolling stop harsh event was filtered out by firmware.",
				Frequency:   FrequencyCustom("Whenever an event was filtered out"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.rolling_stop_algorithm_filter_reason.filter_reason":               metadatahelpers.EnumDescription("Algorithm filter reason enum", maptileproto.AlgorithmFilterReason_name),
					"value.proto_value.rolling_stop_algorithm_filter_reason.stop_location":               "The stop location that was filtered out. Set to nil for filter reasons unrelated to a specific stop location",
					"value.proto_value.rolling_stop_algorithm_filter_reason.stop_location.location_type": metadatahelpers.EnumDescription("Type of stop location", maptileproto.StopLocationCollection_StopLocation_StopLocationType_name),
					"value.proto_value.rolling_stop_algorithm_filter_reason.stop_location.node_id":       "node id of the stop location",
					"value.proto_value.rolling_stop_algorithm_filter_reason.stop_location.layer_source":  "tile layer from which the stop location was loaded",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDRpmGreenBandMs,
			BinaryMessageField: "ConfiguredRpmGreenBand",
			Kind:               StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Tags: []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.EcoDrivingTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Duration of vehicle running in a specific RPM range",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "Amount of time the vehicle was running in a green-band RPM range.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.configured_rpm_green_band.lower_limit_rpm": "Lower limit used for green band RPM range. Configurable, default 800RPM",
					"value.proto_value.configured_rpm_green_band.upper_limit_rpm": "Upper limit used for green band RPM range. Configurable, default 1700RPM",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSafetyEngineState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:         "NOT MEANT TO REPLACE osDEngineState! Safety needs this stat to help debug the new FW side publisher and perhaps display a graph to a customer. Note that this status uses the object stat flags!",
				Frequency:           FrequencyOnChange("engine state changes"),
				IntValueDescription: metadatahelpers.EnumDescription("Current engine state", hubproto.SafetyEngineState_name),
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderActualSpreadRateDryMilligramsPerMeter,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current actual dry material spread rate (mg/m)",
				Frequency:           FrequencyOnChange("dry material spread rate"),
				IntValueDescription: "Current actual dry material spread rate in milligrams per meter. Spread rates can be used to estimate total material usage. If this stat is not reported, but the set point rate is, it is a limitation of the controller manufacturer. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderActualSpreadRatePrewetLitersPerTonne,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current actual prewet material spread rate (L/tonne)",
				Frequency:           FrequencyOnChange("prewet material spread rate"),
				IntValueDescription: "Current actual prewet material spread rate in milliliters per tonne. Spreaders report either the mixture ration of wet to dry material for the spread rate, or the combined amount of material in milliliters per meter. If this stat is not reported, but the set point rate is, it is a limitation of the controller manufacturer. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderActualSpreadRatePrewetMillilitersPerMeter,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current actual prewet material spread rate (ml/m)",
				Frequency:           FrequencyOnChange("prewet material spread rate"),
				IntValueDescription: "Current actual prewet material spread rate in milliliters per meter. Spreaders report either the mixture ration of wet to dry material for the spread rate, or the combined amount of material in milliliters per meter. If this stat is not reported, but the set point rate is, it is a limitation of the controller manufacturer. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderActualSpreadRateWetMillilitersPerMeter,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current actual wet material spread rate (ml/m)",
				Frequency:           FrequencyOnChange("wet material spread rate"),
				IntValueDescription: "Current actual wet material spread rate in milliliters per meter. If this stat is not reported, but the set point rate is, it is a limitation of the manufacturer. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderAirTempMilliC,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Air temperature from a material spreader (mC)",
				Frequency:           FrequencyOnChange("air temperature change"),
				IntValueDescription: "Current air temperature reading from the material spreader. Not all material spreaders report temperature. This may also come from another serial device, depending on the integration. Material spreaders may also integrate with external temperature sensors and relay data through the spreader controller.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderAutomationState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current automation state of the spreader, if the spreader is in manual spread, or automatic spread (closed vs open loop automatic)",
				Frequency:           FrequencyOnChange("spreader automation state"),
				IntValueDescription: metadatahelpers.EnumDescription("Material spreader automation state, values can be unknown, manual, automatic_closed_loop, automatic_open_loop", hubproto.SaltSpreaderAutomationState_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderDerivedQuantitySpreadDryMilligrams,
			BinaryMessageField: "DerivedSpreadQuantity",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Derived quantity of dry material spread",
				Frequency:   FrequencyOnChange("dry material spread"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.derived_spread_quantity.quantity":                 "Quantity of dry material spread in milligrams",
					"value.proto_value.derived_spread_quantity.material_name":            "Name of the material spread",
					"value.proto_value.derived_spread_quantity.calculation_method":       metadatahelpers.EnumDescription("Method used to calculate the derived quantity, for audit purposes", hubproto.DerivedSpreadQuantity_CalculationMethod_name),
					"value.proto_value.derived_spread_quantity.calculation_details_json": "Additional details about the calculation, for audit purposes",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderDerivedQuantitySpreadPrewetMilliliters,
			BinaryMessageField: "DerivedSpreadQuantity",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Derived quantity of prewet material spread",
				Frequency:   FrequencyOnChange("prewet material spread"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.derived_spread_quantity.quantity":                 "Quantity of prewet material spread in milliliters",
					"value.proto_value.derived_spread_quantity.material_name":            "Name of the material spread",
					"value.proto_value.derived_spread_quantity.calculation_method":       metadatahelpers.EnumDescription("Method used to calculate the derived quantity, for audit purposes", hubproto.DerivedSpreadQuantity_CalculationMethod_name),
					"value.proto_value.derived_spread_quantity.calculation_details_json": "Additional details about the calculation, for audit purposes",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderDerivedQuantitySpreadWetMilliliters,
			BinaryMessageField: "DerivedSpreadQuantity",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Derived quantity of wet material spread",
				Frequency:   FrequencyOnChange("wet material spread"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.derived_spread_quantity.quantity":                 "Quantity of wet material spread in milliliters",
					"value.proto_value.derived_spread_quantity.material_name":            "Name of the material spread",
					"value.proto_value.derived_spread_quantity.calculation_method":       metadatahelpers.EnumDescription("Method used to calculate the derived quantity, for audit purposes", hubproto.DerivedSpreadQuantity_CalculationMethod_name),
					"value.proto_value.derived_spread_quantity.calculation_details_json": "Additional details about the calculation, for audit purposes",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderGranularSeasonTotal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of granular material spread this season in metric tonnes",
				Frequency:           FrequencyOnChange("granular material spread"),
				IntValueDescription: "Total amount of granular material spread this season in metric tonnes",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderGranularTotal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of granular material spread in metric tonnes",
				Frequency:           FrequencyOnChange("granular material spread"),
				IntValueDescription: "Total amount of granular material spread in metric tonnes",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderGranularTripTotal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of granular material spread this trip in metric tonnes",
				Frequency:           FrequencyOnChange("granular material spread"),
				IntValueDescription: "Total amount of granular material spread this trip in metric tonnes",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderGroundSpeedMilliknots,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current ground speed (mkn) as seen from the material spreader",
				Frequency:           FrequencyOnChange("on change +- 1 knot"),
				IntValueDescription: "The reported speed from the material spreader over RS232. The material spreaders are typically also connected to the vehicle primary J1939 network, meaning that speed should be derived from the vehicle.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderGroundTempMilliC,
			DataModelStat: true,
			Kind:          StatKindObjectStat,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Ground temperature from a material spreader (mC)",
				Frequency:           FrequencyOnChange("ground temperature change"),
				IntValueDescription: "Current ground temperature reading from the material spreader. Not all material spreaders report temperature. This may also come from another serial device, depending on the integration. Material spreaders may also integrate with external temperature sensors and relay data through the spreader controller.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderIceThicknessMillimeters,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Ice thickness",
				Frequency:           FrequencyOnChange("ice thickness"),
				IntValueDescription: "Ice film height on the road in millimeters",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderJoystickDirection,
			Kind:       StatKindObjectStat,
			Production: true,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Direction joystick is being pressed.",
				Frequency:           FrequencyOnChange("joystick direction change. Change is dependent on OEM"),
				IntValueDescription: metadatahelpers.EnumDescription("Material spreader controllers, depending on the OEM, have a joystick to push a connected plow up or down. The amount of deflection of the joystick implies the direction a plow is being set by the operator. For Rexroth controllers, only changes of at least 10 degrees are recognized in the protocol itself. This is NOT an direct indication of the plow status, but gives an indication.", objectstatproto.JoystickDirection_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderMajorEvent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Material spreader blast status detected",
				Frequency:           FrequencyOnChange("material blasting"),
				IntValueDescription: "Number of transitions from blasting material to not blasting material. Notes a heavy increase in usage of material",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderMaterialNameGranular,
			BinaryMessageField: "DiagnosticValue",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "The current name of material type currently in use",
				Frequency:   FrequencyOnChange("material type being used"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_value.string_value": "The name of material currently being spread",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderMaterialNameLiquid,
			BinaryMessageField: "DiagnosticValue",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "The current name of material type currently in use",
				Frequency:   FrequencyOnChange("material type being used"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_value.string_value": "The name of material currently being spread",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderMaterialNamePrewet,
			BinaryMessageField: "DiagnosticValue",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "The current name of material type currently in use",
				Frequency:   FrequencyOnChange("material type being used"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_value.string_value": "The name of material currently being spread",
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderNormalizedSpreadRateDryMilligramsPerMeter,
			Production:    true,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current normalized spread rate of dry material (in milligrams per meter). This value is derived from osDSaltSpreaderSpreadRateDryMilligramsPerMeter and is normalized whenever it exceeds the predefined threshold for the corresponding spreader model.",
				Frequency:           FrequencyOnChange("similar to osDSaltSpreaderSpreadRateDryMilligramsPerMeter"),
				IntValueDescription: "Current dry material spread rate in milligrams per meter, derived from osDSaltSpreaderSpreadRateDryMilligramsPerMeter. The value is normalized to avoid exceeding predefined thresholds.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderNormalizedSpreadRateWetMillilitersPerMeter,
			Production:    true,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current normalized spread rate of wet material (in milliliters per meter). This value is derived from osDSaltSpreaderSpreadRateWetMillilitersPerMeter and is normalized whenever it exceeds the predefined threshold for the corresponding spreader model.",
				Frequency:           FrequencyOnChange("similar to osDSaltSpreaderSpreadRateWetMillilitersPerMeter"),
				IntValueDescription: "Current wet material spread rate in milliliters per meter, derived from osDSaltSpreaderSpreadRateWetMillilitersPerMeter. The value is normalized to avoid exceeding predefined thresholds.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderPlowStatus,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "The status of the material spreader front plow and its position",
				Frequency:           FrequencyOnChange("material type being used"),
				IntValueDescription: metadatahelpers.EnumDescription("Front plow position status", hubproto.MaterialSpreaderPlowStatus_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderPrewetSeasonTotal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of prewet material spread this season in litres",
				Frequency:           FrequencyOnChange("prewet material spread"),
				IntValueDescription: "Total amount of prewet material spread this season in litres",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderPrewetTotal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of prewet material spread in litres",
				Frequency:           FrequencyOnChange("prewet material spread"),
				IntValueDescription: "Total amount of prewet material spread in litres",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderPrewetTripTotal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of prewet material spread this trip in litres",
				Frequency:           FrequencyOnChange("prewet material spread"),
				IntValueDescription: "Total amount of prewet material spread this trip in litres",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderQuantitySpreadDryMilligrams,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of dry material remaining (mg)",
				Frequency:           FrequencyOnChange("total dry material changing"),
				IntValueDescription: "A delta between the previous and current amount of total material spread, representing the total amount of material used between two stats",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderQuantitySpreadPrewetMilliliters,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of pre-wet material remaining (ml)",
				Frequency:           FrequencyOnChange("total dry material changing"),
				IntValueDescription: "A delta between the previous and current amount of total material spread, representing the total amount of material used between two stats",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderQuantitySpreadWetMilliliters,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of pre-wet material remaining (ml)",
				Frequency:           FrequencyOnChange("total dry material changing"),
				IntValueDescription: "A delta between the previous and current amount of total material spread, representing the total amount of material used between two stats",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderRawMessage,
			BinaryMessageField: "SaltRawMessage",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description: "Debug unprocessed serial frames from an RS232 device",
				Frequency:   FrequencyOnChange("on buffer ingested from RS232"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.salt_raw_message": "Raw message byte buffer received by the VG. This needs to be enabled via config override for a device to log. GQL adds hex and binary message fields so you can extract the raw message and add them as tests in the firmware repository.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderRelativeHumidityPercent,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current relative humidity reading (percent)",
				Frequency:           FrequencyOnChange("when the value changes"),
				IntValueDescription: "Some material spreader vendors support reporting of the realtive humidity using a sensor connected to the controller. This value represents the relative humidity being read in percent",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderRoadGripMilli,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Road grip",
				Frequency:           FrequencyOnChange("road grip"),
				IntValueDescription: "Estimated Road Friction. Dimensionless expressed in milli",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderSetPointSpreadRateDryMilligramsPerMeter,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current set point dry material spread rate (mg/m)",
				Frequency:           FrequencyOnChange("dry material spread rate"),
				IntValueDescription: "Current set point dry material spread rate in milligrams per meter. Material spreaders don't always report the total amount of material remaining. Spread rates can be used to estimate total material usage. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderSetPointSpreadRatePrewetLitersPerTonne,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current set point prewet material spread rate (L/tonne)",
				Frequency:           FrequencyOnChange("prewet material spread rate"),
				IntValueDescription: "Current set point prewet material spread rate in milligrams per tonne. Spreaders report either the mixture ration of wet to dry material for the spread rate, or the combined amount of material in milliliters per meter. If this stat is not reported, but the actual rate is, it is a limitation of the controller manufacturer. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderSetPointSpreadRatePrewetMillilitersPerMeter,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current set point prewet material spread rate (ml/m)",
				Frequency:           FrequencyOnChange("prewet material spread rate"),
				IntValueDescription: "Current set point prewet material spread rate in milliliters per meter. Spreaders report either the mixture ration of wet to dry material for the spread rate, or the combined amount of material in milliliters per meter. If this stat is not reported, but the actual rate is, it is a limitation of the controller manufacturer. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderSetPointSpreadRateWetMillilitersPerMeter,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags:       []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current set point wet material spread rate (ml/m)",
				Frequency:           FrequencyOnChange("wet material spread rate"),
				IntValueDescription: "Current prewet material spread rate in milliliters per meter. If this stat is not reported, but the actual rate is, it is a limitation of the controller manufacturer. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderSnowThicknessMillimeters,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Snow thickness",
				Frequency:           FrequencyOnChange("snow thickness"),
				IntValueDescription: "Snow film height on the road in millimeters",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderSpreadRateDryGramsPerMeter,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         metadatahelpers.DeprecatedDescription("Current dry material spread rate (g/m)"),
				Frequency:           FrequencyOnChange("dry material spread rate"),
				IntValueDescription: "Current dry material spread rate in grams per meter. For Rexroth/ForceAmerica spreaders, this is the set point spread rate, for Cirus/DickeyJohn, this is the actual spread rate.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderSpreadRateDryMilligramsPerMeter,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current dry material spread rate (mg/m)",
				Frequency:           FrequencyOnChange("dry material spread rate"),
				IntValueDescription: "Current dry material spread rate in milligrams per meter. Material spreaders don't always report the total amount of material remaining. Spread rates can be used to estimate total material usage. For Rexroth/ForceAmerica spreaders, this is the set point spread rate, for Cirus/DickeyJohn, this is the actual spread rate.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderSpreadRatePrewetLitersPerTonne,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current prewet material spread rate (ml/tonne)",
				Frequency:           FrequencyOnChange("prewet material spread rate"),
				IntValueDescription: "Current prewet material spread rate in milliliters per tonne. Spreaders report either the mixture ration of wet to dry material for the spread rate, or the combined amount of material in milliliters per meter. For Rexroth/ForceAmerica spreaders, this is the set point spread rate, for Cirus/DickeyJohn, this is the actual spread rate.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderSpreadRatePrewetMillilitersPerMeter,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current prewet material spread rate (ml/m)",
				Frequency:           FrequencyOnChange("prewet material spread rate"),
				IntValueDescription: "Current prewet material spread rate in milliliters per meter. Spreaders report either the mixture ration of wet to dry material for the spread rate, or the combined amount of material in milliliters per meter. For Rexroth/ForceAmerica spreaders, this is the set point spread rate, for Cirus/DickeyJohn, this is the actual spread rate.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderSpreadRatePrewetPercent,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Percentage of pre-wet material spread",
				Frequency:           FrequencyOnChange("pre-wet material spread"),
				IntValueDescription: "Spread rate in percent",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderSpreadRateWetLitersPerMeter,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         metadatahelpers.DeprecatedDescription("Current wet material spread rate (l/m)"),
				Frequency:           FrequencyOnChange("wet material spread rate"),
				IntValueDescription: "Current wet material spread rate in liters per meter. For Rexroth/ForceAmerica spreaders, this is the set point spread rate, for Cirus/DickeyJohn, this is the actual spread rate.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderSpreadRateWetMillilitersPerMeter,
			DataModelStat: true,
			Kind:          StatKindObjectStat,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current wet material spread rate (ml/m)",
				Frequency:           FrequencyOnChange("wet material spread rate"),
				IntValueDescription: "Current prewet material spread rate in milliliters per meter. For Rexroth/ForceAmerica spreaders, this is the set point spread rate, for Cirus/DickeyJohn, this is the actual spread rate.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current on/off state of the spreader",
				Frequency:           FrequencyOnChange("spreader on/off"),
				IntValueDescription: "The spreaders are attached solely through RS-232. Spreader state ON is detected once we've been able to decode a message buffer from an attached serial device. OFF is set once we stop receving responses to requests (active) or we stop receving data (passive) after some amount of time. OFF is also reported if the VG switches power modes and disables the USB host controller.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderStateActivelySpreading,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Production:    true,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Tags: []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current on/off state of the spreader taking into account dry, wet and prewet spreading rates",
				Frequency:           FrequencyOnChange("spreader on/off taking into account spreader rates"),
				IntValueDescription: "A derivative of osDSaltSpreaderState with value equal ON iff osDSaltSpreaderState.IntValue > 0 && (dry_rate > 0 || wet_rate > 0 || prewet_rate > 0)",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderSurfaceState,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Surface state",
				Frequency:           FrequencyOnChange("surface state"),
				IntValueDescription: metadatahelpers.EnumDescription("Salt spreader surface state. See SaltSpreaderSurfaceState enum in object_stat.proto.", hubproto.SaltSpreaderSurfaceState_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowMajorEvent,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Material spreader blast status detected",
				Frequency:           FrequencyOnChange("material blasting"),
				IntValueDescription: "Number of transitions from blasting material to not blasting material. Notes a heavy increase in usage of material",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowMaterialNameGranular,
			BinaryMessageField: "DiagnosticValue",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "The current name of material type currently in use",
				Frequency:   FrequencyOnChange("material type being used"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_value.string_value": "The name of material currently being spread",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowMaterialNameLiquid,
			BinaryMessageField: "DiagnosticValue",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "The current name of material type currently in use",
				Frequency:   FrequencyOnChange("material type being used"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_value.string_value": "The name of material currently being spread",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowMaterialNamePrewet,
			BinaryMessageField: "DiagnosticValue",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "The current name of material type currently in use",
				Frequency:   FrequencyOnChange("material type being used"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.diagnostic_value.string_value": "The name of material currently being spread",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowQuantitySpreadDryMilligrams,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of dry material remaining (mg)",
				Frequency:           FrequencyOnChange("total dry material changing"),
				IntValueDescription: "A delta between the previous and current amount of total material spread, representing the total amount of material used between two stats",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowQuantitySpreadPrewetMilliliters,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of pre-wet material remaining (ml)",
				Frequency:           FrequencyOnChange("total dry material changing"),
				IntValueDescription: "A delta between the previous and current amount of total material spread, representing the total amount of material used between two stats",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowQuantitySpreadWetMilliliters,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of pre-wet material remaining (ml)",
				Frequency:           FrequencyOnChange("total dry material changing"),
				IntValueDescription: "A delta between the previous and current amount of total material spread, representing the total amount of material used between two stats",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowSetPointSpreadRateDryMilligramsPerMeter,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Current set point dry material spread rate (mg/m)",
				Frequency:           FrequencyOnChange("dry material spread rate"),
				IntValueDescription: "Current set point dry material spread rate in milligrams per meter. Material spreaders don't always report the total amount of material remaining. Spread rates can be used to estimate total material usage. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowSetPointSpreadRatePrewetLitersPerTonne,
			Kind:       StatKindObjectStat,
			Production: false,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Current set point prewet material spread rate (L/tonne)",
				Frequency:           FrequencyOnChange("prewet material spread rate"),
				IntValueDescription: "Current set point prewet material spread rate in milligrams per tonne. Spreaders report either the mixture ration of wet to dry material for the spread rate, or the combined amount of material in milliliters per meter. If this stat is not reported, but the actual rate is, it is a limitation of the controller manufacturer. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDSaltSpreaderTowPlowSetPointSpreadRateWetMillilitersPerMeter,
			Kind:       StatKindObjectStat,
			Production: false,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MaterialSpreaderTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Current set point wet material spread rate (ml/m)",
				Frequency:           FrequencyOnChange("wet material spread rate"),
				IntValueDescription: "Current prewet material spread rate in milliliters per meter. If this stat is not reported, but the actual rate is, it is a limitation of the controller manufacturer. The difference between the set point rate and the actual rate is the amount of error in the system.",
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDSaltSpreaderType,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			Tags:          []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current connected spreader",
				Frequency:           FrequencyOnChange("spreader on/off"),
				IntValueDescription: metadatahelpers.EnumDescription("Type device connected via RS232. This can be a material spreader or an accessory, such as a temperature sensor. This stat is reported once per device detected on the VG.", hubproto.DeviceConfig_SaltSpreaderConfig_SpreaderType_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderWaterThicknessMillimeters,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Water thickness",
				Frequency:           FrequencyOnChange("water thickness"),
				IntValueDescription: "Water film height on the road in millimeters",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderWetSeasonTotal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of wet material spread this season in litres",
				Frequency:           FrequencyOnChange("wet material spread"),
				IntValueDescription: "Total amount of wet material spread this season in litres",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderWetTotal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of wet material spread in litres",
				Frequency:           FrequencyOnChange("wet material spread"),
				IntValueDescription: "Total amount of wet material spread in litres",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSaltSpreaderWetTripTotal,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of wet material spread this trip in litres",
				Frequency:           FrequencyOnChange("wet material spread"),
				IntValueDescription: "Total amount of wet material spread this trip in litres",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSatelliteModemInfo,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "SatelliteModemInfo",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.MaterialSpreaderTag},
			MetadataInfo: &MetadataInfo{
				Description: "Contains information on a currently-connected satellite modem.",
				Frequency:   FrequencyCustom("Reported once on boot or when a modem with a different IMEI is attached."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.satellite_modem_info.manufacturer": metadatahelpers.EnumDescription("Manufacturer of the modem", hubproto.SatelliteModemInfo_Manufacturer_name),
					"value.proto_value.satellite_modem_info.imei":         "IMEI (serial number) of the modem",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSatelliteStatus,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "SatelliteStatus",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Status of satellite connection",
				Frequency:   FrequencyCustom("Periodically based on firmware configuration"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.satellite_status.signal_quality":       "Signal quality (0-5 for Iridium Edge modems)",
					"value.proto_value.satellite_status.signal_quality_valid": "Whether the signal quality field is valid",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSatelliteTransmittedData,
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			BinaryMessageField: "SatelliteTransmittedData",
			MetadataInfo: &MetadataInfo{
				Description: "Contains minimum set of satellite transmitted data for low bandwidth telematic solution when device is not connected to the hubserver.",
				Frequency:   FrequencyCustom("Reported every 5-15 minutes (depending on firmware configuration) when the device is connected via a satellite link."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.satellite_transmitted_data.has_gps_fix":                                   "Whether the device has a gps fix.",
					"value.proto_value.satellite_transmitted_data.latitude":                                      "Angular distance north / south of the equator, in degrees.",
					"value.proto_value.satellite_transmitted_data.longitude":                                     "Angular distance east / west of Greenwich, England, in degrees.",
					"value.proto_value.satellite_transmitted_data.speed_milliknots":                              "Speed in milliknots.",
					"value.proto_value.satellite_transmitted_data.gps_accuracy_millimeters":                      "Accuracy in millimeters.",
					"value.proto_value.satellite_transmitted_data.update_reason":                                 metadatahelpers.EnumDescription("Reason for the message.", hubproto.SatelliteTransmittedData_UpdateReason_name),
					"value.proto_value.satellite_transmitted_data.on_trip":                                       "Indicates firmware trip state.",
					"value.proto_value.satellite_transmitted_data.signal_quality_valid":                          "Inticates if signal quality (CSQ) value is valid.",
					"value.proto_value.satellite_transmitted_data.signal_quality":                                "Signal quality (CSQ) value.",
					"value.proto_value.satellite_transmitted_data.internal_metadata":                             "Optional developer metrics.",
					"value.proto_value.satellite_transmitted_data.internal_metadata.protocol_version":            "Protocol version used by the firmware.",
					"value.proto_value.satellite_transmitted_data.internal_metadata.sequence_num":                "Firmware provided sequence number. Initially to compare against MOMSN",
					"value.proto_value.satellite_transmitted_data.internal_metadata.db_disk_size_mb":             "Firmware log database size in MB.",
					"value.proto_value.satellite_transmitted_data.internal_metadata.transmit_delta_ms":           "Delta in milliseconds between when the device first wanted to transmit a satellite messagte and when a message was successfully transmitted.",
					"value.proto_value.satellite_transmitted_data.internal_metadata.transmit_offset_ms":          "Offset in milliseconds between the timestamp of the data that triggered the message transmit and when the message was transmitted.",
					"value.proto_value.satellite_transmitted_data.internal_metadata.db_num_log_events":           "Number of log events present in the firmware's log database.",
					"value.proto_value.satellite_transmitted_data.internal_metadata.log_db_full_percent":         "Percentage filled of the log database on the device.  Reported in 12.5% increments.",
					"value.proto_value.satellite_transmitted_data.internal_metadata.home_directory_full_percent": "Percentage filled of the home directory on the device.  Reported in 12.5% increments.",
					"value.proto_value.satellite_transmitted_data.iridium_metadata":                              "Iridium's provided message metadata, populated when sent over an Iridium satellite connection.",
					"value.proto_value.satellite_transmitted_data.iridium_metadata.protocol_revision_number":     "Iridium's DirectIP protocol revision number.",
					"value.proto_value.satellite_transmitted_data.iridium_metadata.cdr_reference":                "Call detail record, also known as auto ID. It's a unique identifier for a given message in the Iridium gateway database.",
					"value.proto_value.satellite_transmitted_data.iridium_metadata.imei":                         "The IMEI is the equipment identifier, unique to each Iridium field device, of the IMEI originating the mobile originated message. It is a 15-digit number represented in ASCII format.",
					"value.proto_value.satellite_transmitted_data.iridium_metadata.session_status":               metadatahelpers.EnumDescription("An indication of success of the SBD session between the IMEI and the Iridium gateway associated with the over-the-air payload delivery.", hubproto.SatelliteTransmittedData_IridiumMetadata_SessionStatus_name),
					"value.proto_value.satellite_transmitted_data.iridium_metadata.mom_sequence_number":          "Mobile-originated message sequence number (MOMSN) associated with the SBD session. This value is set by the IMEI and transmitted to the Iridium gateway as part of every SBD session. It is incremented by the IMEI after every successful session.",
					"value.proto_value.satellite_transmitted_data.iridium_metadata.session_timestamp_utc_ms":     "UTC timestamp of the IMEI session between the IMEI and the Iridium Gateway.",
					"value.proto_value.satellite_transmitted_data.iridium_metadata.latitude":                     "Iridium Subscriber Unit's latitude.",
					"value.proto_value.satellite_transmitted_data.iridium_metadata.longitude":                    "Iridium Subscriber Unit's longitude.",
					"value.proto_value.satellite_transmitted_data.iridium_metadata.cep_radius_km":                "Estimate of the Iridium Subscriber Unit's location accuracy in Kilometers.",
					"value.proto_value.satellite_transmitted_data.original_payload":                              "Optional raw message payload send by the firmware. If the message was sent as part of a batch, this field will only be populated for the first message in the batch (message_batch_index=0).",
					"value.proto_value.satellite_transmitted_data.brief_wake":                                    "Whether the message was sent during a brief wake.",
					"value.proto_value.satellite_transmitted_data.different_trip":                                "If true, the current trip should be treated as a separate trip from the previous satellite-reported trip.  In other words, firmware trip state changed from ON -> OFF -> ON since the last message.",
					"value.proto_value.satellite_transmitted_data.has_revgeo":                                    "Whether or not reverse geolocation to get additional data was performed on this datapoint.",
					"value.proto_value.satellite_transmitted_data.revgeo_street":                                 "The street corresponding to the latitude / longitude of this datapoint as determined by reverse geolocation.",
					"value.proto_value.satellite_transmitted_data.revgeo_city":                                   "The city corresponding to the latitude / longitude of this datapoint as determined by reverse geolocation.",
					"value.proto_value.satellite_transmitted_data.revgeo_state":                                  "The state corresponding to the latitude / longitude of this datapoint as determined by reverse geolocation.",
					"value.proto_value.satellite_transmitted_data.revgeo_country":                                "The country corresponding to the latitude / longitude of this datapoint as determined by reverse geolocation.",
					"value.proto_value.satellite_transmitted_data.revgeo_postcode":                               "The postal code corresponding to the latitude / longitude of this datapoint as determined by reverse geolocation.",
					"value.proto_value.satellite_transmitted_data.revgeo_house_number":                           "The house number corresponding to the latitude / longitude of this datapoint as determined by reverse geolocation.",
					"value.proto_value.satellite_transmitted_data.revgeo_poi":                                    "The point of interest corresponding to the latitude / longitude of this datapoint as determined by reverse geolocation.",
					"value.proto_value.satellite_transmitted_data.revgeo_neighborhood":                           "The neighborhood corresponding to the latitude / longitude of this datapoint as determined by reverse geolocation.",
					"value.proto_value.satellite_transmitted_data.boot_message":                                  "If true, the message was the first message sent since the device booted.  Only set when satellite_manager_config.always_send_message_after_boot_enabled is Enabled.",
					"value.proto_value.satellite_transmitted_data.panic_button_rate_limited":                     "If true, the panic button was rate limited.  In this case, only the last press is reported in the current message.",
					"value.proto_value.satellite_transmitted_data.has_ble_sos":                                   "If true, the message contains BLE SOS data.",
					"value.proto_value.satellite_transmitted_data.ble_sos":                                       "Array of BLE SOS data",
					"value.proto_value.satellite_transmitted_data.dtc_metadata":                                  "Metadata populated when sent over a cellular direct-to-cell connection.",
					"value.proto_value.satellite_transmitted_data.dtc_metadata.cellular_mobile_country_code":     "Cellular Mobile Country Code (MCC) of the network the device is connected to at the time of transmit.",
					"value.proto_value.satellite_transmitted_data.dtc_metadata.cellular_mobile_network_code":     "Cellular Mobile Network Code (MNC) of the network the device is connected to at the time of transmit.",
					"value.proto_value.satellite_transmitted_data.dtc_metadata.message_batch_index":              "The 0-indexed position of the message in the batch of messages sent. Identifies a submessage's position in the containing message if sent as part of a batch.",
					"value.proto_value.satellite_transmitted_data.moderate_power_mode":                           "If true, the message was sent in moderate power mode. If both moderate_power_mode and brief_wake are true, the message was sent during a brief wake to moderate power.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDScantoolDetected,
			BinaryMessageField: "ScantoolDetectedInfo",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:            "A scantool was detected on the diagnostic bus",
				Frequency:              FrequencyCustom("When a scantool is detected"),
				IntValueDescription:    "Transmitting address of the detected scantool",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.scantool_detected_info.message_id_detected":                                         "Address used by the scantool that we detected",
					"value.proto_value.scantool_detected_info.scantool_detected_metadata.scantool_coexistence_method":      metadatahelpers.EnumDescription("Method used when scantool was detected", hubproto.ScantoolCoexistenceConfig_ScantoolCoexistenceMethod_name),
					"value.proto_value.scantool_detected_info.scantool_detected_metadata.diagnostics_inactive_duration_ms": "Duration that diagnostic processing is inactive",
					"value.proto_value.scantool_detected_info.scantool_detected_metadata.candidate_message_ids_to_detect":  "Slice of all addresses we were parsing at the same to detect a scantool",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSeatbeltDriver,
			BinaryMessageField: "ActiveLoggerMetadata",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Current driver seatbelt clipped status",
				Frequency:           FrequencyCustom("seatbelt clipped status changes and every minute"),
				IntValueDescription: "Reports the current state of the drivers seatbelt status on a vehicle, with 0 as inactive, 1 as active, and 2 as disconnect. The possible values for this stat are stored on the firmware. There are multiple sources for determining seatbelt status, and if a single source is active, seatbelt is considered active. Inactive means that there are no currently active seatbelt signals. Disconnected means there are no sources to derive seatbelt status from. Reported by both heavy-duty and passenger vehicles. Seatbelt status in passenger vehicles is non-standard.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.active_logger_metadata.version": "Version of the ActiveLogger that generated this object stat.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDServiceStopInfo,
			BinaryMessageField: "ServiceStopInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "The stat contains information about stopping bundle services during reboots.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSetPointTempMilliC,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Set point temperature (mC)",
				Frequency:           FrequencyOnChange("set point temperature"),
				IntValueDescription: "Set point temperature of refridgeration unit. Operator sets the set point of the unit based on goods being carried.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSetPointTempMilliCZone2,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Set point temperature zone 2 (mC)",
				Frequency:           FrequencyOnChange("set point temperature of reefer zone 2"),
				IntValueDescription: "Set point temperature of refridgeration unit zone 2. Operator sets the set point of the unit based on goods being carried.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSetPointTempMilliCZone3,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.ReeferTag,
				amundsentags.TelematicsTag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Set point temperature zone 3 (mC)",
				Frequency:           FrequencyOnChange("set point temperature of reefer zone 3"),
				IntValueDescription: "Set point temperature of refridgeration unit zone 3. Operator sets the set point of the unit based on goods being carried.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSimData,
			BinaryMessageField: "SimData",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "SIM Data for all device SIMs",
				Frequency:   FrequencyEveryXSeconds(24 * 60 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.sim_data.sim_data_entries.sim_slot":                                  metadatahelpers.EnumDescription("SIM slot", hubproto.SimSlot_name),
					"value.proto_value.sim_data.sim_data_entries.iccid":                                     "ICCID value for this SIM",
					"value.proto_value.sim_data.sim_data_entries.service_provider_name":                     "Name of the service provider of this SIM card (AT&T, Vodafone, etc.)",
					"value.proto_value.sim_data.sim_data_entries.euicc_data.eid":                            "Embedded Identity Document (EID) is a unique identifier for the eSIM. Populated when the device has an eUICC (eSIM) present in the specified SIM slot, otherwise NULL",
					"value.proto_value.sim_data.sim_data_entries.euicc_data.profiles.iccid":                 "ICCID value for this eSIM profile",
					"value.proto_value.sim_data.sim_data_entries.euicc_data.profiles.profile_name":          "Name of the eSIM profile given by the service provider",
					"value.proto_value.sim_data.sim_data_entries.euicc_data.profiles.service_provider_name": "Name of the service provider of this eSIM profile",
					"value.proto_value.sim_data.sim_data_entries.euicc_data.profiles.class":                 metadatahelpers.EnumDescription("Describes the intended use and characteristics of the eSIM profile", hubproto.SimData_SimDataEntry_EuiccData_EuiccProfileClass_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSimSwitchReason,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "SimSwitchReason",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Sim Switch Reason",
				Frequency:   FrequencyCustom("a single report per sim switch attempt"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.sim_switch_reason.reason":       metadatahelpers.EnumDescription("SIM switch reason", hubproto.ObjectStatBinaryMessage_SimSwitchReason_SimSwitchReason_name),
					"value.proto_value.sim_switch_reason.new_sim_slot": metadatahelpers.EnumDescription("New SIM slot", hubproto.SimSlot_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSmartCardInfo,
			BinaryMessageField: "SmartCardInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Information read from a smart card",
				Frequency:   FrequencyCustom("Whenever a smart card is inserted or otherwise detected (power on or USB connection)"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.smart_card_info.card_serial_number": "Card serial number",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSmogCheckResults,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "SmogCheckResults",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Smog check results",
				Frequency:   FrequencyCustom("a single report per diagnostic session"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.smog_check_results.comm_protocol":                                      "CAN bus communication protocol. Smog is only for passenger vehicles, and supported bus values are defined in ObjectStatBinaryMessage_SmogCheckResults_CommProtocol. Values in the enum defined typically contains the ECU address length on the bus (11 or 29 bit) and the baud rate of the bus (250k or 500k baud).",
					"value.proto_value.smog_check_results.firmware_number":                                    "Static string version reported from the firmware. Typically of the form CTPv(x).",
					"value.proto_value.smog_check_results.odometer_meters":                                    "Current odometer distance (m). This is filtered on the firmware to assure that the odometer value is monotonically increasing.",
					"value.proto_value.smog_check_results.ecu_smog_info.tx_id":                                "Address of ECU sending sending smog related information.",
					"value.proto_value.smog_check_results.ecu_smog_info.ecu_name":                             "Name of ECU sending smog information. ASCII-coded. Right-padded with null chars (0x00).",
					"value.proto_value.smog_check_results.ecu_smog_info.vin":                                  "Validated VIN of the vehicle. This is equivalent to the information sent in osDVin.",
					"value.proto_value.smog_check_results.ecu_smog_info.cal_id":                               "Calibration ID. Up to 16 ASCII chars. Data bytes not used will be reported as null bytes (0x00). Several CALID can be outputed (16 bytes each).",
					"value.proto_value.smog_check_results.ecu_smog_info.cvn":                                  "Calibration verification numbers (CVN) message count for PID 06. Only for ISO 9141-2, ISO 14230-4 and SAE J1850.",
					"value.proto_value.smog_check_results.ecu_smog_info.engine_rpm":                           "Engine speed.",
					"value.proto_value.smog_check_results.ecu_smog_info.mil_on_dist_km":                       "Distance traveled with malfunction indicator lamp (MIL) on.",
					"value.proto_value.smog_check_results.ecu_smog_info.mil_on_runtime_min":                   "Time run with MIL on.",
					"value.proto_value.smog_check_results.ecu_smog_info.time_since_dtcs_cleared_min":          "Time since trouble codes cleared.",
					"value.proto_value.smog_check_results.ecu_smog_info.dlc_pin_voltage_milliv":               "Control module voltage.",
					"value.proto_value.smog_check_results.ecu_smog_info.dist_since_dtcs_cleared_km":           "Distance traveled since codes cleared.",
					"value.proto_value.smog_check_results.ecu_smog_info.num_warmups_since_dtcs_cleared":       "Warm-ups since codes cleared.",
					"value.proto_value.smog_check_results.ecu_smog_info.ecu_name_valid":                       "True if ecu_name field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.vin_valid":                            "True if vin field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.cal_id_valid":                         "True if cal_id field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.cvn_valid":                            "True if cvn field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.engine_rpm_valid":                     "True if engine_rpm field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.mil_on_dist_km_valid":                 "True if mil_on_dist_km field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.mil_on_runtime_min_valid":             "True if mil_on_runtime_min field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.time_since_dtcs_cleared_min_valid":    "True if time_since_dtcs_cleared_min field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.dlc_pin_voltage_milliv_valid":         "True if dlc_pin_voltage_milliv field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.dist_since_dtcs_cleared_km_valid":     "True if dist_since_dtcs_cleared_km field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.num_warmups_since_dtcs_cleared_valid": "True if num_warmups_since_dtcs_cleared field is valid.",
					"value.proto_value.smog_check_results.ecu_smog_info.supported_pids":                       "List of supported data identifiers seen from an ECU.",
					"value.proto_value.smog_check_results.ecu_smog_info.supported_pids_valid":                 "True if supported_pids field is valid.",
					"value.proto_value.smog_check_results.gateway_serial":                                     "Serial of the Samsara device connected to the vehicle.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSmsReceived,
			BinaryMessageField: "SmsReceived",
			Kind:               StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Received SMS information",
				Frequency:   FrequencyCustom("Reported when an SMS is received by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.sms_received.sent_utc_ms":         "UTC timestamp of when the SMS was sent",
					"value.proto_value.sms_received.payload":             "Text payload sent in SMS (can be empty)",
					"value.proto_value.sms_received.originating_address": "Sender's address",
					"value.proto_value.sms_received.mcc":                 "Mobile Country Code",
					"value.proto_value.sms_received.mnc":                 "Mobile Network Code",
					"value.proto_value.sms_received.cell_id":             "E-UTRAN cell ID",
					"value.proto_value.sms_received.tac":                 "Tracking area code",
					"value.proto_value.sms_received.correlation_id":      "An echo back of a field in the payload. Used to correlate the received SMS with metadata produced by the sending service.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSolarDebug,
			BinaryMessageField: "SolarDebug",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSonySearchAgnss,
			BinaryMessageField: "SonySearchAgnss",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AG52Tag, amundsentags.AssetsTag, amundsentags.MarathonTag, amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Represents AGNSS data used to start - and received by - a search with the Sony CXD56XX family of GNSS Modules.",
				Frequency:   FrequencyCustom("Once per GNSS search, potentially many times per day"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.sony_search_agnss.tcxo_bias_injected_hz":           "TCXO Bias injected to start the search",
					"value.proto_value.sony_search_agnss.temperature_at_injection_millic": "PCB temperature at search start",
					"value.proto_value.sony_search_agnss.lle_injected_expiration_utc_sec": "Expiration (UTC seconds) of LLE injected. 0 if not injected",
					"value.proto_value.sony_search_agnss.location_injected":               "Last known AG location used to start the search, null if no last location was found",
					"value.proto_value.sony_search_agnss.time_to_first_fix_ms":            "TTFF, negative if no fix found in the search",
					"value.proto_value.sony_search_agnss.tcxo_bias_at_first_fix_hz":       "TCXO Bias of the first fix. Invalid if ttff_sec is negative",
					"value.proto_value.sony_search_agnss.temperature_at_first_fix_millic": "PCB temperature at the time of the first fix. Invalid if ttff_sec is negative",
					"value.proto_value.sony_search_agnss.location_at_first_fix":           "Location data of the first fix. Invalid if ttff_sec is negative",
					"value.proto_value.sony_search_agnss.accuracy_at_first_fix_mm":        "Reported estimated accuracy of the first fix. Invalid if ttff_sec is negative",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSozeEngineImmobilizerConnected,
			BinaryMessageField: "SozeEngineImmobilizerConnected",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Logs Soze Engine Immobilizer's connection status",
				Frequency:   FrequencyOnChange("Reported each time when USB turns on or off"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.soze_engine_immobilizer_connected.connected":        metadatahelpers.EnumDescription("Is the Soze connected", hubproto.SozeConnected_name),
					"value.proto_value.soze_engine_immobilizer_connected.firmware_version": "Soze firmware version",
					"value.proto_value.soze_engine_immobilizer_connected.serial":           "Soze serial number",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSozeEngineImmobilizerRegionStatus,
			BinaryMessageField: "SozeEngineImmobilizerRegionStatus",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Logs changes to the Soze Engine Immobilizer's region-based safety decision",
				Frequency:   FrequencyOnChange("Up to 1 per configured time period, depending on vehicle conditions"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.soze_engine_immobilizer_region_status.latitude_nd":                        "GPS Latitude for the current region status, in nanodegrees",
					"value.proto_value.soze_engine_immobilizer_region_status.longitude_nd":                       "GPS Longitude for the current region status, in nanodegrees",
					"value.proto_value.soze_engine_immobilizer_region_status.mcc":                                "Current cellular Mobile Country Code (MCC)",
					"value.proto_value.soze_engine_immobilizer_region_status.mcc_state":                          metadatahelpers.EnumDescription("State of the Mobile Country Code (MCC) region lock", hubproto.SozeEngineImmobilizerRegionStatus_SozeMccState_name),
					"value.proto_value.soze_engine_immobilizer_region_status.geo_lock_state":                     metadatahelpers.EnumDescription("State of the Geo-lock region lock", hubproto.SozeEngineImmobilizerRegionStatus_SozeGeoLockState_name),
					"value.proto_value.soze_engine_immobilizer_region_status.time_since_last_gps_fix_ms":         "Time since the last reported GPS fix in milliseconds",
					"value.proto_value.soze_engine_immobilizer_region_status.gps_last_fix_accuracy_mm":           "Accuracy of the last-reported GPS fix in millimeters",
					"value.proto_value.soze_engine_immobilizer_region_status.region_status_reason":               metadatahelpers.EnumDescription("The reason for the region lock decision", hubproto.SozeEngineImmobilizerRegionStatus_SozeRegionStatusReason_name),
					"value.proto_value.soze_engine_immobilizer_region_status.region_auto_immobilization_allowed": "Whether or not auto-immobilization is allowed for the current region",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSozeEngineImmobilizerStatus,
			BinaryMessageField: "SozeEngineImmobilizerStatus",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Logs inputs and outputs for the Soze Engine Immobilizer and its jamming and safety systems",
				Frequency:   FrequencyOnChange("Up to 1 every 10s, depending on vehicle conditions"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.soze_engine_immobilizer_status.immobilizer_connected":                    metadatahelpers.EnumDescription("Is the Soze connected", hubproto.SozeConnected_name),
					"value.proto_value.soze_engine_immobilizer_status.relay_1":                                  "State information for ignition relay",
					"value.proto_value.soze_engine_immobilizer_status.relay_1.desired_state_without_safety":     metadatahelpers.EnumDescription("State desired if safety were not a factor", hubproto.SozeRelayState_name),
					"value.proto_value.soze_engine_immobilizer_status.relay_1.last_open_nonce":                  "One-time number needed to clear the last immobilization",
					"value.proto_value.soze_engine_immobilizer_status.relay_1.read_state":                       metadatahelpers.EnumDescription("State of relay prior to making any new decisions", hubproto.SozeRelayState_name),
					"value.proto_value.soze_engine_immobilizer_status.relay_1.set_state":                        metadatahelpers.EnumDescription("Decided relay state sent to Soze", hubproto.SozeRelayState_name),
					"value.proto_value.soze_engine_immobilizer_status.relay_1.state_change_reason":              metadatahelpers.EnumDescription("Reason for state change", hubproto.SozeEngineImmobilizerStatus_SozeRelayStatus_StateChangeReason_name),
					"value.proto_value.soze_engine_immobilizer_status.relay_2":                                  "State information for accelerator relay",
					"value.proto_value.soze_engine_immobilizer_status.relay_2.desired_state_without_safety":     metadatahelpers.EnumDescription("State desired if safety were not a factor", hubproto.SozeRelayState_name),
					"value.proto_value.soze_engine_immobilizer_status.relay_2.last_open_nonce":                  "One-time number needed to clear the last immobilization",
					"value.proto_value.soze_engine_immobilizer_status.relay_2.read_state":                       metadatahelpers.EnumDescription("State of relay prior to making any new decisions", hubproto.SozeRelayState_name),
					"value.proto_value.soze_engine_immobilizer_status.relay_2.set_state":                        metadatahelpers.EnumDescription("Decided relay state sent to Soze", hubproto.SozeRelayState_name),
					"value.proto_value.soze_engine_immobilizer_status.relay_2.state_change_reason":              metadatahelpers.EnumDescription("Reason for state change", hubproto.SozeEngineImmobilizerStatus_SozeRelayStatus_StateChangeReason_name),
					"value.proto_value.soze_engine_immobilizer_status.safety_information":                       "State info for safety decision system",
					"value.proto_value.soze_engine_immobilizer_status.safety_information.ecu_speed_kmph":        "ECU speed km/h",
					"value.proto_value.soze_engine_immobilizer_status.safety_information.engine_running":        metadatahelpers.EnumDescription("Engine state", hubproto.SozeEngineImmobilizerStatus_SozeSafetyInformation_EngineState_name),
					"value.proto_value.soze_engine_immobilizer_status.safety_information.gps_speed_kmph":        "GPS speed km/h",
					"value.proto_value.soze_engine_immobilizer_status.safety_information.safety_threshold_kmph": "Safety threshold speed km/h",
					"value.proto_value.soze_engine_immobilizer_status.safety_information.safe_to_immobilize":    metadatahelpers.EnumDescription("Safety system decision", hubproto.SozeEngineImmobilizerStatus_SozeSafetyInformation_SafetyDecision_name),
					"value.proto_value.soze_engine_immobilizer_status.tamper_state":                             metadatahelpers.EnumDescription("Tamper sensor state", hubproto.SozeEngineImmobilizerStatus_TamperState_name),
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSpeedLimitSignDetected,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDStopSignDetection,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDStorageMetrics,
			BinaryMessageField:       "StorageMetrics",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			MetadataInfo: &MetadataInfo{
				Description: "Regularly reports storage details for gateways with HDDs.",
				Frequency:   FrequencyCustom("On boot, or oncee a day"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.storage_metrics.storage_device":                                                  "An array of storage metrics, one for each disk.",
					"value.proto_value.storage_metrics.storage_device.model":                                            "The model of the disk.",
					"value.proto_value.storage_metrics.storage_device.serial":                                           "The serial of the disk.",
					"value.proto_value.storage_metrics.storage_device.total_bytes":                                      "The unformatted gross capacity of the disk (eg. 15873650294784 bytes for a 16TB drive).",
					"value.proto_value.storage_metrics.storage_device.free_bytes":                                       "The number of unallocated bytes available for use on the disk.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes":                                 "A struct detailing various S.M.A.R.T. attributes of the disk. See https://en.wikipedia.org/wiki/S.M.A.R.T.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.valid_stats_bitmap":              "Bitmap of which attributes are reported, i.e. if the 2nd bit is set, then reallocated_sector_count is valid. See ValidSmartAttributes to see which bit maps to which value.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.reallocated_sector_count":        "Count of reallocated sectors. The raw value represents a count of the bad sectors that have been found and remapped. This value is primarily used as a metric of the life expectancy of the drive; a drive which has had any reallocations at all is significantly more likely to fail in the immediate months",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.power_on_hours":                  "Count of hours in power-on state.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.power_cycle_count":               "Count of full hard disk power on/off cycles.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.wear_leveling_count":             "Counts the maximum worst erase count on any block.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.used_reserved_block_count_total": "'Pre-Fail' attribute used at least in Samsung devices.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.program_fail_count_total":        "Total number of Flash program operation failures since the drive was deployed.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.erase_fail_count_total":          "'Pre-Fail' attribute used at least in Samsung devices.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.runtime_bad_block":               "The total number of data blocks with detected, uncorrectable errors encountered during normal operation.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.uncorrectable_error_count":       "The count of errors that could not be recovered using hardware ECC.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.airflow_temperature_degree_c":    "Value is equal to (100-temp. C), allowing manufacturer to set a minimum threshold which corresponds to a maximum temperature. This also follows the convention of 100 being a best-case value and lower values being undesirable. However, some older drives may instead report raw Temperature (identical to 0xC2) or Temperature minus 50 here.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.ecc_error_rate":                  "ECC error rate.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.por_recovery_count":              "Recovery count.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.total_lbas_read":                 "Total count of LBAs read.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.total_lbas_written":              "Total count of LBAs written.",
					"value.proto_value.storage_metrics.storage_device.smart_attributes.temperature_degree_c":            "Indicates the device temperature, if the appropriate sensor is fitted. Lowest byte of the raw value contains the exact temperature value (Celsius degrees).",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSuddenFuelDropEvent,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "SuddenFuelDropEvent",
			MetadataInfo: &MetadataInfo{
				Description: "Indicates sudden fuel drop. May indicate fuel theft or fuel leak. Emitted based on data from kinesisstats.osDEcuFuelLevelMillipercent. " +
					"Each event is derived from multiple data points and is not guaranteed to be accurate, as data is noisy. " +
					"The confidence level is provided to indicate the event's reliability.",
				Frequency: FrequencyCustom("When sudden fuel drop is detected"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.sudden_fuel_drop_event.event_id":                       "Value that combined with the device ID uniquely identifies the event",
					"value.proto_value.sudden_fuel_drop_event.change_start_ms":                "Timestamp of the start of the event",
					"value.proto_value.sudden_fuel_drop_event.change_end_ms":                  "Timestamp of the end of thee event",
					"value.proto_value.sudden_fuel_drop_event.fuel_level_before_millipercent": "Fuel level before the event",
					"value.proto_value.sudden_fuel_drop_event.fuel_level_after_millipercent":  "Fuel level after the event",
					"value.proto_value.sudden_fuel_drop_event.confidence_level_millipercent":  "Confidence level which indicates how likely the event is to be accurate",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSuddenFuelRiseEvent,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "SuddenFuelRiseEvent",
			MetadataInfo: &MetadataInfo{
				Description: "Indicates sudden fuel rise.. Emitted based on data from kinesisstats.osDEcuFuelLevelMillipercent. " +
					"Each event is derived from multiple data points and is not guaranteed to be accurate, as data is noisy. " +
					"The confidence level is provided to indicate the event's reliability.",
				Frequency: FrequencyCustom("When sudden fuel rise is detected"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.sudden_fuel_rise_event.event_id":                       "Value that combined with the device ID uniquely identifies the event",
					"value.proto_value.sudden_fuel_rise_event.change_start_ms":                "Timestamp of the start of the event",
					"value.proto_value.sudden_fuel_rise_event.change_end_ms":                  "Timestamp of the end of thee event",
					"value.proto_value.sudden_fuel_rise_event.fuel_level_before_millipercent": "Fuel level before the event",
					"value.proto_value.sudden_fuel_rise_event.fuel_level_after_millipercent":  "Fuel level after the event",
					"value.proto_value.sudden_fuel_rise_event.confidence_level_millipercent":  "Confidence level which indicates how likely the event is to be accurate",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSupplementaryLocation,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			BinaryMessageField: "SupplementaryLocation",
			MetadataInfo: &MetadataInfo{
				Description: "Supplementary location",
				Frequency:   FrequencyCustom("Reported when DeviceLocation is reported"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.supplementary_location.has_fix":               "Whether a supplementary location was available.",
					"value.proto_value.supplementary_location.latitude_nanodegrees":  "Latitude in nanodegrees.",
					"value.proto_value.supplementary_location.longitude_nanodegrees": "Longitude in nanodegrees.",
					"value.proto_value.supplementary_location.altitude_millimeters":  "Altitude in millimeters.",
					"value.proto_value.supplementary_location.accuracy_millimeters":  "Accuracy in millimeters.",
					"value.proto_value.supplementary_location.speed_milliknots":      "Speed in milliknots.",
					"value.proto_value.supplementary_location.heading_millidegrees":  "Heading in millidegrees.",
					"value.proto_value.supplementary_location.timestamp_utc_ms":      "UTC timestamp of the fix.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDSupraConnected,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "SupraConnected",
			MetadataInfo: &MetadataInfo{
				Description: "Supra cable connect event",
				Frequency:   FrequencyOnChange("when a supra cable gets connected through USB"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.supra_connected.serial_number":    "Serial number of the connected supra cable.",
					"value.proto_value.supra_connected.firmware_version": "Firmware version running on the connected Supra cable. The firmware versions are maintained by the firmware team.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSyntheticEngineRuntimeSeconds,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "The synthetic engine seconds reported by the VG.",
				Frequency:           FrequencyCustom("Every time the VG synthetic engine seconds threshold is exceeded and on shutdown."),
				IntValueDescription: "The synthetic engine seconds reported by the VG.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDSyntheticOdometerMeters,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "The synthetic odometer meters reported by the VG.",
				Frequency:           FrequencyCustom("Every time the VG relative distance travelled threshold is exceeded and on shutdown."),
				IntValueDescription: "The synthetic odometer meters reported by the VG.",
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDSystemStats,
			BinaryMessageField:       "SystemStats",
			Kind:                     StatKindObjectStat,
			DataModelStat:            true,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(16),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTachographAuthenticationStatus,
			BinaryMessageField: "TachographAuthenticationStatus",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Authentication status of the tachograph",
				Frequency:   FrequencyOnChange("when the tachograph is authenticated"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.tachograph_authentication_status.is_authenticated":  "Whether the tachograph is authenticated",
					"value.proto_value.tachograph_authentication_status.using_locked_card": "Whether the tachograph has been authenticated using a locked card",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTachographCompanyCardInfo,
			BinaryMessageField: "TachographCompanyCardInfo",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Information read from a Tachograph Company Card",
				Frequency:   FrequencyOnChange("The first time a company card is read as part of the authentication flow"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.tachograph_company_card_info.card_number":               "Card number of the company card",
					"value.proto_value.tachograph_company_card_info.issuing_authority_name":    "Name of the authority that issued the card",
					"value.proto_value.tachograph_company_card_info.company_name":              "Name of the company the card was issued to",
					"value.proto_value.tachograph_company_card_info.issue_date_epoch_seconds":  "Date when the card was issued, in seconds since 1970-01-01 00:00:00",
					"value.proto_value.tachograph_company_card_info.valid_from_epoch_seconds":  "Date the card is valid from, in seconds since 1970-01-01 00:00:00",
					"value.proto_value.tachograph_company_card_info.expiry_date_epoch_seconds": "Date the card expires, in seconds since 1970-01-01 00:00:00",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTachographCompanyCardLock,
			BinaryMessageField: "TachographCompanyCardLock",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Information about the lock status of a Tachograph Company Card read from the tachograph overview",
				Frequency:   FrequencyOnChange("Everytime the tachograph overview is read"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.tachograph_company_card_lock.card_number": "Card number of the company card",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTachographDiscoveryInfo,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "TachographDiscoveryInfo",
			MetadataInfo: &MetadataInfo{
				Description: "Information about the discovery of a tachograph",
				Frequency:   FrequencyOnChange("when a tachograph is discovered"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.tachograph_discovery_info.is_found":  "Whether the tachograph is found",
					"value.proto_value.tachograph_discovery_info.interface": "Interface on which the tachograph is discovered",
					"value.proto_value.tachograph_discovery_info.baudrate":  "Baudrate of the tachograph",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTachographDownloadError,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "TachographDownloadError",
			DataModelStat:      true,
			MetadataInfo: &MetadataInfo{
				Description: "Reports an error status when attempting to download a tachograph file from a tachograph attached to the device. An erro message doesn't mean that the download has failed, but just an error in the process. The download result field will give the result of the download request",
				Frequency:   FrequencyOnChange("when an attempted tachograph driver or vehicle file download fails"),
				ColumnDescriptions: map[string]string{
					"object_id":  "Device ID of the device on which the download error happened",
					"value.time": "Timestamp of the objectstat",
					"value.proto_value.tachograph_download_error.error_text":            "Error Text",
					"value.proto_value.tachograph_download_error.can_interface":         "CAN interface on which the error was detected",
					"value.proto_value.tachograph_download_error.error_code":            "Error Code",
					"value.proto_value.tachograph_download_error.download_stage":        "Download stage at which the download failed",
					"value.proto_value.tachograph_download_error.sent_sid":              "Sent service ID",
					"value.proto_value.tachograph_download_error.received_sid":          "Received service ID",
					"value.proto_value.tachograph_download_error.response_code":         "Response Code",
					"value.proto_value.tachograph_download_error.download_trigger":      "Who did trigger the download",
					"value.proto_value.tachograph_download_error.download_result":       "Result of the tachograph download",
					"value.proto_value.tachograph_download_error.smart_card_gateway_id": "SmartCardGatewayId used to authenticathe the tachograph download",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTachographDriverInfo,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "TachographDriverInfo",
			MetadataInfo: &MetadataInfo{
				Description: "Tachograph driver file binary data",
				Frequency:   FrequencyOnChange("when a new trip is started"),
				ColumnDescriptions: map[string]string{
					"object_id":  "Device ID of the device from which the driver file download happens",
					"value.time": "Timestamp of the objectstat",
					"value.proto_value.tachograph_driver_info.issuing_country": "Country in which the driver card was issued",
					"value.proto_value.tachograph_driver_info.card_number":     "Card number of the driver card",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTachographDriverState,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "TachographDriverState",
			MetadataInfo: &MetadataInfo{
				Description: "Working state changes for driver 1 & driver 2 according to the tachograph vehicle unit",
				Frequency:   FrequencyOnChange("when a driver's working state changes or every minute if a) no state changes happen, b) the engine is on and c) at least one driver card is inserted"),
				ColumnDescriptions: map[string]string{
					"object_id":  "Device ID of the device reporting the tachograph driver state data",
					"value.time": "Timestamp of the objectstat",
					"value.proto_value.tachograph_driver_state.driver_1.working_state":                                                          "Working state enum (e.g. REST, WORK, DRIVE)",
					"value.proto_value.tachograph_driver_state.driver_1.card_number":                                                            "Card number of the driver card",
					"value.proto_value.tachograph_driver_state.driver_1.issuing_country":                                                        "Country in which the driver card was issued",
					"value.proto_value.tachograph_driver_state.driver_1.card_ejected":                                                           "Whether the card was ejected",
					"value.proto_value.tachograph_driver_state.driver_1.time_related_state":                                                     "Time related state indicating if a driver approaches or exceeds working time limits",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.is_reported":                                         "Whether driving rest times are reported - not all tachographs support this data",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.remaining_current_driving_time_minute":               "Remaining current driving time in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.remaining_time_until_next_break_or_rest_minute":      "Remaining time until next break or rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.duration_of_next_break_rest_minute":                  "Duration of next break or rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.remaining_time_of_current_break_rest_minute":         "Remaining time of current break or rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.time_left_until_next_driving_period_minute":          "Time left until next driving period in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.duration_of_next_driving_period_minute":              "Duration of next driving period in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.current_daily_driving_time_minute":                   "Current daily driving time in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.time_left_until_new_daily_rest_period_minute":        "Time left until new daily rest period required in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.minimum_daily_rest_minute":                           "Minimum daily rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.remaining_driving_time_of_current_week_minute":       "Remaining driving time in current week in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.time_left_until_new_weekly_rest_period_minute":       "Time left until new weekly rest period in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.minimum_weekly_rest_minute":                          "Minimum weekly rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.open_compensation_in_the_last_week_minute":           "Open compensation in the last week in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.open_compensation_in_week_before_last_minute":        "Open compensation in week before last in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.open_compensation_in_second_week_before_last_minute": "Open compensation in second week before last in minutes",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.end_of_last_daily_rest_period":                       "End of the last daily rest period of driver 1, as computed by the tachograph using driver 1 card data.",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.maximum_daily_driving_time_minute":                   "Maximum daily driving time for driver 1.",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.number_of_times_9h_daily_driving_times_exceeded":     "Number of times the driver exceeded 9h daily driving time in the current week.",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.number_of_used_reduced_daily_rest_periods":           "Number of the reduced daily rest periods since previous weekly rest period for driver 1.",
					"value.proto_value.tachograph_driver_state.driver_1.driving_rest_times.remaining_2_weeks_driving_time":                      "Set to the maximum remaining driving time left of current week and next week for driver 1.",
					"value.proto_value.tachograph_driver_state.driver_2.working_state":                                                          "Working state enum (e.g. REST, WORK, DRIVE)",
					"value.proto_value.tachograph_driver_state.driver_2.card_number":                                                            "Card number of the driver card",
					"value.proto_value.tachograph_driver_state.driver_2.issuing_country":                                                        "Country in which the driver card was issued",
					"value.proto_value.tachograph_driver_state.driver_2.card_ejected":                                                           "Whether the card was ejected",
					"value.proto_value.tachograph_driver_state.driver_2.time_related_state":                                                     "Time related state indicating if a driver approaches or exceeds working time limits",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.is_reported":                                         "Whether driving rest times are reported - not all tachographs support this data",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.remaining_current_driving_time_minute":               "Remaining current driving time in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.remaining_time_until_next_break_or_rest_minute":      "Remaining time until next break or rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.duration_of_next_break_rest_minute":                  "Duration of next break or rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.remaining_time_of_current_break_rest_minute":         "Remaining time of current break or rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.time_left_until_next_driving_period_minute":          "Time left until next driving period in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.duration_of_next_driving_period_minute":              "Duration of next driving period in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.current_daily_driving_time_minute":                   "Current daily driving time in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.time_left_until_new_daily_rest_period_minute":        "Time left until new daily rest period required in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.minimum_daily_rest_minute":                           "Minimum daily rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.remaining_driving_time_of_current_week_minute":       "Remaining driving time in current week in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.time_left_until_new_weekly_rest_period_minute":       "Time left until new weekly rest period in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.minimum_weekly_rest_minute":                          "Minimum weekly rest in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.open_compensation_in_the_last_week_minute":           "Open compensation in the last week in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.open_compensation_in_week_before_last_minute":        "Open compensation in week before last in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.open_compensation_in_second_week_before_last_minute": "Open compensation in second week before last in minutes",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.end_of_last_daily_rest_period":                       "End of the last daily rest period of driver 2, as computed by the tachograph using driver 2 card data.",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.maximum_daily_driving_time_minute":                   "Maximum daily driving time for driver 2.",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.number_of_times_9h_daily_driving_times_exceeded":     "Number of times the driver exceeded 9h daily driving time in the current week.",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.number_of_used_reduced_daily_rest_periods":           "Number of the reduced daily rest periods since previous weekly rest period for driver 2.",
					"value.proto_value.tachograph_driver_state.driver_2.driving_rest_times.remaining_2_weeks_driving_time":                      "Set to the maximum remaining driving time left of current week and next week for driver 2.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTachographMetadata,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "TachographMetadata",
			MetadataInfo: &MetadataInfo{
				Description: "Report the tachograph settings and cards info",
				Frequency:   FrequencyOnChange("when a tachograph download is triggered"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.tachograph_metadata.supplier_id_valid":                                                                "check validity Supplier id",
					"value.proto_value.tachograph_metadata.supplier_id":                                                                      "Supplier id, tachograph brand",
					"value.proto_value.tachograph_metadata.part_number_valid":                                                                "Check validity of part number",
					"value.proto_value.tachograph_metadata.part_number":                                                                      "Part number",
					"value.proto_value.tachograph_metadata.card_writing_enabled_valid":                                                       "Check if the card writing setting is valid",
					"value.proto_value.tachograph_metadata.card_writing_enabled":                                                             "Check if the card writing is enabled",
					"value.proto_value.tachograph_metadata.rdl_can_a_enabled_valid":                                                          "Check if the tachograph setting remote download on can A is valid",
					"value.proto_value.tachograph_metadata.rdl_can_a_enabled":                                                                "Check if the tachograph remote download is enabled on can A",
					"value.proto_value.tachograph_metadata.rdl_can_c_enabled_valid":                                                          "Check if the tachograph setting remote download on can C is valid",
					"value.proto_value.tachograph_metadata.rdl_can_c_enabled":                                                                "Check if the tachograph remote download is enabled on can C",
					"value.proto_value.tachograph_metadata.tachograph_vehicle_registration":                                                  "Vehicle registration set in the tachograph",
					"value.proto_value.tachograph_metadata.card_id_slot_1":                                                                   "Card id of the card inserted in slot 1 of the tachograph",
					"value.proto_value.tachograph_metadata.card_type_slot_1":                                                                 "Card type of the card inserted in slot 1 of the tachograph",
					"value.proto_value.tachograph_metadata.card_id_slot_2":                                                                   "Card id of the card inserted in slot 2 of the tachograph",
					"value.proto_value.tachograph_metadata.card_type_slot_2":                                                                 "Card type of the card inserted in slot 2 of the tachograph",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.remaining_current_driving_time_minute_valid":               "Check if the remaining current driving time of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.remaining_current_driving_time_minute":                     "Remaining current driving time of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.remaining_time_until_next_break_or_rest_minute_valid":      "Check if the remaining time until the next break or rest of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.remaining_time_until_next_break_or_rest_minute":            "Remaining time until the next break or rest of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.duration_of_next_break_rest_minute_valid":                  "Check if the duration of the next break or rest of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.duration_of_next_break_rest_minute":                        "Duration of the next break or rest of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.remaining_time_of_current_break_rest_minute_valid":         "Check if the remaining time of the current break or rest of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.remaining_time_of_current_break_rest_minute":               "Remaining time of the current break or rest of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.time_left_until_next_driving_period_minute_valid":          "Check if the time left until the next driving period of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.time_left_until_next_driving_period_minute":                "Time left until the next driving period of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.duration_of_next_driving_period_minute_valid":              "Check if the duration of the next driving period of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.duration_of_next_driving_period_minute":                    "Duration of the next driving period of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.current_daily_driving_time_minute_valid":                   "Check if the current daily driving time of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.current_daily_driving_time_minute":                         "Current daily driving time of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.time_left_until_new_daily_rest_period_minute_valid":        "Check if the time left until the new daily rest period of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.time_left_until_new_daily_rest_period_minute":              "Time left until the new daily rest period of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.minimum_daily_rest_minute_valid":                           "Check if the minimum daily rest of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.minimum_daily_rest_minute":                                 "Minimum daily rest of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.remaining_driving_time_of_current_week_minute_valid":       "Check if the remaining driving time of the current week of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.remaining_driving_time_of_current_week_minute":             "Remaining driving time of the current week of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.time_left_until_new_weekly_rest_period_minute_valid":       "Check if the time left until the new weekly rest period of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.time_left_until_new_weekly_rest_period_minute":             "Time left until the new weekly rest period of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.minimum_weekly_rest_minute_valid":                          "Check if the minimum weekly rest of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.minimum_weekly_rest_minute":                                "Minimum weekly rest of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.open_compensation_in_the_last_week_minute_valid":           "Check if the open compensation in the last week of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.open_compensation_in_the_last_week_minute":                 "Open compensation in the last week of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.open_compensation_in_week_before_last_minute_valid":        "Check if the open compensation in the week before last of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.open_compensation_in_week_before_last_minute":              "Open compensation in the week before last of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.open_compensation_in_second_week_before_last_minute_valid": "Check if the open compensation in the second week before last of driver 1 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.open_compensation_in_second_week_before_last_minute":       "Open compensation in the second week before last of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.end_of_last_daily_rest_period":                             "End of the last daily rest period of driver 1, as computed by the tachograph using driver 1 card data.",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.maximum_daily_driving_time_minute":                         "Maximum daily driving time for driver 1.",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.number_of_times_9h_daily_driving_times_exceeded":           "Number of times the driver exceeded 9h daily driving time in the current week.",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.number_of_used_reduced_daily_rest_periods":                 "Number of the reduced daily rest periods since previous weekly rest period for driver 1.",
					"value.proto_value.tachograph_metadata.uds_driver_1_rest_time.remaining_2_weeks_driving_time":                            "Set to the maximum remaining driving time left of current week and next week for driver 1.",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.remaining_current_driving_time_minute_valid":               "Check if the remaining current driving time of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.remaining_current_driving_time_minute":                     "Remaining current driving time of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.remaining_time_until_next_break_or_rest_minute_valid":      "Check if the remaining time until the next break or rest of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.remaining_time_until_next_break_or_rest_minute":            "Remaining time until the next break or rest of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.duration_of_next_break_rest_minute_valid":                  "Check if the duration of the next break or rest of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.duration_of_next_break_rest_minute":                        "Duration of the next break or rest of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.remaining_time_of_current_break_rest_minute_valid":         "Check if the remaining time of the current break or rest of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.remaining_time_of_current_break_rest_minute":               "Remaining time of the current break or rest of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.time_left_until_next_driving_period_minute_valid":          "Check if the time left until the next driving period of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.time_left_until_next_driving_period_minute":                "Time left until the next driving period of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.duration_of_next_driving_period_minute_valid":              "Check if the duration of the next driving period of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.duration_of_next_driving_period_minute":                    "Duration of the next driving period of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.current_daily_driving_time_minute_valid":                   "Check if the current daily driving time of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.current_daily_driving_time_minute":                         "Current daily driving time of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.time_left_until_new_daily_rest_period_minute_valid":        "Check if the time left until the new daily rest period of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.time_left_until_new_daily_rest_period_minute":              "Time left until the new daily rest period of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.minimum_daily_rest_minute_valid":                           "Check if the minimum daily rest of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.minimum_daily_rest_minute":                                 "Minimum daily rest of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.remaining_driving_time_of_current_week_minute_valid":       "Check if the remaining driving time of the current week of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.remaining_driving_time_of_current_week_minute":             "Remaining driving time of the current week of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.time_left_until_new_weekly_rest_period_minute_valid":       "Check if the time left until the new weekly rest period of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.time_left_until_new_weekly_rest_period_minute":             "Time left until the new weekly rest period of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.minimum_weekly_rest_minute_valid":                          "Check if the minimum weekly rest of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.minimum_weekly_rest_minute":                                "Minimum weekly rest of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.open_compensation_in_the_last_week_minute_valid":           "Check if the open compensation in the last week of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.open_compensation_in_the_last_week_minute":                 "Open compensation in the last week of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.open_compensation_in_week_before_last_minute_valid":        "Check if the open compensation in the week before last of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.open_compensation_in_week_before_last_minute":              "Open compensation in the week before last of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.open_compensation_in_second_week_before_last_minute_valid": "Check if the open compensation in the second week before last of driver 2 is valid",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.open_compensation_in_second_week_before_last_minute":       "Open compensation in the second week before last of driver 2",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.end_of_last_daily_rest_period":                             "End of the last daily rest period of driver 1, as computed by the tachograph using driver 1 card data.",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.maximum_daily_driving_time_minute":                         "Maximum daily driving time for driver 1.",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.number_of_times_9h_daily_driving_times_exceeded":           "Number of times the driver exceeded 9h daily driving time in the current week.",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.number_of_used_reduced_daily_rest_periods":                 "Number of the reduced daily rest periods since previous weekly rest period for driver 1.",
					"value.proto_value.tachograph_metadata.uds_driver_2_rest_time.remaining_2_weeks_driving_time":                            "Set to the maximum remaining driving time left of current week and next week for driver 1.",
					"value.proto_value.tachograph_metadata.uds_driver_1_working_state":                                                       "Working state of driver 1",
					"value.proto_value.tachograph_metadata.uds_driver_2_working_state":                                                       "Working state of driver 2",
					"value.proto_value.tachograph_metadata.uds_tachograph_time_date_valid":                                                   "Check if the tachograph time date is valid",
					"value.proto_value.tachograph_metadata.uds_tachograph_time_date.tachograph_timestamp_unix_secs":                          "Timestamp of the tachograph",
					"value.proto_value.tachograph_metadata.uds_tachograph_time_date.tachograph_local_offset_secs":                            "Local offset of the tachograph",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTachographThirdPartyDetection,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "TachographThirdPartyDetection",
			MetadataInfo: &MetadataInfo{
				Description: "Third party detection of the tachograph",
				Frequency:   FrequencyOnChange("when a third party device is detected"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.tachograph_third_party_detection.is_detected": "Whether the third party detection is detected",
				},
			},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDTachographVUDownload,
			Kind:                 StatKindObjectStat,
			BinaryMessageField:   "TachographVuDownload",
			S3BinaryMessageField: "TachographVuDownload",
			DataModelStat:        true,
			MetadataInfo: &MetadataInfo{
				Description: "Provides a copy of the binary data of the vehicle file between two dates",
				Frequency:   FrequencyOnChange("Normally once per week, can be forced if required"),
				ColumnDescriptions: map[string]string{
					"object_id":  "Device ID of the device from which the vehicle file download happens",
					"value.time": "Timestamp of the objectstat",
					"value.proto_value.tachograph_vu_download.license_plate":        "License plate",
					"value.proto_value.tachograph_vu_download.start_date_unix_secs": "Start date in unix timestamp",
					"value.proto_value.tachograph_vu_download.end_date_unix_secs":   "End date in unix timestamp",
					"value.proto_value.tachograph_vu_download.generation":           "Tachograph generation (1 or 2)",
					"value.proto_value.tachograph_vu_download.manufacturer_name":    "Tachograph manufacturer name",
					"value.proto_value.tachograph_vu_download.part_number":          "Tachograph part number",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDThermalLimiterState,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "ThermalLimiterOverheatedSensors",
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDThunderbirdExpectedSleepDurationMs,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDThunderbirdWakeReason,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDTileDiskUsage, // deprecated, switch to osDTileDiskUsageV2
			BinaryMessageField:       "TileDiskUsage",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			MetadataInfo: &MetadataInfo{
				Description: metadatahelpers.DeprecatedDescription("Please use osDTileDiskUsageV2"),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTileDiskUsageV2,
			BinaryMessageField: "TileDiskUsage",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "Reports tiling cache information. SessionStats tracks counts since last log. A session ends whenever the speedlimit service stops, or one of TileVersion, TilesCacheKey, OverridesCacheKey, BridgeLocationVersion, or BridgeLocationCacheKey change",
				Frequency:   FrequencyCustom("When a field changes value, rate limited to at most every 10 minutes but at least once an hour, and when a session ends"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.tile_disk_usage.tile_count":                                           "Number of cached tiles at the time this stat was logged",
					"value.proto_value.tile_disk_usage.tile_bytes":                                           "Total cache size at the time this stat was logged",
					"value.proto_value.tile_disk_usage.session_stats.session_nonce":                          "Unique session identifier since last log",
					"value.proto_value.tile_disk_usage.session_stats.tile_lookups":                           "Number of tile lookups this session since last log",
					"value.proto_value.tile_disk_usage.session_stats.disk_cache_hits":                        "Number of tile lookups found in cache since last log",
					"value.proto_value.tile_disk_usage.session_stats.download_attempts":                      "Number of tile download attempts since last log",
					"value.proto_value.tile_disk_usage.session_stats.download_success_count":                 "Number of successful tile downloads (including etag hits) since last log",
					"value.proto_value.tile_disk_usage.session_stats.override_disk_cache_hits":               "Number of override lookups found in cache since last log",
					"value.proto_value.tile_disk_usage.session_stats.override_download_attempts":             "Number of override download attempts since last log",
					"value.proto_value.tile_disk_usage.session_stats.override_download_success_count":        "Number of successful override downloads (including etag hits) since last log",
					"value.proto_value.tile_disk_usage.session_stats.tile_download_etag_hits":                "Number of tile etag matches since last log",
					"value.proto_value.tile_disk_usage.session_stats.override_download_etag_hits":            "Number of override etag hits since last log",
					"value.proto_value.tile_disk_usage.session_stats.session_start_time_utc_ms":              "Times when the current session began in UTC",
					"value.proto_value.tile_disk_usage.session_stats.tile_version":                           "Tile version being used during this session",
					"value.proto_value.tile_disk_usage.session_stats.tiles_cache_key":                        "Tile cache key being used during this session",
					"value.proto_value.tile_disk_usage.session_stats.overrides_cache_key":                    "Override cache key being used during this session",
					"value.proto_value.tile_disk_usage.session_stats.bridge_location_lookups":                "Number of bridge location lookups this session",
					"value.proto_value.tile_disk_usage.session_stats.bridge_location_disk_cache_hits":        "Number of bridge location lookups found in cache since last log",
					"value.proto_value.tile_disk_usage.session_stats.bridge_location_download_attempts":      "Number of bridge location download attempts since last log",
					"value.proto_value.tile_disk_usage.session_stats.bridge_location_download_success_count": "Number of successful bridge location downloads (including etag hits) since last log",
					"value.proto_value.tile_disk_usage.session_stats.bridge_location_download_etag_hits":     "Number of bridge location etag matches since last log",
					"value.proto_value.tile_disk_usage.session_stats.bridge_location_version":                "Bridge location version being used during this session",
					"value.proto_value.tile_disk_usage.session_stats.bridge_location_cache_key":              "Bridge location cache key being used during this session",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTimeStatus,
			BinaryMessageField: "TimeStatus",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the time status of the gateway that identifies the time tracking source and the time skew relative to different time sources.",
				Frequency:   FrequencyEveryXSeconds(10 * samtime.SecondsInMinute),
				ColumnDescriptions: map[string]string{
					"value.proto_value.time_status.skews":         "A list of time skews for different time sources.",
					"value.proto_value.time_status.skews.source":  metadatahelpers.EnumDescription("The time source used to calculate the skew.", hubproto.ObjectStatBinaryMessage_TimeStatus_TimeSource_name),
					"value.proto_value.time_status.skews.skew_ms": "The millisecond time skew between this time source and the locked time source.",
					"value.proto_value.time_status.tracking":      metadatahelpers.EnumDescription("The time source used for tracking and adjusting time.", hubproto.ObjectStatBinaryMessage_TimeStatus_TimeSource_name),
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTimeToFirstHubConnection,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTireConditionData,
			BinaryMessageField: "TireConditionPerAsset",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag, amundsentags.AssetsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Tire condition data per tire on the vehicle (J1939)",
				Frequency:   FrequencyEveryXSeconds(5 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.tire_condition_per_asset.asset.type":                          metadatahelpers.EnumDescription("Type of asset sending the information", hubproto.ObjectStatBinaryMessage_TireConditionPerAsset_Asset_AssetType_name),
					"value.proto_value.tire_condition_per_asset.asset.manufacturer":                  metadatahelpers.EnumDescription("Manufacturer seen based on PGN 60928 (Address Claim)", hubproto.ObjectStatBinaryMessage_TireConditionPerAsset_Asset_Manufacturer_name),
					"value.proto_value.tire_condition_per_asset.asset.manufacturer_code":             "The Manufacturer Code is an 11-bit field that indicates which company was responsible for the production of electronic control module for which this NAME is being referenced. Manufacturer codes are assigned by committee and may be found in the SAE J1939 base document. The Manufacturer Code field is not dependent on any other field in the NAME. J1939-81",
					"value.proto_value.tire_condition_per_asset.asset.source_address":                "ECU address source of the tire condition data. J1939-DA PGN 65268, SPN 929",
					"value.proto_value.tire_condition_per_asset.asset.tire.tire_from_left":           "Location on the axel from the left. J1939-DA PGN 65268, SPN 929",
					"value.proto_value.tire_condition_per_asset.asset.tire.axle_from_front":          "Location from the axle on the vehicle.",
					"value.proto_value.tire_condition_per_asset.asset.tire.pressure_k_pa":            "Pressure at which air is contained in cavity formed by tire and rim. J1939-DA PGN 65268",
					"value.proto_value.tire_condition_per_asset.asset.tire.temperature_milli_c":      "Temperature at the surface of the tire sidewall. J1939-DA PGN 65268 [TIRE1], SPN 242.",
					"value.proto_value.tire_condition_per_asset.asset.tire.sensor_status":            metadatahelpers.EnumDescription("Indicates whether the tire sensor is being monitored by the controller or is Enabled/Disabled.", hubproto.ObjectStatBinaryMessage_TireConditionPerAsset_Asset_Tire_SensorStatus_name),
					"value.proto_value.tire_condition_per_asset.asset.tire.tire_status":              metadatahelpers.EnumDescription("Indicates the status of the tire. J1939-DA PGN 65268 (Tire Condition Message 1) [TIRE1], SPN 1698.", hubproto.ObjectStatBinaryMessage_TireConditionPerAsset_Asset_Tire_TireStatus_name),
					"value.proto_value.tire_condition_per_asset.asset.tire.pressure_threshold":       metadatahelpers.EnumDescription("Signal indicating the pressure level of the tire.  The levels defined represent different pressure conditions of the tire. J1939-DA PGN 65268 (Tire Condition Message 1) [TIRE1], SPN 2587", hubproto.ObjectStatBinaryMessage_TireConditionPerAsset_Asset_Tire_PressureThreshold_name),
					"value.proto_value.tire_condition_per_asset.asset.tire.temperature_status":       metadatahelpers.EnumDescription("Temperature status of the tire.", hubproto.ObjectStatBinaryMessage_TireConditionPerAsset_Asset_Tire_TemperatureStatus_name),
					"value.proto_value.tire_condition_per_asset.asset.tire.tire_alerts":              metadatahelpers.EnumDescription("Alerts related to the tire", hubproto.TireAlert_name),
					"value.proto_value.tire_condition_per_asset.asset.serial_number":                 "Serial number of the component. J1939-DA PGN 65259 (Component Identification) [CI], SPN 588",
					"value.proto_value.tire_condition_per_asset.asset.tire.pressure_high_range_k_pa": "Higher range Pressure of air in tire. PressurePro specific reporting in PGN 64953",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTorquePercent,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTotalApparentPowerVoltAmpere,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTotalAssetEngineMs,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTotalChargeUsedMicroAmpsH,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTotalkWHExported,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTotalPowerkW,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.AssetsTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Electrical power delivered by the engine to the electrical system connected to the generator.",
				Frequency:           FrequencyOnChange("1kW delta between readings are reported"),
				IntValueDescription: "Total power (kW). J1939-DA PGN 65171 Engine Electrical System/Module Information (EES), SPN 1024.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTotalReactivePowerVoltAmpereReactive,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTotalRealPowerWatt,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTotalUsedMemKB,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Total amount of system memory used (kb)",
				Frequency:           FrequencyEveryXSeconds(10 * 60),
				IntValueDescription: "Total amount of system memory used as read from meminfo. This is the total amount of memory minus the amount of available memory",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTrailerAirLineStatus,
			BinaryMessageField: "TrailerAirLineStatus",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Temperature and pressure readings from trailer third party sensors that are connected to the trailer air line.",
				Frequency:   FrequencyCustom("When we read a valid value from third party sensor"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.trailer_air_line_status.temperature_celsius":                    "Temperature in Celsius",
					"value.proto_value.trailer_air_line_status.pressure_kpa":                           "Pressure in kPa",
					"value.proto_value.trailer_air_line_status.sensor_diagnostics.battery_level_volts": "Battery level in volts",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTrailerAxleLoadSumKilograms,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.AG52Tag, amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag, amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "The sum of all reported trailer axles as reported by a 3rd party device such as ABS or onboard scale.",
				Frequency:           FrequencyEveryXSeconds(5 * 60),
				IntValueDescription: "sum of all reported trailer axles as reported by a 3rd party device such as ABS or onboard scale in kilograms",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDTrailerFaultReportingStartupConnectivityStatus,
			BinaryMessageField: "TrailerFaultReportingStartupConnectivityStatus",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.AG52Tag, amundsentags.AssetsTag, amundsentags.MarathonTag, amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Sent at startup of ABS system to log startup success and metadata",
				Frequency:   FrequencyCustom("Once per start of ABS system, normally on device power up."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.trailer_fault_reporting_startup_connectivity_status.cable_type":                       "Cable ID of cable currently plugged into the AG5x",
					"value.proto_value.trailer_fault_reporting_startup_connectivity_status.startup_connectivity_type":        metadatahelpers.EnumDescription("Startup type, or no startup if routine not captured.", plc4trucksproto.TrailerFaultReportingStartupConnectivityStatus_StartupConnectivityType_name),
					"value.proto_value.trailer_fault_reporting_startup_connectivity_status.start_signal_detection_period_ms": "Time in milliseconds of the period gateway looked for start signal after power on.  From device config.",
					"value.proto_value.trailer_fault_reporting_startup_connectivity_status.start_signal_debounce_ms":         "Debounce time of signal; from device config.  Longer means signal had to maintain longer at a level before being recognized as that level.",
					"value.proto_value.trailer_fault_reporting_startup_connectivity_status.sample_period_ms":                 "Time between samples of the device analog to digital converter that is measuring signal.",
					"value.proto_value.trailer_fault_reporting_startup_connectivity_status.start_time_after_power_on_ms":     "Time in milliseconds after the AG recognized power on until it caught the beginning of the start signal or 0 if not caught.",
					"value.proto_value.trailer_fault_reporting_startup_connectivity_status.end_time_after_power_on_ms":       "Time in milliseconds after the AG recognized power on until it caught the end of the start signal or 0 if not caught.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTrailerVehicleDynamicControlStatus,
			Kind:     StatKindObjectStat,
			Tags:     []amundsentags.Tag{amundsentags.AG53Tag, amundsentags.AssetsTag, amundsentags.MarathonTag, amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description:         "Status of the VDC (Vehicle dynamic Control) system for a trailer asset (Includes Roll over and Yaw control)",
				Frequency:           FrequencyOnChange("On change of state"),
				IntValueDescription: metadatahelpers.EnumDescription("If VDC is actively controlling an event", brakemonitoringproto.VehicleDynamicControlStatus_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDTripPurpose,
			Kind:     StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Tells if the current trip should be treated as private or business",
				Frequency:           FrequencyOnChange("Once per trip selection."),
				IntValueDescription: metadatahelpers.EnumDescription("Tells if the current trip should be treated as private or business.", hubproto.TripPurposeState_name),
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDUnpoweredDormantSinceMs,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "Reports the time (in ms) since an unpowered asset's eligible, previously recorded location to its most recent.",
				Frequency:           FrequencyCustom("These stats are generated over a 30 min spread interval by the unpowereddormancyworker poller"),
				IntValueDescription: "Total amount of time (in ms) between an unpowered asset's eligible, previously recorded location to its most recent. This value is calculated via a polling worker in unpowereddormancyworker",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDUpgradeDurations,
			BinaryMessageField: "UpgradeDurations",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.CoreFirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "How long it takes to complete each part of the upgrade process",
				Frequency:   FrequencyOnChange("once per upgrade attempt"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.upgrade_durations.build":                             "build of firmware being upgraded to",
					"value.proto_value.upgrade_durations.time_from_first_push_to_reboot_ms": "time in milliseconds from start of upgrade process to rebooting",
					"value.proto_value.upgrade_durations.delta_download_duration_ms":        "time in milliseconds it took to download the delta upgrade if the device attempted to use delta upgrades",
					"value.proto_value.upgrade_durations.delta_apply_duration_ms":           "time in milliseconds it takes to generate a full upgrade script from the delta",
					"value.proto_value.upgrade_durations.full_script_download_duration_ms":  "time in milliseconds it takes to download the full upgrade script if delta method is not being used",
					"value.proto_value.upgrade_durations.successfully_used_delta":           "upgrade was generated using delta method",
					"value.proto_value.upgrade_durations.attempted_to_use_delta":            "delta upgrade was downloaded",
					"value.proto_value.upgrade_durations.upgrade_script_duration_ms":        "time in milliseconds it takes to run the upgrade script",
					"value.proto_value.upgrade_durations.wait_duration_ms":                  "time in milliseconds the device waits before rebooting due to movement, etc.",
				}},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDUploadedFileSet,
			BinaryMessageField: "UploadedFileSet",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			MetadataInfo: &MetadataInfo{
				Description: "Contains the S3 urls of files uploaded from the device. The group of URLs are all the files associated with a single event, such as a video retrieval, a harsh event, or a trip still snapshot. Files can include audio, mp4s, trip stills, and metadata.",
				Frequency:   FrequencyOnChange("all files for the event have been uploaded to S3"),
				ColumnDescriptions: map[string]string{
					"object_id": "Emitted by CM deviceId for CM3Xs, and VG deviceId for non-CM3Xs.",
					"value.proto_value.uploaded_file_set.event_id":                                    "Corresponds to event_id in cmassets.dashcam_assets table. Also corresponds to the historical_video_request.id for retrievals.",
					"value.proto_value.uploaded_file_set.s3urls":                                      "S3 URLs that were uploaded for the asset",
					"value.proto_value.uploaded_file_set.requested_file_state":                        "0 for files okay, 1 for files not found.",
					"value.proto_value.uploaded_file_set.file_timestamp":                              "asset_ms (start time) of the uploaded asset.",
					"value.proto_value.uploaded_file_set.dashcam_file_infos.filename":                 "DashcamFileInfos is an array with an entry for each file that was uploaded. The filename field specifies which file the entry corresponds to.",
					"value.proto_value.uploaded_file_set.dashcam_file_infos.duration_ms":              "Duration in ms of the asset (if it's a video).",
					"value.proto_value.uploaded_file_set.dashcam_file_infos.file_size":                "Size in MB of the raw uploaded asset",
					"value.proto_value.uploaded_file_set.dashcam_file_infos.start_ago_ms":             "The device sends up video streams starting on keyframes, so the start time of video/audio files can be slightly offset. This field reports the difference between the requested asset_ms of the asset and the actual start time. Positive value if the stream starts before asset_ms, and negative value if the stream starts after asset_ms.",
					"value.proto_value.uploaded_file_set.dashcam_file_infos.upload_duration_ms":       "The duration in ms of the last successful upload for the respective file.",
					"value.proto_value.uploaded_file_set.dashcam_file_infos.total_upload_duration_ms": "The duration in ms for all upload attempts for this file (starting from the last time the device attempted processing the asset request).",
					"value.proto_value.uploaded_file_set.dashcam_file_infos.upload_attempts":          "The number of times the device attempted to upload the file, (starting from the last time the device attempted processing the asset request)",
				},
			},
			Tags: []amundsentags.Tag{amundsentags.SafetyTag},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDUploadedFileSetStart,
			BinaryMessageField: "DashcamReport",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDUploadStatus,
			BinaryMessageField: "UploadStatus",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDUsbResetAttempt,
			BinaryMessageField: "UsbResetAttempt",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description: "Record of VG attempting to reset USB connection to CM",
				Frequency:   FrequencyOnChange("once per usb reset attempt"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.usb_reset_attempt.successful":                        "whether or not the CM reconnected within the attempt interval",
					"value.proto_value.usb_reset_attempt.time_since_reset_ms":               "ms offset between objectstat timestamp and initiation of usb reset",
					"value.proto_value.usb_reset_attempt.config":                            "usb reset configs at the time of attempt",
					"value.proto_value.usb_reset_attempt.config.enabled":                    "EnabledFlag that determines whether or not reset functionality is enabled",
					"value.proto_value.usb_reset_attempt.config.interval_between_resets_ms": "ms between consecutive reset attempts",
					"value.proto_value.usb_reset_attempt.config.reset_duration_ms":          "time in ms that usb is held down for during reset",
					"value.proto_value.usb_reset_attempt.config.max_resets":                 "maximum number of unsuccessful resets before stopping recovery attempt",
				}},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDUtilizationEvent,
			BinaryMessageField: "UtilizationEvent",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Asset Utilization event",
				Frequency:   FrequencyCustom("When a utilization event starts or ends"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.utilization_event.utilization_state": metadatahelpers.EnumDescription("The state of the utilization event", hubproto.UtilizationEvent_UtilizationState_name),
					"value.proto_value.utilization_event.uuid":              "Identifier for the utilization event.",
					"value.proto_value.utilization_event.use_case_uuid":     "Identifier for the use case used to generate the event.",
					"value.proto_value.utilization_event.start_ms":          "Timestamp in ms when the utilization event started.",
					"value.proto_value.utilization_event.duration_ms":       "Duration in ms of the utilization event.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDValidBrakeScore,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:            "The brake score using regression analysis only if the margin of error is less than 3%",
				Frequency:              FrequencyCustom("Less than once every six hours."),
				DoubleValueDescription: "Brake score out of 100",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDVanishingPointState,
			BinaryMessageField: "VanishingPointState",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDVdpSignalCacheSnapshot,
			BinaryMessageField: "VdpSignalCacheSnapshot",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Snapshot of the VDP Signal Cache",
				Frequency:   FrequencyEveryXSeconds(20 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.vdp_signal_cache_snapshot":                                            "Snapshot of the VDP Signal Cache",
					"value.proto_value.vdp_signal_cache_snapshot.entries":                                    "Entries in the VDP Signal Cache, each corresponding to a single source",
					"value.proto_value.vdp_signal_cache_snapshot.entries.source":                             "The source of the signals contained in this entry",
					"value.proto_value.vdp_signal_cache_snapshot.entries.source.bus":                         metadatahelpers.EnumDescription("The bus of the signals contained in this entry", objectstatproto.VehicleDiagnosticBus_name),
					"value.proto_value.vdp_signal_cache_snapshot.entries.source.ecu_id":                      "The ECU ID of the signals contained in this entry",
					"value.proto_value.vdp_signal_cache_snapshot.entries.source.request_id":                  "The request ID of the signals contained in this entry",
					"value.proto_value.vdp_signal_cache_snapshot.entries.source.data_id":                     "The data ID of the signals contained in this entry",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals":                            "The signals corresponding the the source for this entry",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal":                     "The signal and its statistics, calculated over the values seen within the period of the snapshot",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.obd_value":           "The OBD value of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.int_value":           "The last seen value of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.string_value":        "The string value of the signal, if there is one",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.double_value":        "Unused.",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.positive_diff_count": "The number of positive diffs between consecutive values of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.negative_diff_count": "The number of negative diffs between consecutive values of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.first_int_value":     "The first seen value of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.min_int_value":       "The minimum value of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.min_count":           "The number of times the minimum value was seen (see min_int_value)",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.max_int_value":       "The maximum value of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.max_count":           "The number of times the maximum value was seen (see max_int_value)",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.avg_value":           "The mean of the values of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.stddev":              "The standard deviation of the values of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.q1_value":            "The first quartile, or 25th percentile, of the values of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.median_value":        "The median, or 50th percentile, of the values of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.signal.q3_value":            "The third quartile, or 75th percentile, of the values of the signal",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.updated_ago_ms":             "How long ago the last value of the signal was seen, in ms (see int_value)",
					"value.proto_value.vdp_signal_cache_snapshot.entries.signals.count":                      "The number of times this signal was seen since the last snapshot (see duration_ms)",
					"value.proto_value.vdp_signal_cache_snapshot.duration_ms":                                "The time in ms this snapshot has been gathered over. Note that some signals may not have been seen in this period; the count will be 0 if not.",
				},
			},
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDVehicleCurrentGear,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			MetadataInfo: &MetadataInfo{
				Description: "The current gear of the vehicle",
				Frequency:   FrequencyOnChange("When value changes"),
				ColumnDescriptions: map[string]string{
					"object_id":       "Device ID",
					"value.time":      "Timestamp of the objectstat",
					"value.int_value": "The current gear a vehicle is in. This value can be either positive (foward gears) or negative (reverse gears).",
				},
			},
			Production: true,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(4),
					},
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDVehicleGearCommanded,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "The current drive state of the vehicle.",
				Frequency:           FrequencyOnChange("When the value changes."),
				IntValueDescription: metadatahelpers.EnumDescription("Drive state of the vehicle", hubproto.GearCommanded_name),
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDVgCableInfo,
			BinaryMessageField:       "VgCableInfo",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDVgMcuFatal,
			BinaryMessageField:       "VgMcuFatal",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDVgMcuMetrics,
			BinaryMessageField:       "VgMcuMetrics",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDVgMcuSpiTiming,
			BinaryMessageField: "VgMcuSpiTimingInfo",
			Kind:               StatKindObjectStat,
			InternalOverrides: &DataplatformOverrides{
				RegionOverrides: map[string]RegionOverrides{
					infraconsts.SamsaraAWSDefaultRegion: {
						MaxWorkersOverride: pointer.IntPtr(8),
					},
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDVictronSmartShuntBatteryMonitorDebug,
			BinaryMessageField: "VictronSmartShuntBatteryMonitorDebug",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Snapshot of the Victron Smart Shunt Battery Monitor",
				Frequency:   FrequencyCustom("Every time it receives data from the battery monitor."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.victron_smart_shunt_battery_monitor_debug.state_of_charge_percentage": "The state of charge of the battery in percentage.",
					"value.proto_value.victron_smart_shunt_battery_monitor_debug.battery_voltage_millivolts": "Voltage of the battery in millivolts.",
					"value.proto_value.victron_smart_shunt_battery_monitor_debug.battery_current_milliamps":  "Current of the battery in milliamps.",
				},
			},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDVideoTokens,
			Kind:                 StatKindObjectStat,
			BinaryMessageField:   "VideoTokens",
			S3BinaryMessageField: "VideoTokensData",
			MetadataInfo: &MetadataInfo{
				Description: "Video tokens are embeddings generated from video captured by dashcams.",
				Frequency:   FrequencyEveryXSeconds(60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.video_tokens.model_version":                  "The model used to generate the embeddings.",
					"value.proto_value.video_tokens.media_inputs":                   "The media inputs for which embeddings were generated.",
					"s3_proto_value.video_tokens_data.streams.media_input":          "The media input that corresponds to this stream.",
					"s3_proto_value.video_tokens_data.streams.embeddings.data":      "The embedding value",
					"s3_proto_value.video_tokens_data.streams.embeddings.offset_ms": "The timestamp offset (relative to objectstat) of the frame of the embedding.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDVin,
			BinaryMessageField: "VinEvent",
			DataModelStat:      true,
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Filtered VIN reported from a vehicle",
				Frequency:   FrequencyOnChange("when VIN response received and validated, and only once per diagnostic session"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.vin_event.vin": "Validated VIN response received from the vehicle. The reported VIN is validated by VIN providers in both the EU and US when this objectstat is reported. The reported VIN is added to the device configuration as well to change the behavior of the firmware.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDVisionResult,
			BinaryMessageField: "VisionResult",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDVoltageIgnitionDetections,
			BinaryMessageField: "VoltageIgnitionDetection",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag, amundsentags.TelematicsTag},
			MetadataInfo: &MetadataInfo{
				Description: "Vehicle ignition events detected by using the cable voltage signal",
				Frequency:   FrequencyOnChange("every 5 minutes if there was an ignition event detected within the last 5 minutes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.voltage_ignition_detection.metadata.algorithm_version":            "The firmware algorithm version (incremented by 1 anytime we update the firmware algorithm).",
					"value.proto_value.voltage_ignition_detection.metadata.sample_period_ms":             "The external voltage sample period the firmware is using.",
					"value.proto_value.voltage_ignition_detection.metadata.voltage_jump_detector_config": "The voltage jump detection config.",
					"value.proto_value.voltage_ignition_detection.detection_offsets_ms":                  "A list of time offsets in the past when an ignition event was detected.",
					"value.proto_value.voltage_ignition_detection.detection_min_observed_voltages_mv":    "A list of the minimum observed voltages in the voltage jump detector window before each ignition event. See voltageprocessor for detection window duration.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDVrpcClientConnected,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osDVrpcClientMetrics,
			BinaryMessageField:       "VrpcClientMetrics",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDVulcanBootInfo,
			BinaryMessageField: "VulcanBootInfo",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDVulcanPeripheralReset,
			BinaryMessageField: "VulcanPeripheralReset",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDWakeReason,
			BinaryMessageField: "WakeReason",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Reasons that the device is awake in normal power",
				Frequency:   FrequencyOnChange("osDWakeReason"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.wake_reason.reason_entries.wake_reason": metadatahelpers.EnumDescription("Wake Reason", hubproto.ObjectStatBinaryMessage_PowerStateInfo_PowerStateChangeReason_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDWakeUpSmsSent,
			BinaryMessageField: "WakeUpSmsSent",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Contains the logs of wake up SMS sent by the backend to a device",
				Frequency:   FrequencyCustom("When a device wake up is requested"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.wake_up_sms_sent.device_iccid":       "The ICCID of the device we're sending the SMS to.",
					"value.proto_value.wake_up_sms_sent.source_id":          "The id of the 'sender' of the SMS.",
					"value.proto_value.wake_up_sms_sent.priority":           metadatahelpers.EnumDescription("The SMS priority on the network", hubproto.ObjectStatBinaryMessage_WakeUpSms_SmsPriority_name),
					"value.proto_value.wake_up_sms_sent.validity_period_ms": "The period (in ms) before which the SMS is dropped if not delivered.",
					"value.proto_value.wake_up_sms_sent.replace_if_present": "Specifies if this SMS should replace a previous SMS pending reception (if present).",
				},
			},
			Tags: []amundsentags.Tag{amundsentags.AssetsTag},
		},
		{
			StatType:             objectstatproto.ObjectStatEnum_osDWazeBeaconSamples,
			S3BinaryMessageField: "WazeBeaconSamples",
			Kind:                 StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "List of waze beacon samples detected by a device in its vicinity",
				Frequency:   FrequencyCustom("Reports every 30 seconds if at least one beacon is detected"),
				ColumnDescriptions: map[string]string{
					"s3_proto_value.waze_beacon_samples":                 "An array of waze beacons detected by the device",
					"s3_proto_value.waze_beacon_samples.instance_id":     "Unique identifier for the waze beacon",
					"s3_proto_value.waze_beacon_samples.rssi_dbm":        "Signal strength in dBm",
					"s3_proto_value.waze_beacon_samples.event_offset_ms": "Time offset in milliseconds since the beacon event occurred",
				},
			},
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDWeatherAlertStatus,
			BinaryMessageField: "WeatherAlertStatus",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Weather alert status for devices approaching severe weather conditions. " +
					"Emitted only when a device is detected to be heading toward severe weather based on trajectory analysis and weather forecast data. ",
				Frequency: FrequencyCustom("When a device is detected to be heading toward severe weather"),
				ColumnDescriptions: map[string]string{
					"object_id":  "Device ID",
					"value.time": "Timestamp when the alert status was recorded",
					"value.proto_value.weather_alert_status.weather_type":       "Type of weather: 0 = UNSPECIFIED, 1 = PRECIPITATION, 2 = WIND, 3 = THUNDER",
					"value.proto_value.weather_alert_status.precipitation_type": "Type of precipitation: 0 = UNSPECIFIED, 1 = RAIN, 2 = FREEZE, 3 = MIX, 4 = SNOW",
					"value.proto_value.weather_alert_status.weather_severity":   "Severity of weather: 0 = UNSPECIFIED, 1 = NONE, 2 = LIGHT, 3 = MODERATE, 4 = HEAVY, 5 = EXTREME",
				},
			},
			Tags: []amundsentags.Tag{
				amundsentags.SafetyTag,
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDWgfiConnected,
			BinaryMessageField: "WgfiConnected",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Information retrieved from a WGFI device upon connection",
				Frequency:   FrequencyCustom("Every time the WGFI USB cable is connected and the device responds to a request for information"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.wgfi_connected.device_info.model_number":     "Model number of the WGFI device (uint8).",
					"value.proto_value.wgfi_connected.device_info.firmware_version": "Firmware version of the WGFI device. uint16 with MSB=major version, LSB=minor version.",
					"value.proto_value.wgfi_connected.device_info.serial_number":    "Serial number of the WGFI device.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDWgfiIncrementalStatistics,
			BinaryMessageField: "WgfiIncrementalStatistics",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Incremental statistics related to communications with a WGFI device",
				Frequency:   FrequencyCustom("Determined by device config WgfiConfig.MinReportingIntervalMs"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.wgfi_incremental_statistics.packets_sent_count":      "The number of packets sent to the WGFI device since the last report.",
					"value.proto_value.wgfi_incremental_statistics.packets_received_count":  "The number of good packets received from the WGFI device since the last report.",
					"value.proto_value.wgfi_incremental_statistics.responses_missing_count": "The number of packets that weren't replied to by the WGFI device since the last report. (deprecated)",
					"value.proto_value.wgfi_incremental_statistics.bad_checksums_count":     "The number of packets received from the WGFI device with a bad checksum since the last report. (deprecated)",
					"value.proto_value.wgfi_incremental_statistics.report_window_ms":        "The time window in ms that this report covers.",
					"value.proto_value.wgfi_incremental_statistics.errors":                  "The errors that occurred during the reporting window and their respective counts.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDWheelEndHealth,
			BinaryMessageField: "WheelEndHealth",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Snapshot of health of all wheel ends on the truck or trailer.",
				Frequency:   FrequencyCustom("Depends on integration type and aggregation logic."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.wheel_end_health.wheel_ends.wheel_end_position.axle_from_front":           "Axle number front front. Zero indexed.",
					"value.proto_value.wheel_end_health.wheel_ends.wheel_end_position.wheel_end_side":            metadatahelpers.EnumDescription("Side of the asset the wheel end is on.", assethealthproto.WheelEndHealth_WheelEnd_WheelEndPosition_WheelEndSide_name),
					"value.proto_value.wheel_end_health.wheel_ends.wheel_end_reading.temperature_milli_celsius":  "Temperature of wheel end in milli celsius.",
					"value.proto_value.wheel_end_health.wheel_ends.wheel_end_reading.temperature_warning_active": "True is temperature warning is active.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDWidgetLogBatchProcessingStat,
			BinaryMessageField: "WidgetLogBatchProcessingStat",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDWifiApBytes,
			Kind:       StatKindObjectStat,
			Production: true,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osDWifiApNonWhitelistUsageBytes,
			Kind:     StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description:         "VG WiFi data usage that isn't whitelisted in mobileconsts/driver_app_proxy_whitelist.go",
				Frequency:           FrequencyCustom("As data usage occurs"),
				IntValueDescription: "Number of bytes",
			},
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
			},
		},
		{
			StatType:   objectstatproto.ObjectStatEnum_osDWifiApWhitelistBytes,
			Kind:       StatKindObjectStat,
			Production: true,
		},
		{
			StatType:      objectstatproto.ObjectStatEnum_osDWindshieldWiperStatus,
			Kind:          StatKindObjectStat,
			DataModelStat: true,
			MetadataInfo: &MetadataInfo{
				Description:         "Status of the windshield wipers.",
				Frequency:           FrequencyOnChange("On change, but no faster than every 200ms"),
				IntValueDescription: metadatahelpers.EnumDescription("Status of the windshield wipers.", hubproto.WindshieldWiperStatus_name),
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osDWirelessInterfaceState,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "InterfaceState",
			Tags:               []amundsentags.Tag{amundsentags.FirmwareTag},
			MetadataInfo: &MetadataInfo{
				Description: "Information retrieved from a device's wireless interface",
				Frequency:   FrequencyCustom("Every ping cycle and/or custom interval"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.interface_state.wifi.uplink.up":     "Whether the network interface is connected and operational",
					"value.proto_value.interface_state.wifi.uplink.mac":    "String value representing the MAC address of the device's wireless interface",
					"value.proto_value.interface_state.wifi.uplink.ip":     "String value representing the IP address of the device's wireless interface",
					"value.proto_value.interface_state.wifi.uplink.router": "String value representing the router address of the device's wireless interface",
					"value.proto_value.interface_state.wifi.uplink.dns1":   "String value representing the primary domain name server of the device's wireless interface",
					"value.proto_value.interface_state.wifi.uplink.dns2":   "String value representing the secondary domain name server of the device's wireless interface",
					"value.proto_value.interface_state.wifi.ssid":          "String value representing the unique service set identifier of the device's wireless interface",
					"value.proto_value.interface_state.wifi.rssi_dbm":      "Integer value representing the signal strength of the wireless connection in decibel milliwatts",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osGBatteryLevel,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.AssetsTag,
				amundsentags.AG46Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "The string description of the battery level of the gateway. This differs from osGBattery because we want to calculate the battery level async, and do not use osGBattery to determine battery level for all associated gateways.",
				Frequency:           FrequencyCustom("This will be calculated weekly by batterylevelworker."),
				IntValueDescription: "Enum value of the battery state for the gateway. See go/src/samsaradev.io/products/battery_levels.go for enum values.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osGBleProxiedAdvertisement,
			Kind:               StatKindObjectStat,
			BinaryMessageField: "BleProxiedAdvertisement",
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MarathonTag,
				amundsentags.AG51Tag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Data corresponding to a BLE Proxied Advertisement, AKA Crux",
				Frequency:   FrequencyCustom("Logged when compatible peripheral(s) are observed by a central, default 1 minute per peripheral, but it is configurable"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.ble_proxied_advertisement.peripherals.uuid":                                                 metadatahelpers.EnumDescription("BLE Service UUID", bleproxyproto.ServiceUuid_name),
					"value.proto_value.ble_proxied_advertisement.peripherals.mac_observed":                                         "MAC address observed, may or may not be encrypted",
					"value.proto_value.ble_proxied_advertisement.peripherals.num_times_observed_during_batch_period":               "Number of times the peripheral was observed during the log period (will be non-zero only if different from number of repeated peripherals)",
					"value.proto_value.ble_proxied_advertisement.peripherals.last_adv_packet_data":                                 "Verbatim advertisement data observed in last advertisement in batch period",
					"value.proto_value.ble_proxied_advertisement.peripherals.tx_power_is_invalid":                                  "Set to true if the central couldn't understand the structure of advertisement to decode TX power",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series.incremental_observed_at_offset_ds": "Array with incremental deciseconds deltas after the log's happenedAtMs that this advertisement was observed",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series.incremental_rssi_dbm":              "Array of deltas of received signal strength of the peripheral as seen by the central, in dBm",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series.incremental_tx_power_dbm":          "Array of deltas of transmit power of peripheral, in dBm (note that 0 is a valid value)",
					"value.proto_value.ble_proxied_advertisement.peripherals.observation_series":                                   "Observation data that occurs during the batch period corresponding to this peripheral",
					"value.proto_value.ble_proxied_advertisement.peripherals.third_party_integration_id":                           "Device type ID used for third party BLE integrations, telling the backend what the data type is for use when parsing",
					"value.proto_value.ble_proxied_advertisement.peripherals":                                                      "Peripheral data observed during the batch period",
					"value.proto_value.ble_proxied_advertisement.batch_duration_sec":                                               "Amount of time (in seconds) the central scanned before uploading this stat",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osGGatewayMicroTotalSelfDischargeMicroAmpsH,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.AG46Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "The total charge passively used by the gateway via internal processes in the battery separate from any external circuits.",
				Frequency:           FrequencyCustom("Determined by organization-wide or device-specific config setting for unpowered asset gateway check-in frequency"),
				IntValueDescription: "Cumulative passive charge used over the gateway's lifetime in microampere hours.",
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osGHardwareInfo,
			BinaryMessageField: "HardwareInfo",
			Kind:               StatKindObjectStat,
			DataModelStat:      true,
			MetadataInfo: &MetadataInfo{
				Description: "Device Hardware Info",
				Frequency:   FrequencyEveryXSeconds(60 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.hardware_info.hardware_version":          "The full hardware version string from the identity partition.",
					"value.proto_value.hardware_info.product_version":           "The product version portion of the hardware version string.",
					"value.proto_value.hardware_info.build_phase":               "The build phase portion of the hardware version string.",
					"value.proto_value.hardware_info.bill_of_materials_version": "The bill of materials version portion of the hardware version string.",
					"value.proto_value.hardware_info.product":                   "The product string from the identity partition.",
					"value.proto_value.hardware_info.variant":                   "The variant string from the identity partition.",
					"value.proto_value.hardware_info.mac":                       "The MAC string from the identity partition.",
					"value.proto_value.hardware_info.serial":                    "The serial string from the identity partition.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osGMcuSecureLifecycleState,
			BinaryMessageField: "McuSecureLifecycleState",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Device Hardware Info",
				Frequency:   FrequencyCustom("On every boot if the hardware has an MCU that supports a secure lifecycle (e.g. VG55 product version 3 or later)."),
				ColumnDescriptions: map[string]string{
					"value.int_value": "Same as 0 value.proto_value.mcu_secure_lifecycle_state.state for convenience.",
					"value.proto_value.mcu_secure_lifecycle_state.state": metadatahelpers.EnumDescription("The MCU secure lifecycle state", vgmcuobjectstatproto.McuSecureLifecycleState_State_name),
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osGMemoryTestResult,
			BinaryMessageField: "MemoryTestResult",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Device Memory Test Result",
				Frequency:   FrequencyCustom("Once on boot as long as memory_test_config.results_enabled is enabled."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.memory_test_result.test_status": metadatahelpers.EnumDescription("Result returned by the test.", hubproto.MemoryTestResult_MemoryTestStatus_name),
					"value.proto_value.memory_test_result.test_output": "Text output produced by the test, if any.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osGNVRConnectionState,
			BinaryMessageField: "NvrConnectionState",
			Kind:               StatKindObjectStat,
			Tags:               []amundsentags.Tag{amundsentags.MulticamTag, amundsentags.SafetyTag},
			MetadataInfo: &MetadataInfo{
				Description:            "A stat that is uploaded when the NVR comes online and offline.",
				Frequency:              FrequencyOnChange("connects to VG"),
				IntValueDescription:    "Unused.",
				DoubleValueDescription: "Unused.",
				ColumnDescriptions: map[string]string{
					"value.proto_value.nvr_connection_state.nvr_id":                      "The device ID of the NVR. This should be map to the device ID in the devices table.",
					"value.proto_value.nvr_connection_state.nvr_serial":                  "The serial number of the NVR.",
					"value.proto_value.nvr_connection_state.slot_info.slot_id":           "",
					"value.proto_value.nvr_connection_state.slot_info.connected_state":   "Whether the NVR is connected to the VG. True if so, false otherwise.",
					"value.proto_value.nvr_connection_state.slot_info.camera_name":       "The name of the camera. Typically a pre-set value of HW-CM25 or HW-CM25-RJ45",
					"value.proto_value.nvr_connection_state.slot_info.camera_serial":     "The serial number of the camera. Typically hardcoded starting from 5000, increasing by 1 for each camera connected to the NVR. Could also be the default serial number of the camera. Not standardized to any case, and may or may not include hyphens.",
					"value.proto_value.nvr_connection_state.slot_info.camera_resolution": "Unused.",
					"value.proto_value.nvr_connection_state.slot_info.recording_state":   metadatahelpers.EnumDescription("Current recording state", hubproto.NVRConnectionState_NVRCameraSlotInfo_RecordingState_name),
					"value.proto_value.nvr_connection_state.slot_info.camera_id":         "Similar to camera_serial.",
					"value.proto_value.nvr_connection_state.slot_info.track_id":          "Maps to the NVR ID.",
					"value.proto_value.nvr_connection_state.unix_time_ms":                "The timestamp (ms) in which the connection state was uploaded.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osGObdCableId,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.TelematicsTag,
				amundsentags.MarathonTag,
				amundsentags.AG52Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Identifier read from on-board diagnostics (OBD)",
				Frequency:           FrequencyCustom("Reported each time the firmware OBD Manager is started"),
				IntValueDescription: "Cable ID read from attached gateway cable. Cable IDs are defined on the firmware in platform/cable_id.go",
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osGServicesMetrics,
			BinaryMessageField:       "ServicesMetrics",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			MetadataInfo: &MetadataInfo{
				Description: "Regularly reports metrics about service health of firmware services, used by Site Gateways and multicam Perseus devices.",
				Frequency:   FrequencyEveryXSeconds(10 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.services_metrics.services_metrics":                                   "An array of structs containing the different metrics values in this stat.",
					"value.proto_value.services_metrics.services_metrics.metric_name":                       metadatahelpers.EnumDescription("Name of contained metric.", hubproto.ServicesMetrics_ServicesMetric_Name_name),
					"value.proto_value.services_metrics.services_metrics.metric_custom_name":                "Populated if the MetricName value is CustomMetricName (enum value 1). This typically won't be populated.",
					"value.proto_value.services_metrics.services_metrics.metric_type":                       metadatahelpers.EnumDescription("Type of metric.", hubproto.ServicesMetrics_ServicesMetric_MetricType_name),
					"value.proto_value.services_metrics.services_metrics.tags_values":                       "An array representing the metric value for 'tag' entities (services, streams, channels, etc.).",
					"value.proto_value.services_metrics.services_metrics.tags_values.tags":                  "An array of tags, which identify different entities (services, streams, channels, etc.).",
					"value.proto_value.services_metrics.services_metrics.tags_values.tags.tag_key":          metadatahelpers.EnumDescription("Type of entity being described.", hubproto.ServicesMetrics_ServicesMetric_TagsValue_Tag_Key_name),
					"value.proto_value.services_metrics.services_metrics.tags_values.tags.tag_custom_key":   "Populated if the TagKey value is CustomTagKey (enum value 1). This typically won't be populated.",
					"value.proto_value.services_metrics.services_metrics.tags_values.tags.tag_int_value":    metadatahelpers.EnumDescription("An int value representing the tag & corresponding to the TagKey, so we can identify the entity. This can be an arbitrary int value (some Stream / Channel ID), or it can be the enum value corresponding to a particular service.", hubproto.ServicesMetrics_ServicesMetric_TagsValue_Tag_ServiceValue_name),
					"value.proto_value.services_metrics.services_metrics.tags_values.tags.tag_custom_value": "Populated if the tag value is represented by a string. This typically won't be populated.",
					"value.proto_value.services_metrics.services_metrics.tags_values.int_value":             "The int metric value corresponding to this array of tags. Populated if the value is an int (vs. float)",
					"value.proto_value.services_metrics.services_metrics.tags_values.int_diff_value":        "The difference between the current and previous int metric value. Int values are populated if the value is an int (vs. float).",
					"value.proto_value.services_metrics.services_metrics.tags_values.float_value":           "The float metric value corresponding to this array of tags. Populated if the value is a float (vs. int).",
					"value.proto_value.services_metrics.services_metrics.tags_values.float_diff_value":      "The difference between the current and previous float metric value. Float values are populated if the value is a float (vs. int).",
					"value.proto_value.services_metrics.end_time_offset_ms":                                 "The end of the time period captured by this stat's metrics, relative to the changedAtMs of the object stat.",
					"value.proto_value.services_metrics.duration_ms":                                        "The time period over which these metrics are aggregated. Typically 10 minutes, but it could be shorter (ex: service spins down b/c of gateway restart).",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osGTotalChargeUsedMicroAmpsH,
			Kind:     StatKindObjectStat,
			Tags: []amundsentags.Tag{
				amundsentags.FirmwareTag,
				amundsentags.AssetsTag,
				amundsentags.AG46Tag,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "The total charge actively used by the gateway, such as for sending pings.",
				Frequency:           FrequencyCustom("Determined by organization-wide or device-specific config setting for unpowered asset gateway check-in frequency"),
				IntValueDescription: "Cumulative active charge used over the gateway's lifetime in microampere hours.",
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osODeepStreamAggregates,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osODeepStreamMetadata,
			BinaryMessageField:       "DeepStreamMetadata",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
			MetadataInfo: &MetadataInfo{
				Description: "Reports data about objects detected by the firmware's video processing pipeline. Used for object detections (People, Vehicles, etc.) in the Sites product.",
				Frequency:   FrequencyCustom("Sent every 5 seconds when there are objects being detected. When detections stop, an 'empty' stat is sent (with detections as a len-0 array), and no more data will be sent until object detections resume."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.deep_stream_metadata":                                                                      "DeepStreamMetadata contains the object detection data, generated from the video processing pipeline on the Site Gateway",
					"value.proto_value.deep_stream_metadata.video_processing_pipeline_run_id":                                     "A randomly-generated number from the video processing service, to distinguish object ids between different runs of the service.",
					"value.proto_value.deep_stream_metadata.stream_width":                                                         "The width (in pixels) of the camera stream's frame. A user can change the camera dimensions at any time, so this can't be stateful in the backend.",
					"value.proto_value.deep_stream_metadata.stream_height":                                                        "The height (in pixels) of the camera stream's frame. A user can change the camera dimensions at any time, so this can't be stateful in the backend.",
					"value.proto_value.deep_stream_metadata.detections":                                                           "An array representing all the detected objects in this time period.",
					"value.proto_value.deep_stream_metadata.detections.deep_stream_object_id":                                     "A number to identify this tracked object, inside a given run of the video processing service. This increments with each new detected object.",
					"value.proto_value.deep_stream_metadata.detections.instances":                                                 "An array of the instances in which this detected object was present. Instance data is presented in deltas, so to calculate the absolute value of an instance, work back to index 0 and sum all values in-between.",
					"value.proto_value.deep_stream_metadata.detections.instances.delta_time_offset_ms":                            "Offset (in milliseconds) from the previous instance's timestamp.",
					"value.proto_value.deep_stream_metadata.detections.instances.delta_duration_ms":                               "The duration of this instance. Typically the value should be 0, since we expect an instance to represent a single frame. In the future, we could use this to represent data aggregated over a duration.",
					"value.proto_value.deep_stream_metadata.detections.instances.delta_upper_left":                                "A delta coordinate representing the upper-left vertex of the object's bounding box, relative to the previous instance's position.",
					"value.proto_value.deep_stream_metadata.detections.instances.delta_upper_left.delta_x":                        "The delta (in pixels) of the upper-left vertex's x-axis position.",
					"value.proto_value.deep_stream_metadata.detections.instances.delta_upper_left.delta_y":                        "The delta (in pixels) of the upper-left vertex's y-axis position.",
					"value.proto_value.deep_stream_metadata.detections.instances.delta_lower_right":                               "A delta coordinate representing the lower-right vertex of the object's bounding box, relative to the previous instance's position.",
					"value.proto_value.deep_stream_metadata.detections.instances.delta_lower_right.delta_x":                       "The delta (in pixels) of the lower-right vertex's x-axis position.",
					"value.proto_value.deep_stream_metadata.detections.instances.delta_lower_right.delta_y":                       "The delta (in pixels) of the lower-right vertex's y-axis position.",
					"value.proto_value.deep_stream_metadata.detections.instances.diagnostics":                                     "A struct that can be used to send detection confidence of this instance. Generally we populate the overall detection confidence, insetad of the confidence on each instance.",
					"value.proto_value.deep_stream_metadata.detections.instances.diagnostics.delta_confidence_percent":            "A number representing the delta in confidence percent from the previous instance.",
					"value.proto_value.deep_stream_metadata.detections.type":                                                      metadatahelpers.EnumDescription("The type of this detection", hubproto.DeepStreamMetadataAggregate_MetadataType_name),
					"value.proto_value.deep_stream_metadata.detections.secondary_classifier_metadata":                             "A struct representing some 'secondary' / additional information about this detection. This information applies across all instances of the detection.",
					"value.proto_value.deep_stream_metadata.detections.secondary_classifier_metadata.person":                      "A struct representing additional detection information, specific to Person detections.",
					"value.proto_value.deep_stream_metadata.detections.secondary_classifier_metadata.person.clothing":             "A struct representing the detected clothing color of this detected Person.",
					"value.proto_value.deep_stream_metadata.detections.secondary_classifier_metadata.person.clothing.upper_color": metadatahelpers.EnumDescription("The upper-body clothing color detected on this Person", hubproto.DeepStreamMetadataAggregate_Metadata_ObjDetection_PersonDetection_ClothingColorDetection_Color_name),
					"value.proto_value.deep_stream_metadata.detections.secondary_classifier_metadata.person.clothing.lower_color": metadatahelpers.EnumDescription("The lower-body clothing color detected on this Person", hubproto.DeepStreamMetadataAggregate_Metadata_ObjDetection_PersonDetection_ClothingColorDetection_Color_name),
					"value.proto_value.deep_stream_metadata.detections.motion_metadata":                                           "A struct representing the amount of motion associated with this object detection.",
					"value.proto_value.deep_stream_metadata.detections.motion_metadata.motion_value":                              "A number value for this object's 'motion' during its detected lifetime.",
					"value.proto_value.deep_stream_metadata.detections.confidence_percent":                                        "A number representing the detector's confidence in this object detection. If populated and valid, it should be a real percentage value (0-100).",
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osOMotionAggregate,
			BinaryMessageField:       "MotionAggregate",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osOSiteGatewayEventStillLowRes,
			BinaryMessageField: "SiteGatewayStillData",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Represents data about uploaded Sites still images, where these stills correspond to activity detections from the Site Gateway.",
				Frequency:   FrequencyCustom("Every 10 seconds, when there is an activity event (ex: person detection)"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.site_gateway_still_data":        "A struct representing how to access the image data.",
					"value.proto_value.site_gateway_still_data.s3_key": "The S3 key which identifies this uploaded image data in the samsara-workforce-video-assets S3 bucket.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osOSiteGatewayPeriodicStillLowRes,
			BinaryMessageField: "SiteGatewayStillData",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Represents data about uploaded Sites still images which are uploaded at a regular interval.",
				Frequency:   FrequencyEveryXSeconds(10 * 60),
				ColumnDescriptions: map[string]string{
					"value.proto_value.site_gateway_still_data":        "A struct representing how to access the image data.",
					"value.proto_value.site_gateway_still_data.s3_key": "The S3 key which identifies this uploaded image data in the samsara-workforce-video-assets S3 bucket.",
				},
			},
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osPEipRead,
			Kind:     StatKindObjectStat,
		},
		{
			StatType: objectstatproto.ObjectStatEnum_osPModbusRead,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osTDataPlatformInternalTestStat,
			BinaryMessageField: "DataPlatformInternalTestStat",
			Kind:               StatKindObjectStat,
			InternalOverrides: &DataplatformOverrides{
				MirrorToK8sSqSQueue: true,
			},
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description:         "Intended to be used for Data Platform team's internal testing purposes. Should not be used by any other teams.",
				Frequency:           FrequencyCustom("This stat does not have a logging frequency. It is an internal test stat and may not contain valid data."),
				IntValueDescription: "An arbitrary int value that does not have any meaning.",
				ColumnDescriptions: map[string]string{
					"value.time": "Timestamp of the internal test objectstat",
					"value.proto_value.data_platform_internal_test_stat.int_input":                       "An arbitrary int value that does not have any meaning.",
					"value.proto_value.data_platform_internal_test_stat.basic_data_input.sint_input":     "An arbitrary signed int value that does not have any meaning.",
					"value.proto_value.data_platform_internal_test_stat.basic_data_input.uint_input":     "An arbitrary unsigned int value that does not have any meaning.",
					"value.proto_value.data_platform_internal_test_stat.basic_data_input.bool_input":     "An arbitrary bool value that does not have any meaning.",
					"value.proto_value.data_platform_internal_test_stat.basic_data_input.string_input":   "An arbitrary string value that does not have any meaning.",
					"value.proto_value.data_platform_internal_test_stat.advanced_data_input.bytes_input": "An arbitrary bytes value that does not have any meaning.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvertisementStatistics,
			BinaryMessageField: "WidgetAdvertisementStatistics",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatBatteryMilliV,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the battery voltage of a widget in mV via advertisement",
				Frequency:   FrequencyCustom("When seen by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatCargoPercent,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the cargo percentage on cargo sensors via advertisement",
				Frequency:   FrequencyCustom("When seen by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatDistanceCM,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the cargo distance on cargo sensors via advertisement",
				Frequency:   FrequencyCustom("When seen by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatDoorClosed,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the door state on door monitors via advertisement",
				Frequency:   FrequencyCustom("When seen by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatLatch,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the magnet state on door monitors via advertisement",
				Frequency:   FrequencyCustom("When seen by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatMetadata,
			BinaryMessageField: "WidgetAdvStatMetadata",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports metadata about advertisements seen with encoded widget data",
				Frequency:   FrequencyCustom("Every 12 minutes while a widget is in view of a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_adv_stat_metadata.gateway_id":           "Gateway ID that saw the widget",
					"value.proto_value.widget_adv_stat_metadata.rssi_dbm":             "RSSI in dBm of widget",
					"value.proto_value.widget_adv_stat_metadata.min_counter_received": "Lowest packet counter seen in window",
					"value.proto_value.widget_adv_stat_metadata.version":              "Version of encoded data protocol",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatRelativeHumidityMilliPercent,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the relative humidity in percent via advertisement",
				Frequency:   FrequencyCustom("When seen by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatTemperatureMilliC,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the temperature in mC via advertisement",
				Frequency:   FrequencyCustom("When seen by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatThermistorTemperatureMilliC,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the thermistor temperature in mC via advertisement",
				Frequency:   FrequencyCustom("When seen by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWAdvStatTilt,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the accelerometer state on door monitors via advertisement",
				Frequency:   FrequencyCustom("When seen by a gateway"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osWAnomalyEvent,
			BinaryMessageField:       "AnomalyEvent",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},

		{
			StatType: objectstatproto.ObjectStatEnum_osWConnDeviceRSSI,
			Kind:     StatKindObjectStat,
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osWConnectInfo,
			BinaryMessageField:       "WidgetConnectInfo",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:                 objectstatproto.ObjectStatEnum_osWConnectionLifeCycle,
			BinaryMessageField:       "WidgetConnectionLifeCycle",
			Kind:                     StatKindObjectStat,
			DoNotSetConversionParams: sparktypes.ConversionParams{LegacyUint64AsBigint: true},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWLogStatistics,
			BinaryMessageField: "WidgetLogStatistics",
			Kind:               StatKindObjectStat,
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatBatteryVoltage,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the battery voltage in mV",
				Frequency:   FrequencyCustom("Every 5 minutes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatBootCount,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the boot count",
				Frequency:   FrequencyCustom("Once per boot"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatButton,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports widget button event",
				Frequency:   FrequencyCustom("Once per button event"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatCargoPercent,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the cargo percentage for an ACC-CRGO",
				Frequency:   FrequencyCustom("Every 10 minutes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatDistanceCM,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the distance in cm for an ACC-CRGO",
				Frequency:   FrequencyCustom("Every 10 minutes"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatDoorClosed,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports whether the door is closed",
				Frequency:   FrequencyCustom("Every 5 minutes or on change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatFillLevel,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the magnet state on door monitors",
				Frequency:   FrequencyCustom("Every 5 minutes or on change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatHardwareRevision,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the hardware revision of the widget",
				Frequency:   FrequencyCustom("Once per boot"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatLatch,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the magnet state on door monitors",
				Frequency:   FrequencyCustom("Every 5 minutes or on change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatManufactureUtcSec,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the UTC time the widget was manufactured",
				Frequency:   FrequencyCustom("Once per boot"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatPanic,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports panic string messages",
				Frequency:   FrequencyCustom("On event"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.string_value":           "String value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatProbeId,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the magnet state on door monitors",
				Frequency:   FrequencyCustom("Every 5 minutes or on change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatRelativeHumidity,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the relative humidity in percent",
				Frequency:   FrequencyCustom("On change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatResetReason,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the reset reason from the RESETREAS register",
				Frequency:   FrequencyCustom("Once per boot"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatTemperature,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the temperature in mC",
				Frequency:   FrequencyCustom("On change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatThermistorTemp,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the thermistor temperature in mC",
				Frequency:   FrequencyCustom("On change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatTilt,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the acceleromoter state on door monitors",
				Frequency:   FrequencyCustom("Every 5 min or on change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatVrmsXYZUmPerSec,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Three axes of vibration data in micrometers per second. Also leveraged for Altus debug data.",
				Frequency:   FrequencyCustom("Reported every 5 minutes."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStatWidgetRSSI,
			BinaryMessageField: "WidgetStat",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the RSSI as seen by the widget",
				Frequency:   FrequencyCustom("Every 5 min or on change"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_stat.power_cycle_generation": "Randomly generated value for each power-on-reset.",
					"value.proto_value.widget_stat.sequence":               "Sequence number that increments per log.",
					"value.proto_value.widget_stat.happened_at_ms":         "The original happened_at_ms from the log event.",
					"value.proto_value.widget_stat.int_value":              "Integer value reported by the widget.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStreamChannelConnectivity,
			BinaryMessageField: "WorkforceStreamChannelConnectivity",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports data about Sites CameraStream channel connectivity.",
				Frequency:   FrequencyCustom("Once per camera stream connection or disconnection event"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.workforce_stream_channel_connectivity":                     "A struct representing a sample of the CameraStream channel connectivity.",
					"value.proto_value.workforce_stream_channel_connectivity.connected":           "Whether the camera is connected to the SG or not.",
					"value.proto_value.workforce_stream_channel_connectivity.width":               "The width in pixels of this stream's video.",
					"value.proto_value.workforce_stream_channel_connectivity.height":              "The height in pixels of this stream's video.",
					"value.proto_value.workforce_stream_channel_connectivity.fps":                 "The Frames Per Second of this stream's video.",
					"value.proto_value.workforce_stream_channel_connectivity.start_time_ms":       "The start time for the camera connecting or disconnecting. ",
					"value.proto_value.workforce_stream_channel_connectivity.rfc6381_codec":       "The rfc6381 name for the codec used to compress this stream's video.",
					"value.proto_value.workforce_stream_channel_connectivity.bitrate":             "The bitrate of this stream's video.",
					"value.proto_value.workforce_stream_channel_connectivity.audio_availablility": metadatahelpers.EnumDescription("Denotes if audio is available and able to be used", hubproto.ObjectStatBinaryMessage_WorkforceStreamChannelConnectivity_AudioAvailability_name),
					"value.proto_value.workforce_stream_channel_connectivity.is_streaming_audio":  "We are using the audio from this steam and will be included in the video to the user.",
					"value.proto_value.workforce_stream_channel_connectivity.audio_codec":         "The name of the audio codec coming from this stream.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWStreamChannelStats,
			BinaryMessageField: "WorkforceStreamChannelStats",
			Kind:               StatKindObjectStat,
			ServerlessConfig: &databricks.ServerlessConfig{
				PerformanceTarget: databricks.StandardSeverlessJobPerformanceTarget,
			},
			MetadataInfo: &MetadataInfo{
				Description: "Reports data about Sites CameraStream channels.",
				Frequency:   FrequencyCustom("Every 1 minute, when there is active data coming in for a given stream channel"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.workforce_stream_channel_stats":                          "A struct representing a sample of the CameraStream channel.",
					"value.proto_value.workforce_stream_channel_stats.audio_sample_rate":        "The number of samples received per second from the camera.",
					"value.proto_value.workforce_stream_channel_stats.audio_samples_count":      "The number of samples received from the camera.",
					"value.proto_value.workforce_stream_channel_stats.compressed_audio_bytes":   "The number of compressed audio bytes stored.",
					"value.proto_value.workforce_stream_channel_stats.uncompressed_audio_bytes": "The number of uncompressed audio bytes received from the camera.",
					"value.proto_value.workforce_stream_channel_stats.video_bytes":              "The number of video bytes received in this sampled duration.",
					"value.proto_value.workforce_stream_channel_stats.video_duration_ms":        "The duration in ms over which this sample was taken.",
					"value.proto_value.workforce_stream_channel_stats.video_frame_count":        "The number of frames actually received in this sampled duration.",
					"value.proto_value.workforce_stream_channel_stats.video_keyframe_count":     "The number of key-frames actually received in this sampled duration.",
					"value.proto_value.workforce_stream_channel_stats.video_sps_change":         "True if there was a change in the camera's config (SPS framerate/res) during this sample.",
					"value.proto_value.workforce_stream_channel_stats.video_sps_fps":            "The SPS (Sequence Parameter Set)'s framerate. This is the FPS that the camera is trying to send - i.e. what the camera says it's doing. This could end up mismatched from the actual-recorded data.",
					"value.proto_value.workforce_stream_channel_stats.video_sps_height_px":      "The SPS (Sequence Parameter Set)'s height in pixels.",
					"value.proto_value.workforce_stream_channel_stats.video_sps_width_px":       "The SPS (Sequence Parameter Set)'s width in pixels.",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_osWUpgradeAttempt,
			BinaryMessageField: "WidgetUpgradeAttempt",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Data about a widget that has tried to upgrade its fw",
				Frequency:   FrequencyCustom("Reported every time a widget tries to upgrade"),
				ColumnDescriptions: map[string]string{
					"value.proto_value.widget_upgrade_attempt.upgrade_type":    metadatahelpers.EnumDescription("The type of widget upgrade", hubproto.ObjectStatBinaryMessage_WidgetUpgradeAttempt_UpgradeType_name),
					"value.proto_value.widget_upgrade_attempt.upgrade_version": "The version the widget is trying to upgrade to",
					"value.proto_value.widget_upgrade_attempt.current_version": "The version the widget is trying to upgrade from",
				},
			},
		},
		{
			StatType:           objectstatproto.ObjectStatEnum_usAppLocation,
			BinaryMessageField: "AppLocation",
			Kind:               StatKindObjectStat,
			MetadataInfo: &MetadataInfo{
				Description: "Reports the location of a device running a Samsara mobile app",
				Frequency:   FrequencyCustom("Reported every 5 seconds for an hour once a Worker Safety app-based panic button is hit. This is subject to change as future use cases adopt this stat type."),
				ColumnDescriptions: map[string]string{
					"value.proto_value.app_location.latitude":  "The latitude of a device running a Samsara mobile app",
					"value.proto_value.app_location.longitude": "The longitude of a device running a Samsara mobile app",
				},
			},
		},
	}
}

func init() {
	// Add Stats from rawStats Table (see above)
	for _, stat := range rawStats() {
		mustAddTable(NewTable(stat))
	}

	// Add Stats defined via reflection from methods that return *Stat
	registry := NewRegistryStat()
	for _, stat := range registry.GetStatsAll() {
		mustAddTable(NewTable(*stat))
	}
}
