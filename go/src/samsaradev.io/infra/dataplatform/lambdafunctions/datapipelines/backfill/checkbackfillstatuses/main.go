/*
checkbackfillstatuses is a lambda function that takes in a node and its parents backfill statuses (or lack thereof)
and computes whether a backfill should be run on a node. The conditions are as follows:

  - If an entry for the node is present in the Dynamo Table --> {execute_backfill: false}

  - If the length of the parents and length of the parent entries are not equal, a parent entry must be missing from the dynamo table.
    All parents should be SUCCESS backfill before a node is backfilled --> {execute_backfill: false}

  - If any of the parent entries are RUNNING or FAILED --> {execute_backfill: false}

  - If all of the above checks pass --> {execute_backfill: true}

    input: {
    parents: ["parent_1", "parent_2"], // Array of parents generated by the pipeline engine
    parent_backfill_statuses: [
    {
    "Item": {
    "node_id": {
    "S": "SUCCESS"
    }
    }
    }
    ], // Array of dynamodb items for the parents entries in the backfill status table
    node_backfill_status: {
    "Item": {
    "node_id": {
    "S": "SUCCESS"
    }
    }
    } // Dynamodb item for the node backfill entry in the backfill status table
    }

    output: {
    execute_backfill: true // Result of the lambda dictacting whether a backfill should be executed.
    }
*/
package main

import (
	"context"
	"errors"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/google/uuid"

	"samsaradev.io/infra/dataplatform/lambdafunctions/util/middleware"
)

type CheckBackfillStatusesInput struct {
	Parents                 []string                 `json:"parents"`
	ParentsBackfillStatuses []dynamodb.GetItemOutput `json:"parent_backfill_statuses"`
	NodeBackfillStatus      dynamodb.GetItemOutput   `json:"node_backfill_status"`
}

type CheckBackfillStatusesOutput struct {
	ExecuteBackfill     bool   `json:"execute_backfill"`
	BackfillExecutionID string `json:"backfill_execution_id"`
}

func itemBackfillEntryExists(item dynamodb.GetItemOutput) bool {
	if item.Item != nil && item.Item["backfill_status"] != nil {
		return true
	}

	return false
}

func itemBackfillEntrySuccessful(item dynamodb.GetItemOutput) bool {
	if item.Item != nil && item.Item["backfill_status"] != nil && aws.StringValue(item.Item["backfill_status"].S) == "SUCCESS" {
		return true
	}

	return false
}

func checkBackfillStatusForNode(ctx context.Context, input CheckBackfillStatusesInput) (CheckBackfillStatusesOutput, error) {
	nodeBackfillEntryExists := itemBackfillEntryExists(input.NodeBackfillStatus)
	numParents := len(input.Parents)
	numParentBackfillStatuses := len(input.ParentsBackfillStatuses)
	numCompletedParents := 0
	for _, item := range input.ParentsBackfillStatuses {
		if itemBackfillEntrySuccessful(item) {
			numCompletedParents++
		}
	}

	var executeBackfill bool
	switch {
	case nodeBackfillEntryExists:
		executeBackfill = false
	case numParents != numParentBackfillStatuses:
		executeBackfill = false
	case numParents != numCompletedParents:
		executeBackfill = false
	case numParents == numCompletedParents:
		executeBackfill = true
	default:
		return CheckBackfillStatusesOutput{}, errors.New("unexpected backfill status result")
	}

	// TODO: Remove backfill execution ID once sharding is implemented, since sharding lambda creates its own execIds @Albert J
	return CheckBackfillStatusesOutput{
		ExecuteBackfill:     executeBackfill,
		BackfillExecutionID: uuid.New().String(),
	}, nil
}

func LambdaFunction(ctx context.Context, input CheckBackfillStatusesInput) (CheckBackfillStatusesOutput, error) {
	return checkBackfillStatusForNode(ctx, input)
}

func main() {
	middleware.StartWrapped(LambdaFunction, middleware.LogInputOutput)
}
