package datapipelines

import (
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/samsarahq/go/oops"

	"samsaradev.io/helpers/fileformatter"
	"samsaradev.io/helpers/ni/filepathhelpers"
	"samsaradev.io/infra/dataplatform/datapipelines/configvalidator"
	"samsaradev.io/infra/dataplatform/datapipelines/graphs"
	"samsaradev.io/infra/dataplatform/datapipelines/nodetypes"
)

type dataPipelineOwnership struct {
	AllPipelines    []string
	AllNodes        []string
	TeamToPipelines map[string][]string
	TeamToNodes     map[string][]string
	NodesToSFNNames map[string][]string
}

var dataPipelineOwnershipTemplate = `// Code generated by taskrunner gen/dataplatform/datapipelineownership; DO NOT EDIT.
package datapipelines

var AllPipelines = []string{
{{range .AllPipelines -}}
{{"\t"}}"{{.}}",
{{end}}}

var AllNodes = []string{
{{range .AllNodes -}}
{{"\t"}}"{{.}}",
{{end}}}

var TeamToPipeline = map[string][]string{
{{range $team, $pipelines := .TeamToPipelines -}}
{{"\t"}}"{{$team}}": { {{range $pipelines}}
		{{"\t"}}{{"\t"}}"{{.}}",
	{{- end}}
	},
{{end}}}

var TeamToNodes = map[string][]string{
{{range $team, $nodes := .TeamToNodes -}}
{{"\t"}}"{{$team}}": { {{range $nodes}}
		{{"\t"}}{{"\t"}}"{{.}}",
	{{- end}}
	},
{{end}}}

var NodesToSFNNames = map[string][]string{
{{range $node, $sfns := .NodesToSFNNames -}}
{{"\t"}}"{{$node}}": { {{range $sfns}}
		{{"\t"}}{{"\t"}}"{{.}}",
	{{- end}}
	},
{{end}}}
`

func GenerateDataPipelineOwnershipFile() error {
	pipelines, err := graphs.BuildDAGs()
	if err != nil {
		return oops.Wrapf(err, "error building DAGs")
	}

	teamToPipelines := make(map[string][]string)
	nodeToSFNName := make(map[string][]string)
	allPipelines := []string{}
	for _, pipeline := range pipelines {
		owner := pipeline.GetLeafNodes()[0].Owner().TeamName
		if _, ok := teamToPipelines[owner]; !ok {
			teamToPipelines[owner] = []string{}
		}

		teamToPipelines[owner] = append(teamToPipelines[owner], pipeline.Name())
		allPipelines = append(allPipelines, pipeline.Name())

		for _, node := range pipeline.GetNodes() {
			nodeName := node.Name()
			if _, ok := nodeToSFNName[nodeName]; !ok {
				nodeToSFNName[nodeName] = []string{}
			}

			// Step Functions don't like period so we replace it with a dash
			nodeToSFNName[nodeName] = append(nodeToSFNName[nodeName], strings.Replace(pipeline.Name(), ".", "-", -1))

			// Add the sqlite node to the nodes list, if it exists
			if node.SqliteNodeName() != nil {
				sqliteNodeName := *node.SqliteNodeName()
				nodeToSFNName[sqliteNodeName] = append(nodeToSFNName[sqliteNodeName], strings.Replace(pipeline.Name(), ".", "-", -1))
			}
		}
	}

	sort.Strings(allPipelines)
	sortSliceMap(teamToPipelines)
	sortSliceMap(nodeToSFNName)

	nodes, err := configvalidator.ReadNodeConfigurations()
	if err != nil {
		return oops.Wrapf(err, "error reading node configurations")
	}

	teamToNodes := make(map[string][]string)
	allNodes := []string{}
	for _, node := range nodes {
		owner := node.Owner.TeamName
		if _, ok := teamToPipelines[owner]; !ok {
			teamToNodes[owner] = []string{}
		}

		teamToNodes[owner] = append(teamToNodes[owner], node.Name)
		allNodes = append(allNodes, node.Name)

		// Add the sqlite node to the nodes list, if it exists
		dagNode := nodetypes.NodeConfigToDAGNode(node)
		if dagNode.SqliteNodeName() != nil {
			sqliteNodeName := *dagNode.SqliteNodeName()
			teamToNodes[owner] = append(teamToNodes[owner], sqliteNodeName)
			allNodes = append(allNodes, sqliteNodeName)
		}
	}

	sort.Strings(allNodes)
	sortSliceMap(teamToNodes)

	tmpl, err := template.New("datapipelines_ownership_template").Parse(dataPipelineOwnershipTemplate)
	if err != nil {
		return oops.Wrapf(err, "error parsing datapipelines ownership template string into text.Template")
	}

	f, err := os.Create(filepath.Join(filepathhelpers.BackendRoot, "go/src/samsaradev.io/infra/dataplatform/datapipelines/ownership.go"))
	if err != nil {
		return oops.Wrapf(err, "unable to create file at 'go/src/samsaradev.io/infra/dataplatform/datapipelines/ownership.go'")
	}

	return fileformatter.ExecuteTmplWithFormat(f, dataPipelineOwnership{
		AllPipelines:    allPipelines,
		AllNodes:        allNodes,
		TeamToPipelines: teamToPipelines,
		TeamToNodes:     teamToNodes,
		NodesToSFNNames: nodeToSFNName,
	}, tmpl, fileformatter.Golang)
}

func sortSliceMap(m map[string][]string) {
	for key := range m {
		sort.Strings(m[key])
	}
}
