// Code generated by generate_db_boilerplate. DO NOT EDIT.

package main

import (
	"log"

	"samsaradev.io/infra/dataplatform/dataplatformtestinternalmodels"
	"samsaradev.io/infra/dbtools/dbhelpers"
	"samsaradev.io/infra/dbtools/dbversionstate"
	"samsaradev.io/infra/dbtools/migratehelpers"
	"samsaradev.io/infra/samsaraaws"
)

func runGeneratedMigrations(app *migrateApp, versionStateMap map[string]int) {
	var err error
	shardedDataplatformtestinternalConfig := app.Config.GetShardedDataplatformtestinternalConfig()
	shardsSucceeded := 0
	for shardName, shardPair := range shardedDataplatformtestinternalConfig.Shards {
		if samsaraaws.IsRunningInECS() {
			var currentVersion int
			// These are different shards and therefore inherently separate calls. We must make this call once per shard rather than in batch.
			// skiplint: +loopedexpensivecall
			if err := migratehelpers.WithDatabase(shardPair.Writer, func(db *dbhelpers.Database) error {
				verbose := false
				res, err := dbhelpers.GetCurrentVersionFromDB(shardPair.Writer.DatabaseName, db, verbose)
				if err != nil {
					return err
				}
				currentVersion = res
				return nil
			}); err != nil {
				log.Printf("cannot decide if schema check for shard %s is necessary: %s", shardName, err)
			}
			checkedInVersion := dataplatformtestinternalmodels.Versions.Applied
			// This is the location of the checked in schema in the docker container.
			checkedInFile := "/db_schema.sql"
			if currentVersion == checkedInVersion {
				log.Printf("migrate: Running schema checker for shard %s\n", shardName)
				if err := migratehelpers.RunSchemaCheck(shardPair.Writer, checkedInFile, app.launchDarklyBridge); err != nil {
					// Do not fail for now until we are sure all production schema are the same as the
					// checked in ones. We can detect this by searching the log for the error message.
					log.Println(err)
				}
			} else {
				log.Printf("migrate: checked in version in code (%d) is different from version state (%d) for this shard (%s). Not running schema check.\n", checkedInVersion, currentVersion, shardName)
			}
		}

		log.Printf("migrate %s: app.DataplatformtestinternalModels.Migrate()", shardName)
		versionStateMap[shardPair.Writer.Type], err = dbhelpers.MigratePending(dataplatformtestinternalmodels.Versions, shardPair.Writer, true, false)
		if err != nil {
			log.Fatalf("migrate failed for shard %v: %v", shardName, err)
		}
		shardsSucceeded++
	}

	if !app.Config.IsDevEnv() && shardsSucceeded == len(shardedDataplatformtestinternalConfig.Shards) {
		if err := dbversionstate.WriteDBVersions(versionStateMap, app.dbState, "dataplatformtestinternal"); err != nil {
			log.Fatalln("failed to write db versions to s3")
		}
	}

}
